<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>The Dice Maker</title><link>http://suraciii.github.io/</link><description>Recent content on The Dice Maker</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 27 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://suraciii.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Release Flow: 为持续交付而优化的分支策略</title><link>http://suraciii.github.io/posts/release-flow/</link><pubDate>Sat, 27 Jan 2024 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/release-flow/</guid><description>&lt;p>在快节奏的软件开发世界中，有效的分支策略对于确保顺利协作、并行开发和及时发布至关重要。Release Flow是一种&lt;strong>基于主干的分支策略&lt;/strong>，使团队能够实现更快的迭代、持续集成和可扩展性，目标是最大程度地减少向客户发布新功能所需的时间，同时仍保持高度的稳定性和可靠性。&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/release-flow/release-flow.png" alt="">&lt;/p>
&lt;h2 id="开发">开发&lt;/h2>
&lt;p>Release Flow下，在开发功能或者修复缺陷时，第一步是从主干分支（&lt;code>main&lt;/code>/&lt;code>master&lt;/code>）中创建出一个新的本地分支，使用这个新的本地分支来编写代码，这些新分支需要是“短暂”的，即这些分支需要尽早地（通常是一天到几天内）合并回主干分支，在合并前可以按需插入&lt;code>代码审阅&lt;/code>、&lt;code>构建及单元测试&lt;/code>、&lt;code>代码安全扫描&lt;/code>等环节&lt;/p>
&lt;p>主干分支需要被保证是永远“可用”的，即主干分支上的代码需要保证可成功构建以及通过所有的自动化持续集成流水线环节。&lt;/p>
&lt;p>推荐的本地分支名：&lt;code>feat/xxx&lt;/code>, &lt;code>user/xxx/feat/xxx&lt;/code>等&lt;/p>
&lt;p>如果某些功能的开发时间较长怎么办：仍然尽早合并，但是使用&lt;code>功能开关&lt;/code>，避免未开发完整的功能破坏主干的完整性和可用性&lt;/p>
&lt;p>条件允许的情况下，可以将主干分支的代码持续部署到一个临时的环境中，以便于开发者和QA可以尽快地对其进行检验，获得更紧密的反馈周期。&lt;/p>
&lt;h2 id="发布">发布&lt;/h2>
&lt;p>在当前发布周期的开发任务完成后，即可从主干分支中创建出发布分支，以进行当前发布周期的发布工作。发布分支是专门为发布创建的长生命周期的分支。它们提供了隔离和稳定性，允许开发团队准备和测试版本，而不会干扰主线分支上正在进行的开发。&lt;/p>
&lt;p>在大多数情况下，发布分支的代码不会直接交付到生产环境，可以按需构建版本发布的流水线来进行逐步发布，如先发布到预发布环境做最后的验收测试，验收测试通过后，则通过金丝雀部署等方式部分发布到生产环境，通过线上监控和用户反馈收集确认版本可靠性后，再最终发布到所有线上用户。&lt;/p>
&lt;p>推荐的分支名：&lt;code>rel/202401&lt;/code>, &lt;code>rel/m121&lt;/code>等，没有必要也不推荐使用语义版本(&lt;code>1.2.1&lt;/code>风格)作为分支名&lt;/p>
&lt;p>部分发布的方式：&lt;/p>
&lt;ol>
&lt;li>线上部署新版本的同时，保留老版本，结合流量控制（通过Service Mesh等技术），将随机的少部分请求(例如5%)引导至新版本上。&lt;/li>
&lt;li>直接部署新版本，结合功能开关，将新版本的功能首先提供给部分用户（比如内部测试用户）&lt;/li>
&lt;/ol>
&lt;p>注意：发布分支不会合并回主干分支，一旦某发布分支的版本在生产环境已经完全被更新，这个发布分支就失去了存在的意义，可以直接删除掉&lt;/p>
&lt;h2 id="缺陷修复">缺陷修复&lt;/h2>
&lt;p>当有缺陷被确认时：&lt;/p>
&lt;ol>
&lt;li>首先从主干分支中创建出修复分支，在修复分支上进行编码&lt;/li>
&lt;li>将修复分支合并到主干分支&lt;/li>
&lt;li>将修复分支上的改动挑选(&lt;code>cherry-pick&lt;/code>)到发布分支&lt;/li>
&lt;/ol>
&lt;p>为什么从主干分支而非发布分支进行修复：如果我们首先修复发布分支，则很有可能忘记将此修复合并回主干分支，从而导致被修复的缺陷在下个版本发布时再次出现&lt;/p>
&lt;p>一个例外情况是：如果此缺陷只在发布分支存在，在主干分支中已经因为重构或者其它原因不再存在，则可以无视主分支，直接将修复分支合并到发布分支&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/release-flow/pipelines.png" alt="">&lt;/p>
&lt;h2 id="一些经验">一些经验&lt;/h2>
&lt;ul>
&lt;li>保持简单&lt;/li>
&lt;li>避免高成本的分支合并&lt;/li>
&lt;li>将代码组织成可交付的单元&lt;/li>
&lt;li>分别给集成和发布准备单独的自动化流水线&lt;/li>
&lt;li>缩短反馈周期，尽量早地获得反馈&lt;/li>
&lt;li>工具不是万能的，但是工具很有用&lt;/li>
&lt;li>不要为每个环境设置单独的分支&lt;/li>
&lt;/ul></description></item><item><title>使用k6进行负载测试</title><link>http://suraciii.github.io/posts/load-testing-k6/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/load-testing-k6/</guid><description>&lt;h2 id="k6">k6&lt;/h2>
&lt;p>k6是一款来自Grafana的开源的负载测试工具。&lt;/p>
&lt;p>官方说法中，K6的特点是：&lt;/p>
&lt;ul>
&lt;li>提供简单易用的CLI工具，具有开发人员友好的API。&lt;/li>
&lt;li>使用 JavaScript ES2015/ES6 编写脚本 - 支持本地和远程模块&lt;/li>
&lt;li>检查(Checks)和阈值(Thresholds) - 用于面向目标、自动化友好的负载测试&lt;/li>
&lt;/ul>
&lt;h3 id="和其它负载工具测试对比">和其它负载工具测试对比&lt;/h3>
&lt;h3 id="jmeter">JMeter&lt;/h3>
&lt;ul>
&lt;li>k6没有界面化的UI，需要编写基于JavaScript的测试脚本，以及通过命令行来执行测试，这意味着k6的使用者需要具备一些基本的编码能力&lt;/li>
&lt;li>不像JMeter，k6可以轻松地集成到自动化的DevOps流水线中&lt;/li>
&lt;li>k6只支持HTTP相关的负载测试(HTTP1/2, gRPC, WebSockets等)&lt;/li>
&lt;li>k6的性能强劲并且效率高，即使在配置一般的笔记本电脑上也能轻松跑出上万级别的qps&lt;/li>
&lt;/ul>
&lt;h3 id="gatling">Gatling&lt;/h3>
&lt;ul>
&lt;li>学习成本没有Gatling高（主要是因为Scala的学习成本比较高）&lt;/li>
&lt;li>同样，相对于Gatling，k6的性能和效率非常出色&lt;/li>
&lt;li>Gatling只在高级版本支持分布式负载&lt;/li>
&lt;/ul>
&lt;h3 id="vegeta">Vegeta&lt;/h3>
&lt;ul>
&lt;li>k6的性能和效率略微逊色于Vegeta&lt;/li>
&lt;li>Vegeta不支持脚本化测试，使用起来比较不方便&lt;/li>
&lt;/ul>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>对于开发者或者具备一些JavaScript编码能力的测试人员来说，k6使用起来非常方便，其性能高，成本低，可以方便地集成进自动化流水线，支持分布式负载&lt;/p>
&lt;h2 id="一般使用姿势">一般使用姿势&lt;/h2>
&lt;p>k6使用起来非常简单，只需要3步&lt;/p>
&lt;h3 id="1-安装">1. 安装&lt;/h3>
&lt;p>MacOS下可以通过&lt;code>brew install k6&lt;/code>命令安装&lt;/p>
&lt;p>Windows下，如果安装了&lt;code>Chocolatey&lt;/code>或者&lt;code>winget&lt;/code>等包管理工具，可以通过工具命令安装&lt;/p>
&lt;p>或者，访问github.com/grafana/k6/releases，下载对应的安装包或可执行文件&lt;/p>
&lt;h3 id="2-编写脚本">2. 编写脚本&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">import&lt;/span> { &lt;span style="color:#728e00">check&lt;/span> } &lt;span style="color:#728e00">from&lt;/span> &lt;span style="color:#7f8c8d">&amp;#39;k6&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">import&lt;/span> &lt;span style="color:#728e00">http&lt;/span> &lt;span style="color:#728e00">from&lt;/span> &lt;span style="color:#7f8c8d">&amp;#39;k6/http&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">export&lt;/span> &lt;span style="color:#728e00">default&lt;/span> &lt;span style="color:#728e00">function&lt;/span> () {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">const&lt;/span> &lt;span style="color:#728e00">url&lt;/span> &lt;span style="color:#728e00">=&lt;/span> &lt;span style="color:#7f8c8d">`&lt;/span>&lt;span style="color:#7f8c8d">${&lt;/span>&lt;span style="color:#728e00">baseUrl&lt;/span>&lt;span style="color:#7f8c8d">}&lt;/span>&lt;span style="color:#7f8c8d">/items`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">const&lt;/span> &lt;span style="color:#728e00">req_body&lt;/span> &lt;span style="color:#728e00">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f8c8d">&amp;#34;foo&amp;#34;&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;bar&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">const&lt;/span> &lt;span style="color:#728e00">params&lt;/span> &lt;span style="color:#728e00">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">headers&lt;/span>&lt;span style="color:#728e00">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f8c8d">&amp;#39;Content-Type&amp;#39;&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#39;application/json&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">const&lt;/span> &lt;span style="color:#728e00">res&lt;/span> &lt;span style="color:#728e00">=&lt;/span> &lt;span style="color:#728e00">http&lt;/span>.&lt;span style="color:#728e00">post&lt;/span>(&lt;span style="color:#728e00">url&lt;/span>, &lt;span style="color:#728e00">JSON&lt;/span>.&lt;span style="color:#728e00">stringify&lt;/span>(&lt;span style="color:#728e00">req_body&lt;/span>), &lt;span style="color:#728e00">params&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">check&lt;/span>(&lt;span style="color:#728e00">res&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f8c8d">&amp;#39;status is 200&amp;#39;&lt;/span>&lt;span style="color:#728e00">:&lt;/span> () =&amp;gt; &lt;span style="color:#728e00">res&lt;/span>.&lt;span style="color:#728e00">status&lt;/span> &lt;span style="color:#728e00">===&lt;/span> &lt;span style="color:#8a7b52">200&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="3-执行">3. 执行&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>k6 run --vus &lt;span style="color:#8a7b52">400&lt;/span> --duration 3m mytest.js
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>(启动400个vu，持续执行3分钟)&lt;/p>
&lt;p>等待执行结果：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-log" data-lang="log">✓ status is 200
█ setup
checks.........................: 100.00% ✓ 495418 ✗ 0
data_received..................: 116 MB 642 kB/s
data_sent......................: 371 MB 2.1 MB/s
http_req_blocked...............: avg=38.93µs min=924ns med=2.45µs max=80.93ms p(90)=3.56µs p(95)=4.48µs
http_req_connecting............: avg=5.88µs min=0s med=0s max=30.2ms p(90)=0s p(95)=0s
http_req_duration..............: avg=145.1ms min=10.55ms med=109.6ms max=2.99s p(90)=296.31ms p(95)=372.08ms
{ expected_response:true }...: avg=145.1ms min=10.55ms med=109.6ms max=2.99s p(90)=296.31ms p(95)=372.08ms
http_req_failed................: 0.00% ✓ 0 ✗ 495418
http_req_receiving.............: avg=1.28ms min=12.33µs med=307.76µs max=120.82ms p(90)=3.44ms p(95)=5.25ms
http_req_sending...............: avg=31.82µs min=7.4µs med=16.63µs max=135.44ms p(90)=28.31µs p(95)=46.41µs
http_req_tls_handshaking.......: avg=0s min=0s med=0s max=0s p(90)=0s p(95)=0s
http_req_waiting...............: avg=143.79ms min=10.49ms med=108.24ms max=2.98s p(90)=294.81ms p(95)=370.19ms
http_reqs......................: 495418 2749.134151/s
iteration_duration.............: avg=145.37ms min=300.04µs med=109.85ms max=2.99s p(90)=296.56ms p(95)=372.5ms
iterations.....................: 495418 2749.134151/s
vus............................: 400 min=0 max=400
vus_max........................: 400 min=400 max=400
&lt;/code>&lt;/pre>&lt;h2 id="在kubernetes中进行分布式负载测试">在Kubernetes中进行分布式负载测试&lt;/h2>
&lt;p>分布式负载测试需要在Kubernetes中安装&lt;code>k6-operator&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>curl https://raw.githubusercontent.com/grafana/k6-operator/main/bundle.yaml | kubectl apply -f -
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装完成后，需要将测试脚本写入ConfigMap中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>kubectl create configmap mytest --from-file &lt;span style="color:#7f8c8d">&amp;#34;mytest.js&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>script.js
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>之后，通过在Kubernetes中创建一个类型为&lt;code>K6&lt;/code>的资源，来执行测试：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">apiVersion&lt;/span>: k6.io/v1alpha1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">kind&lt;/span>: K6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">name&lt;/span>: mytest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">runner&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">image&lt;/span>: registry.cn-hangzhou.aliyuncs.com/surac/grafana-operator:latest-runner
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6"># 这个镜像以及下面的镜像是我自己打包的，如果需要用到一些额外的k6扩展，则需要自己打包镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">starter&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">image&lt;/span>: registry.cn-hangzhou.aliyuncs.com/surac/grafana-operator:latest-starter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">parallelism&lt;/span>: &lt;span style="color:#8a7b52">4&lt;/span> &lt;span style="color:#95a5a6">#并行实例数，测试任务会分摊到各个实例执行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">script&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">configMap&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">name&lt;/span>: mytest.js
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">file&lt;/span>: mytest.js
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>kubectl apply -f mytest.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>k6-operator发现这个资源被创建后，就会创建1个启动&lt;code>Job&lt;/code>和4个执行&lt;code>Job&lt;/code>，来执行测试任务，可以通过&lt;code>kubectl get jobs&lt;/code>来观察&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-log" data-lang="log">NAME COMPLETIONS DURATION AGE
mytest-1 1/1 115s 440d
mytest-2 1/1 114s 440d
mytest-3 1/1 79s 440d
mytest-starter 1/1 2s 440d
&lt;/code>&lt;/pre>&lt;h2 id="最后">最后&lt;/h2>
&lt;p>k6还有许多功能，比如：&lt;/p>
&lt;ul>
&lt;li>阈值(Thresholds)，比如设定“请求的错误率&amp;gt;1%”或者“p99延迟&amp;gt;500ms”时提前结束测试并视为失败，很适合针对服务的SLO来进行测试&lt;/li>
&lt;li>支持将测试指标写到Prometheus，这样就可以在做负载测试时，将QPS、延迟等指标结合服务的CPU、内存、线程等指标进行观察，并且浏览和统计数据也很方便&lt;/li>
&lt;/ul></description></item><item><title>事件驱动架构：设计好的事件</title><link>http://suraciii.github.io/posts/eda-events/</link><pubDate>Thu, 27 Jul 2023 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/eda-events/</guid><description>&lt;p>当我们在系统中发送一些消息时，可能会有以下三种原因：&lt;/p>
&lt;ul>
&lt;li>我要对方为我做某些事&lt;/li>
&lt;li>系统中发生了某些事&lt;/li>
&lt;li>我想知道对方的某些信息&lt;/li>
&lt;/ul>
&lt;p>在这三种场景中的三种不同的消息分别对应着命令，事件和查询&lt;/p>
&lt;p>我喜欢用一个星巴克的例子来解释这三种形式的消息：&lt;/p>
&lt;ul>
&lt;li>当你走进一家星巴克，但是你有些犹豫要喝点什么，于是你问店员最近有什么新品 —— 这是查询&lt;/li>
&lt;li>想来想去，你最终还是只想来上一杯拿铁，于是你礼貌却强硬地要求店员为你调制一杯拿铁，你会一直紧紧地盯着他，除非拿到小票，否则你不会离开收银台 —— 这是命令&lt;/li>
&lt;li>咖啡师将做好的拿铁放在取餐处，对着空气大喊了一声“X先生/女士的拿铁好了”后转身离开，他不关心你是否听到了，甚至不关心你是否还在此处 —— 这是事件&lt;/li>
&lt;/ul>
&lt;p>（这个例子的灵感来源于《星巴克不用2PC》;））&lt;/p>
&lt;p>总结下来，这三种形式的消息具有以下的特性：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>消息&lt;/th>
&lt;th>行为/状态变更&lt;/th>
&lt;th>需要响应&lt;/th>
&lt;th>接收人&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>命令&lt;/td>
&lt;td>请求发生&lt;/td>
&lt;td>也许&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>事件&lt;/td>
&lt;td>刚发生过&lt;/td>
&lt;td>否&lt;/td>
&lt;td>0..N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>查询&lt;/td>
&lt;td>无&lt;/td>
&lt;td>是&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>理解这三种消息，尤其是命令与事件之间的区别，对于如何设计一个成功的事件驱动系统来说至关重要&lt;/p>
&lt;h2 id="以事件替代命令">以事件替代命令&lt;/h2>
&lt;p>假设一个场景：在一个电商微服务系统中，有着若干个模块，其中包括&lt;/p>
&lt;ul>
&lt;li>商品目录模块： 负责维护商品信息&lt;/li>
&lt;li>购物车模块： 负责维护顾客的购物车信息&lt;/li>
&lt;/ul>
&lt;p>假设我们需要实现一个功能：在运营人员变更商品价格后，更新用户购物车中的商品价格&lt;/p>
&lt;p>一个直观的实现方式是，为&lt;code>购物车模块&lt;/code>实现一个用于更新顾客购物车中的商品价格的接口(在微服务系统中，这通常是一个REST或RPC的API)，并由&lt;code>商品目录模块&lt;/code>在更新商品价格时进行调用&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/eda-events/1.png" alt="">&lt;/p>
&lt;p>稍有经验的开发者就能看出，这样的设计有着几个问题：&lt;/p>
&lt;ul>
&lt;li>对顾客购物车的更新阻塞了对商品价格的更新&lt;/li>
&lt;li>在分布式系统中，网络请求具备着不确定性，尤其在请求链路较长和请求耗时较长的情况下更是如此&lt;/li>
&lt;li>由于网络中断，或者用户取消了请求，更新中断了，数据出现了不一致&lt;/li>
&lt;/ul>
&lt;p>而对于具备微服务架构设计经验的人来说，很可能还会看到另外的问题：&lt;/p>
&lt;p>在这种模式下，&lt;code>商品目录模块&lt;/code>调用了&lt;code>购物车模块&lt;/code>的一个接口，这使商品目录模块显式地依赖着购物车模块&lt;br>
而&lt;code>购物车模块&lt;/code>公开了一个接口，但是这个接口却不属于&lt;code>购物车模块&lt;/code>自己，这个接口是为了&lt;code>商品目录模块&lt;/code>而存在的，是为了响应对方的变化而存在的，并且，&lt;code>购物车模块&lt;/code>中的商品信息、价格信息等是来自于&lt;code>商品目录模块&lt;/code>中的业务知识，这意味着&lt;code>购物车模块&lt;/code>隐式地依赖着&lt;code>商品目录模块&lt;/code> &lt;br>
更何况，通常这种情况下，&lt;code>购物车模块&lt;/code>也会显式地依赖&lt;code>商品目录模块&lt;/code>——比如在用户添加商品到购物车时，购物车也许需要检查商品是否已被下架等&lt;/p>
&lt;p>这样，模块间出现了双向依赖，它的坏味道足以令敏感的架构师皱起眉头，甚至坐立难安，仿佛已经看到了在未来，随着系统的不断演进，这两个模块耦合的越来越深，任何改动都必须在二者上同时进行，或者是，其中一个模块的血液逐渐被另一个模块所吸食，成为一个只有CRUD没有自己的业务逻辑的贫血模块，最后逐渐被对方吞并，成为其中的一部分&lt;/p>
&lt;p>这时，我们也许可以换个角度来重新看这个功能：&lt;/p>
&lt;blockquote>
&lt;p>用户购物车中的商品价格，需要&lt;strong>响应&lt;/strong>商品价格信息的变更&lt;/p>
&lt;/blockquote>
&lt;p>按照这样的描述，我们来重新实现这个功能&lt;/p>
&lt;p>其中一个简单的做法是，&lt;code>购物车模块&lt;/code>根本不保存商品的价格信息，而是只在需要这些信息时，才前往&lt;code>商品目录模块&lt;/code>进行查询，这种方式解决了上面所说的问题，简单而有效，但是这基本只适合我们例子里的当前场景，当业务逻辑更丰满，更复杂起来后，就行不通了，比如，如果需要给购物车中有商品降价的顾客发送促销通知。
（事实上，如果没有这样的复杂场景的话，&lt;code>购物车模块&lt;/code>也就没有存在的必要了）&lt;/p>
&lt;p>因此，此时就适合以事件的方式来完成模块间的通信&lt;/p>
&lt;p>在商品价格变更后，&lt;code>商品目录模块&lt;/code>发布一条名为&amp;quot;商品价格已变更(&lt;code>CatalogItemPriceChanged&lt;/code>)&amp;ldquo;的事件到事件基础设施，而任何对此事件感兴趣的模块，都可以通过事件基础设施订阅此事件，订阅事件后，由事件基础设施负责将事件交付到相关模块，并由各模块对此进行响应&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/eda-events/2.png" alt="">&lt;/p>
&lt;p>在这种情况下，&lt;code>商品目录模块&lt;/code>对&lt;code>购物车模块&lt;/code>的显式依赖被&lt;strong>反转&lt;/strong>，购物车中的商品价格更新不再阻塞商品目录模块中的业务执行，&lt;em>最终&lt;/em>也保证了数据的一致性&lt;/p>
&lt;h2 id="事件协作">事件协作&lt;/h2>
&lt;p>说完两个模块之间的通讯，再来看事件的协作
既然说是“事件驱动架构”，那么当然就要以事件来触发模块中的业务行为，甚至理所当然地会想到要以事件来驱动整个业务流程，还是以电商系统为例，实现事件驱动架构，经常就会很自然地产出类似下面的事件流(EventFlow)：&lt;/p>
&lt;ul>
&lt;li>用户创建订单，&lt;code>订单模块&lt;/code>发布&lt;code>订单已创建&lt;/code>事件&lt;/li>
&lt;li>&lt;code>支付模块&lt;/code>订阅&lt;code>订单已创建&lt;/code>事件，处理完成后发布&lt;code>支付已完成&lt;/code>事件&lt;/li>
&lt;li>&lt;code>库存模块&lt;/code>订阅&lt;code>支付已完成&lt;/code>事件，处理完成后发布&lt;code>商品已出库&lt;/code>事件&lt;/li>
&lt;li>&lt;code>配送模块&lt;/code>订阅&lt;code>商品已出库&lt;/code>事件，处理完成后发布&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://suraciii.github.io/eda-events/3.png" alt="">&lt;/p>
&lt;p>这里只是一个极度简化版的事件流，一个完整的流程应该还要包含相应的补偿事件，比如&lt;code>支付失败&lt;/code>和&lt;code>商品出库失败&lt;/code>等事件，以取得跨模块，跨数据库的最终的业务一致性（这被称为“Saga”）&lt;/p>
&lt;p>这样的系统中不仅以事件来触发模块中的业务行为，甚至也以事件来驱动着整个业务流程的流转，看起来十分地“事件驱动”，各个模块也看起来十分自治、低耦合，但是，实际上它可能会是一个非常糟糕的设计，如果没能在设计之初意识到这点，它可能会给项目带来巨大的痛苦和灾难。&lt;/p>
&lt;p>直觉上，和前面一样，是事件的消费方依赖于事件的生产方，即：&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/eda-events/4.png" alt="">&lt;/p>
&lt;p>但是当我们深入下去，可以看到，&lt;code>订单模块&lt;/code>需要通过响应来自&lt;code>支付模块&lt;/code>、&lt;code>库存模块&lt;/code>、&lt;code>配送模块&lt;/code>的事件来更新订单的当前进度（订单状态），以用来进行对退货退款等业务流程的校验，这没什么问题，跟踪订单的生命周期确实是&lt;code>订单模块&lt;/code>的职责，维护订单模块的开发者也乐于去响应这些事件。&lt;/p>
&lt;p>但是，对于其它模块则未必如此，比如&lt;code>支付模块&lt;/code>作为一个支撑模块，也许并不是仅仅支持订单业务，而是也会支持客户的订阅服务付款、自动续费、会员卡余额充值等支付场景，这种情况下，就需要&lt;code>支付模块&lt;/code>学习了解订单、订阅服务、会员卡等业务流程，需要准确地了解这些业务分别会发布哪些事件，需要知道哪些事件会&lt;strong>导致&lt;/strong>自己启动支付流程&lt;/p>
&lt;p>还有一种情况是业务流程发生了变更，比如说商城推出了针对VIP客户的先用后买服务，这时&lt;code>支付模块&lt;/code>对于其订阅到的&lt;code>订单已创建&lt;/code>事件，就需要根据&lt;code>订单类型&lt;/code>或者&lt;code>客户类型&lt;/code>来进行选择性的响应，而&lt;code>库存模块&lt;/code>则需要额外从&lt;code>订单模块&lt;/code>订阅&lt;code>订单已创建&lt;/code>事件来提前开启出库和发货流程&lt;/p>
&lt;p>这样，各个模块模糊了上下游的分界，互相依赖，大大增加了系统的复杂性，从而导致系统维护难度和成本增加，也更容易出问题&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/eda-events/5.png" alt="">&lt;/p>
&lt;p>对于各支撑模块，其内部引入了大量来自于各个业务场景上的业务逻辑，每次有新的业务场景或者业务流程发生变化都需要跟着进行改动，还要注意兼容已有的业务场景&lt;br>
而对于&lt;code>订单模块&lt;/code>，一方面，订单业务的变化很可能导致需要对多个模块进行修改，极大增加了开发成本，尤其是当这些模块是由不同团队独立开发时，另一方面，&lt;code>订单模块&lt;/code>也失去了对订单业务流程的控制力和可见性，这个问题在需要进行故障诊断时会显得更加严重&lt;/p>
&lt;p>此时，就可以考虑下以另外的风格来实现模块间的通讯，思考以下问题：&lt;/p>
&lt;ul>
&lt;li>在这个业务流程中，&lt;code>订单已创建&lt;/code>究竟是命令还是事件？&lt;/li>
&lt;li>谁应该控制和主导这个订单流程？或者说，谁该为这个流程负责？&lt;/li>
&lt;/ul>
&lt;p>显然，负责开发&lt;code>订单模块&lt;/code>的团队是这个订单流程的直接责任人，而&lt;code>订单模块&lt;/code>发出的&lt;code>订单已创建&lt;/code>消息并不是一个纯粹的事件，它确切地知道谁是这条消息的接收人，它需要保证&lt;code>支付模块&lt;/code>会收到这条消息并且执行后续的工作，它也十分关注着&lt;code>支付模块&lt;/code>对这条消息的响应所导致的后果（成功还是失败），所以与其说这是一条事件，不如说是一条命令&lt;/p>
&lt;p>我们不妨对上面的设计进行如下改动：&lt;/p>
&lt;ul>
&lt;li>将支撑模块（&lt;code>支付模块&lt;/code>、&lt;code>库存模块&lt;/code>、&lt;code>配送模块&lt;/code>）所抽象出的通用能力，以API的形式开放&lt;/li>
&lt;li>将类似&lt;code>订单已创建&lt;/code>这样的“命令式的事件”转化为命令&lt;/li>
&lt;li>由&lt;code>订单模块&lt;/code>来主导并控制业务的流转&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://suraciii.github.io/eda-events/6.png" alt="">&lt;/p>
&lt;p>这样，支撑模块中的代码就可以被简化，&lt;code>订单模块&lt;/code>也获得了对其核心业务流程的控制权，整个端到端的业务流程在代码中完整地体现，而如果业务流程需要改动，则只需要对&lt;code>订单模块&lt;/code>进行改动&lt;br>
有些人会提出质疑：随着业务越来越复杂，&lt;code>订单模块&lt;/code>不是会变得越来越臃肿最终成为一个“上帝服务”吗，我的看法是，是的，没错，也许会这样，但是，将业务复杂性集中在一个核心业务模块上，要好于将业务的复杂性扩散分布到系统的各个角落&lt;/p>
&lt;p>总之，事件并不总是美好的，事件驱动架构并不是说把所有的REST API替换成事件就完事了，想要搞好事件驱动架构，&lt;strong>不仅要知道什么时候应该用事件，还得知道什么时候不该用事件&lt;/strong>&lt;/p>
&lt;h2 id="事件中的信息">事件中的信息&lt;/h2>
&lt;p>最后再说下事件中的信息，正如前文所说，事件是一种消息，那这样的消息中应该携带哪些信息，携带多少信息，就是一个非常值得谨慎设计的地方&lt;/p>
&lt;p>以&lt;code>商品价格已变更&lt;/code>事件为例，其中一个思路是，既然&lt;code>购物车模块&lt;/code>需要响应这个事件，来告诉客户“您购物车里的商品比加入时降价了xxx元”，那么就为它来提供它所需要的信息吧&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">type&lt;/span> &lt;span style="color:#728e00">CatalogItemPriceChanged&lt;/span> &lt;span style="color:#728e00">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">catalogItemId&lt;/span>: &lt;span style="color:#00979d">string&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">currentPrice&lt;/span>: &lt;span style="color:#00979d">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看起来不错，事件足够简洁又提供了足够&lt;code>购物车模块&lt;/code>做出响应所需的全部信息，不多不少，恰到好处&lt;/p>
&lt;p>但是，这就陷入了上面提到过的“为事件的消费方定制事件”的局面，这是个非常不健康的现象，因为也许两个星期后&lt;code>购物车模块&lt;/code>就会跑过来说“嘿，麻烦发布事件的时候把&lt;code>商品类型&lt;/code>也带上”，如果这个事件还有&lt;code>购物车模块&lt;/code>之外的其它模块感兴趣，那就更危险了，&lt;code>商品目录模块&lt;/code>的每次改动都要小心避免破坏其它订阅此事件的模块对此事件的处理&lt;/p>
&lt;p>那能不能让事件携带尽量完整的信息呢，像这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">type&lt;/span> &lt;span style="color:#728e00">CatalogItemUpdated&lt;/span> &lt;span style="color:#728e00">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">previous&lt;/span>: &lt;span style="color:#00979d">CatalogItem&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">current&lt;/span>: &lt;span style="color:#00979d">CatalogItem&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">updatedBy&lt;/span>: &lt;span style="color:#00979d">Operator&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">comment&lt;/span>: &lt;span style="color:#00979d">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">type&lt;/span> &lt;span style="color:#728e00">CatalogItem&lt;/span> &lt;span style="color:#728e00">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">id&lt;/span>: &lt;span style="color:#00979d">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">name&lt;/span>: &lt;span style="color:#00979d">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">catogory&lt;/span>: &lt;span style="color:#00979d">CatalogCategory&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">tags&lt;/span>: &lt;span style="color:#00979d">Tag&lt;/span>[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是一个常见的做法，和前者的区别是事件模型不是为了消费者的业务逻辑而特别定制的，而是像公开REST API接口一样公开了自己上下文中的模型，消费方也能从事件中携带的数据里直接获得自己需要的信息而不需要进行额外的查询，坏消息是事件的消费方对于发布方的依赖和耦合会变得更加紧密&lt;/p>
&lt;p>此外，以上两种模式都属于“事件承载状态传输(Event-Carried State Transfer)”，将状态信息伴随着事件一起发布，使事件消费者不需要再度联系发布者即可进行后续工作。&lt;br>
在云原生时代，这么做会有一个不良后果，即它引入了对时间和顺序的耦合，导致事件的生产和消费都要去保证事件时序的正确，试想一下，如果&lt;code>商品目录模块&lt;/code>先后进行了两次对同一商品的价格更新，并发布了两个相关事件，如果这两个事件不是以其真实发生的顺序被&lt;code>购物车模块&lt;/code>处理，就会出现数据不一致的情况。
而如果需要强行保证事件的时序正确，比如在创建事件时标记时间戳或序号，并在消费时正确处理事件时序（比如严格遵循先进先出线性处理），则会大大牺牲系统的并行性和可扩展性（参见&amp;quot;The Universal Scalability Law&amp;rdquo;）&lt;/p>
&lt;p>这时，我们不妨去仔细思考一下，事件中的关键信息是哪些？哪些信息是至关重要的？&lt;/p>
&lt;p>首先，最关键的信息是事件名或者事件类型，它传达了“发生了什么”&lt;/p>
&lt;p>此外，事件还应该携带一些关键的上下文信息，比如：&lt;/p>
&lt;ul>
&lt;li>是谁发布了这个事件&lt;/li>
&lt;li>这个事件是在什么时间发生的&lt;/li>
&lt;li>这个事件是关于什么东西的&lt;/li>
&lt;li>事件的唯一标识&lt;/li>
&lt;/ul>
&lt;p>这里顺便介绍一下由CNCF主持制定的&lt;code>CloudEvents&lt;/code>规范，其提供了一种描述事件的通用格式，如果将我们上面例子里的事件以&lt;code>CloudEvents&lt;/code>规范实现的话，就是下面这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">&amp;#34;specversion&amp;#34;&lt;/span> : &lt;span style="color:#7f8c8d">&amp;#34;1.0&amp;#34;&lt;/span>, &lt;span style="color:#95a5a6">// CloudEvents规范版本
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">&lt;/span> &lt;span style="color:#434f54">&amp;#34;type&amp;#34;&lt;/span> : &lt;span style="color:#7f8c8d">&amp;#34;catalog.item.updated.v2&amp;#34;&lt;/span>, &lt;span style="color:#95a5a6">// 事件类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">&lt;/span> &lt;span style="color:#434f54">&amp;#34;source&amp;#34;&lt;/span> : &lt;span style="color:#7f8c8d">&amp;#34;https://catalogservice/items/123&amp;#34;&lt;/span>, &lt;span style="color:#95a5a6">// 事件源
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">&lt;/span> &lt;span style="color:#434f54">&amp;#34;subject&amp;#34;&lt;/span> : &lt;span style="color:#7f8c8d">&amp;#34;123&amp;#34;&lt;/span>, &lt;span style="color:#95a5a6">// 事件的主体
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">&lt;/span> &lt;span style="color:#434f54">&amp;#34;id&amp;#34;&lt;/span> : &lt;span style="color:#7f8c8d">&amp;#34;A234-1234-1234&amp;#34;&lt;/span>, &lt;span style="color:#95a5a6">// 事件唯一标识
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">&lt;/span> &lt;span style="color:#434f54">&amp;#34;time&amp;#34;&lt;/span> : &lt;span style="color:#7f8c8d">&amp;#34;2018-04-05T17:31:00Z&amp;#34;&lt;/span>, &lt;span style="color:#95a5a6">// 事件发生时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">&lt;/span> &lt;span style="color:#434f54">&amp;#34;datacontenttype&amp;#34;&lt;/span> : &lt;span style="color:#7f8c8d">&amp;#34;application/json&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">&amp;#34;data&amp;#34;&lt;/span> : &lt;span style="color:#7f8c8d">&amp;#34;{}&amp;#34;&lt;/span> &lt;span style="color:#95a5a6">// 事件数据，在这里不是必要的
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>按照我们上面的分析，&lt;code>catalog.item.updated.v2&lt;/code>事件可以不必携带更新后的商品信息，而是只发出“我有一个id为123的商品信息发生了变更”的通知，&lt;code>购物车模块&lt;/code>则可以订阅所有来自&lt;code>商品目录模块&lt;/code>的&lt;code>catalog.item.updated.v2&lt;/code>事件，在处理时向&lt;code>商品目录模块&lt;/code>发送查询来获取最新的商品信息&lt;/p>
&lt;p>这样，尽管产生了额外的一次网络请求，但是却换来了更低的耦合度，并且，通过使系统能够对时序不敏感，换来了可扩展性上的提升&lt;/p>
&lt;h2 id="最后">最后&lt;/h2>
&lt;p>老实说，这篇文章里并没有多少我原创性的东西，主要是对一些其他人分享的知识的引用和组合，以及对自己一些架构设计中受到的教训的反思和总结&lt;/p>
&lt;p>所以如果想更好地了解这些内容的话，可以参考下面列出来的一些资料&lt;/p>
&lt;p>后面打算写一写具体如何以Kafka和Redis实现事件基础设施，如何可靠地发布事件，以及如何在不牺牲可扩展性的情况下保证事件的处理时序&lt;/p>
&lt;h3 id="参考">参考：&lt;/h3>
&lt;ol>
&lt;li>&lt;a href="https://martinfowler.com/articles/201701-event-driven.html">What do you mean by “Event-Driven”? - Martin Fowler&lt;/a>&lt;/li>
&lt;li>&lt;a href=""> Designing Event-Driven Systems: Concepts and Patterns for Streaming Services with Apache Kafka - Ben Stopford&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.bernd-ruecker.com/how-to-tame-event-driven-microservices-5b30a6b98f86">How to tame event-driven microservices - Bernd Rücker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.bernd-ruecker.com/why-service-collaboration-needs-choreography-and-orchestration-239c4f9700fa">Why service collaboration needs choreography AND orchestration - David Boike&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://particular.net/blog/putting-your-events-on-a-diet">Putting your events on a diet - David Boike&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>事件驱动架构下的业务系统需要怎样的事件基础设施</title><link>http://suraciii.github.io/posts/eda-infra/</link><pubDate>Fri, 30 Jun 2023 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/eda-infra/</guid><description>&lt;p>这是一个简单的事件驱动架构下的工作流：&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/eda-infra/eda-workflow.png" alt="">&lt;/p>
&lt;p>这样的系统中，其相当一部分的业务流程是以相关事件的发布/订阅进行流转的，而在一些更为激进的事件驱动架构实现中，可能其内部绝大多数的交互都是是以事件而非命令（如HTTP/RPC等）的方式进行。&lt;/p>
&lt;p>设计良好的事件驱动架构的确有着一些优势，比如：&lt;/p>
&lt;ul>
&lt;li>耦合度低，更为灵活，向系统添加新模块较为方便&lt;/li>
&lt;li>具备较高的响应性，避免了上游的阻塞和等待&lt;/li>
&lt;li>具备高度的可扩展性和对分布式友好&lt;/li>
&lt;li>为业务流程提供了高度的弹性，或者说可恢复性，在分布式环境下，大量的命令式（HTTP/RPC）交互会带来大量的不确定性，如何面对这些不确定性，来让业务流程可靠、正确地进行下去成为了一个非常棘手的问题，而事件驱动架构就是解决这个问题的极佳方案之一&lt;/li>
&lt;/ul>
&lt;p>想要设计以及实现好这样的一个事件驱动架构的系统，就不得不考虑一个至关重要的问题：这个系统需要怎样的事件基础设施，即它应该如何收集事件，需要收集怎样的事件，它如何处理这些事件，以及如何交付这些事件&lt;/p>
&lt;p>&lt;em>事件驱动架构就像许多其它的架构概念一样，仍然是一个比较模糊的，抽象的概念，这里只讨论实现发布/订阅模式以事件驱动并支撑业务流程的业务系统，而不包括事件流处理系统&lt;/em>&lt;/p>
&lt;h2 id="不是什么">不是什么？&lt;/h2>
&lt;p>想要知道一个东西是什么的最好方法，就是首先搞清楚它不是什么&lt;/p>
&lt;h3 id="消息队列">消息队列&lt;/h3>
&lt;p>很容易进入的一个误区就是认为事件驱动架构需要的仅仅是一个消息队列，的确，事件总线通常基于消息队列产品（如Kafka、Pulsar等）实现，但是事件驱动系统需要的不仅仅是消息队列&lt;/p>
&lt;p>消息队列是队列，是有进有出，先进先出的，队列中的消息一旦出队被处理，它的任务就结束了，也就是说，消息是&lt;em>非持久&lt;/em>的&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/eda-infra/mq.png" alt="">&lt;/p>
&lt;p>消息队列只会有一方消费者，通常也只有一方生产者，当然，在现代分布式的微服务中，“一方”消费者或生产者也许会是具备多个实例副本的单个微服务
大多数情况下，消息队列中的消息的时序性需要被严格保证，消息出队的顺序需要严格符合消息的入队顺序&lt;/p>
&lt;p>而在事件驱动系统中，事件流中的事件会被持久化，并提供给可能的多方消费者消费，事件被消费处理后不会从事件流中移除，此外，事件消费者可能不会在意事件的交付顺序——在事件驱动系统中，业务的一致性通常是由事件产生的因果而非事件流中的事件顺序保证的，消费方只关心事件的到达，而不关心事件到达的顺序&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/eda-infra/event-stream.png" alt="">&lt;/p>
&lt;p>此外，消息队列中消息的处理及时性可能并不重要，有时甚至会故意选择牺牲消息的及时处理来交换系统的稳定性&lt;/p>
&lt;h3 id="事件溯源">事件溯源&lt;/h3>
&lt;p>另一个常见的误区是混淆事件驱动架构和事件溯源（Event Sourcing）&lt;/p>
&lt;p>事件溯源的核心是记录实体状态的变更而非记录实体的当前状态，并通过对变更记录的重放来投影出实体的最新状态&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/eda-infra/eventsourcing.png" alt="">&lt;/p>
&lt;p>因此，事件溯源需要持久化作为变更记录的事件，并提供严格的时序性保证&lt;/p>
&lt;p>事件驱动架构和事件溯源的相似之处在于，二者都会以业务事件作为载体（这通常会是业务领域中的领域事件），对事件进行存储以支持重放，但是二者之间有着巨大的差异：&lt;/p>
&lt;ul>
&lt;li>事件溯源只记录实体的变更，事件只存在于本上下文内，自产自销，而事件驱动架构中的事件则主要负责系统各模块间的通讯、交互，以驱动业务流程的流转&lt;/li>
&lt;li>事件溯源以实体为单元建立事件流，每个实体都有着各自的事件流，来记录此实体上发生过的变更，这也是为什么通常更适合选择数据库作为事件溯源的事件存储方案，而事件驱动架构中的事件流通常对应着各个上下文或者微服务&lt;/li>
&lt;li>在事件溯源中，事件的消费者需要了解实体变更的全部信息，而在事件驱动的业务系统中，事件可以只传达某个事实的发生，而隐藏其中的数据信息&lt;/li>
&lt;/ul>
&lt;p>事件溯源，本质上是业务实体的存储的一种实现，而事件驱动架构，则是关于系统各组件如何交互集成的方案&lt;/p>
&lt;h2 id="寻找适合事件驱动架构的事件基础设施">寻找适合事件驱动架构的事件基础设施&lt;/h2>
&lt;p>我们需要思考以下几点：&lt;/p>
&lt;h3 id="事件的投递保证">事件的投递保证&lt;/h3>
&lt;p>事件也是一种消息，而对于消息，就不得不考虑它的投递保证，投递保证有三种：&lt;/p>
&lt;ul>
&lt;li>最多一次投递，这种情况下事件可能会丢失不被处理&lt;/li>
&lt;li>最少一次投递，这种情况下同一事件可能会被投递多次，但是最终一定会被消费处理&lt;/li>
&lt;li>严格一次投递&lt;/li>
&lt;/ul>
&lt;p>对于事件驱动的业务系统来说，绝大多数场景下需要的都是&lt;code>严格一次投递&lt;/code>，无论是事件的丢失，或者事件的重复处理都会影响业务的一致性或者说正确性，这是不可接受的&lt;/p>
&lt;p>但是，在分布式环境下，单一组件想要实现&lt;code>严格一次投递&lt;/code>是不可能的，实际上最终只是从&lt;code>最多一次投递&lt;/code>和&lt;code>最少一次投递&lt;/code>中做选择，此时我们不得不选择&lt;code>最少一次投递&lt;/code>，然后在事件的消费端，通过记录已处理事件或业务校验来提供幂等性，最终在整体上做到&lt;strong>同一事件一定会被处理且只被处理一次&lt;/strong>&lt;/p>
&lt;p>实现&lt;code>最少一次投递&lt;/code>，就需要&lt;/p>
&lt;ol>
&lt;li>生产者在发布事件时重试直到事件被成功发布&lt;/li>
&lt;li>消费者一定会获取到没有被完全处理的事件&lt;/li>
&lt;li>消费者通过记录已处理事件，或者进行相关业务校验，来忽略掉重复的事件&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="http://suraciii.github.io/eda-infra/at-least-once.png" alt="">&lt;/p>
&lt;p>这样做有一个好处：当生产者发布事件时，它可以放心大胆地确认，只要事件被成功发布，那么这个事件就一定会被送达，这为分布式环境下的业务系统带来了至关重要的确定性，为保证业务（最终）一致性提供了巨大帮助&lt;/p>
&lt;h3 id="单方生产和多方消费">单方生产和多方消费&lt;/h3>
&lt;p>事件驱动架构下，事件可能会有多方消费者，一个模块发布的事件也许会被多个模块所关注&lt;br>
一个比较极端的例子是，当系统中某个用户被禁用时，多个微服务都需要对此事件做出响应&lt;/p>
&lt;p>但是，事件通常只有一个生产方，因为&lt;strong>业务事件是专属于某个上下文中所发生的影响业务的变化事实，事件标志着一个无可辩驳的事实已经发生&lt;/strong>，它具备极高的权威性
拿上面的例子来说，用户被禁用的事件只有用户服务才有资格发布，而其它服务如果想要禁用某个用户，比如当付款服务识别到了用户处于有风险的支付环境中，那么它应该做的是去&lt;strong>请求&lt;/strong>用户服务来禁用此用户，而不是直接告诉全系统“某某用户已被禁用”&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/eda-infra/single-publisher.png" alt="">&lt;/p>
&lt;p>此外，对于现代的分布式应用，通常会有多个实例副本以提高性能和可用性，这些实例副本同属于一个消费方，但却会是多个消费者，这就需要采用&lt;code>竞争消费&lt;/code>的模式来应对，即一个事件只会同一消费者组的其中一个消费者所消费&lt;/p>
&lt;h3 id="事件的处理顺序">事件的处理顺序&lt;/h3>
&lt;p>首先需要知道，&lt;strong>事件的处理顺序是否重要，取决于事件的发生顺序是否重要&lt;/strong>，比如，两个订单A和B几乎同时被请求创建并创建成功，那么哪个先被创建，哪个后被创建其实并不重要，因为首先这些创建订单的请求都未必能说清楚是哪个先到达，订单被创建的事件发布顺序也是不确定的，因此处理这两个事件的顺序也是不重要的，因为无论哪个先被处理哪个后被处理，都不影响业务一致性&lt;/p>
&lt;p>但是有些情况下，就需要重视事件的处理顺序，例如，同一订单，被创建和被取消的事件的处理顺序就十分重要了，如果订单取消事件先于订单创建事件到达，导致订单取消事件无法被正确的处理，就会破坏业务流程的一致性&lt;/p>
&lt;p>此时有两种选择，要么选择实现&lt;strong>有序的事件流&lt;/strong>，要么，就需要设计&lt;strong>时序不敏感&lt;/strong>的系统
这两种选择都会有所牺牲，如果选择有序事件流，则会严重降低事件的吞吐，以及系统的性能、可扩展性甚至可用性，如果精心设计（比如采用如Kafka等支持消息分区的技术产品），能够一定程度上降低系统性能和可扩展性的损失&lt;/p>
&lt;p>我更推荐去设计时序不敏感的系统，来让系统能够健康正常地处理乱序的事件，这需要一些学习成本，和架构改造成本，但是其带来的对性能、可扩展性、容错性以及灵活性上的提升是非常可观的&lt;/p>
&lt;p>&lt;em>关于时序不敏感的系统，以及设计时序不敏感的事件驱动架构，后面会单独写点东西讨论&lt;/em>&lt;/p>
&lt;h3 id="吞吐性能和可扩展性">吞吐性能和可扩展性&lt;/h3>
&lt;p>上面之所以纠结于事件的时序，就是放弃有序事件所带来的性能和可扩展性的提升对于现代云原生应用来说实在是太重要了，对于许多云原生应用来说，可扩展性是性能的前提，性能是响应性的前提&lt;/p>
&lt;p>甚至对于那些声称“不需要很高的性能也够用”的系统也是如此，因为对于可扩展性差的系统来说，也许几个月之后，当初“够用”的性能就会不够用了&lt;/p>
&lt;h3 id="近实时性">近实时性&lt;/h3>
&lt;p>尽管事件是一种异步的通讯方式，但它仍然要求具备较高的实时性，事件通常应该在其被发布的几秒内被处理，偶尔，也许出现分钟级别的处理延迟，但是如果处理延迟在10分钟以上，就十分不健康了，需要考虑是否因为消息的消费速度跟不上消息的生产速度而导致了消息的堆积，如果事件在发布几个小时后才被处理，那这个事件甚至可能已经失去意义了&lt;/p>
&lt;p>这也是事件驱动架构和普通消息队列的不同之处，事件是消息，是一种通讯方式，是驱动业务正常流转的载体，它需要提供较高的实时性，从而保证系统整体的高响应性&lt;/p>
&lt;h3 id="可观测性">可观测性&lt;/h3>
&lt;p>可观测性对于任何系统都有很高的价值，对于有着复杂交互的事件驱动架构的系统更是如此，良好的可观测性能够很好地帮助我们识别和诊断系统中的问题&lt;/p>
&lt;p>这其中一般包括日志、指标和链路追踪三个维度&lt;/p>
&lt;h3 id="事件流和路由">事件流和路由&lt;/h3>
&lt;p>事件基础设施需要考虑如何将接收到的事件整合成事件流，并以消费者的需求将不同事件投递给各个消费者来进行处理&lt;br>
大多数情况下会以主题（Topic）作为事件流，Topic是生产者发布事件的目的地，是消费者订阅事件的来源，事件生效的区域，和（可能的）顺序保证的有效区&lt;/p>
&lt;p>在发布/订阅模式下，相同事件会被送到相同的固定的某个Topic，在这个Topic下，这些事件所传达的信息是明确的，没有歧义的，消费者订阅某个Topic下的某个事件，并在事件到达时进行响应处理&lt;/p>
&lt;p>许多消息队列产品（如Kafka）只能在Topic层级进行路由，这种情况下就只能在消费端实现更细粒度的事件路由，将具体某个事件送到对应的处理逻辑进行处理&lt;/p>
&lt;p>这里就有个选择题，是 1. 每个消费方订阅一个Topic，生产方将不同事件发布到不同Topic中呢？还是 2. 生产方将事件发布到一个Topic，消费方订阅多个Topic并从中消费事件呢？&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/eda-infra/topics.png" alt="">&lt;/p>
&lt;p>这里应该选择后者，具体为什么牵涉到一个关于上下文依赖的设计问题，后面单独找时间写一写&lt;/p>
&lt;h2 id="未完待续">未完待续&lt;/h2>
&lt;p>关于事件驱动架构，后面准备写的有：&lt;/p>
&lt;ol>
&lt;li>如何设计事件驱动系统中的交互，或者说，如何设计事件&lt;/li>
&lt;li>结合Kafka和Redis，介绍具体如何实现最少一次交付，以及其中的时序问题和可扩展性问题，以及CloudEvent&lt;/li>
&lt;/ol>
&lt;p>能不能写出来再说吧&lt;/p></description></item><item><title>在EF Core中使用拦截器实现自动软删除</title><link>http://suraciii.github.io/posts/ef-soft-delete/</link><pubDate>Fri, 30 Jun 2023 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/ef-soft-delete/</guid><description>&lt;p>拦截器(Interceptor)是EF Core中的一种中间件形式的组件，可以用于在EF Core的工作流中注入用户代码，以进行拦截、修改一些特定的EF Core操作。&lt;/p>
&lt;p>下面以实现软删除为例。&lt;/p>
&lt;h2 id="ef-core中删除实体的流程">EF Core中删除实体的流程&lt;/h2>
&lt;p>在EF Core中，通常所有对实体的写操作（增删改）都需要被追踪，EF Core通过对实体对象进行追踪，对比并记录其状态变更，从而生成相应的数据库SQL语句。&lt;/p>
&lt;p>当我们调用&lt;code>DbContext.Remove(entity001)&lt;/code>时，其内部逻辑为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">// 获取此实体的入口（Entry），EntityEntry就像一个装着实体的瓶子，瓶子上贴着标签，表示着这个瓶子里的实体即将被同步到数据库中的变更&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">entry&lt;/span> = &lt;span style="color:#728e00">new&lt;/span> &lt;span style="color:#434f54">EntityEntry&lt;/span>(&lt;span style="color:#434f54">entity&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">initialState&lt;/span> = &lt;span style="color:#434f54">entry&lt;/span>.&lt;span style="color:#434f54">State&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">// 如果这是一个未被跟踪(Detached)的实体，则将实体的状态设置为已跟踪但没有发生变更(Unchanged)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">if&lt;/span> (&lt;span style="color:#434f54">initialState&lt;/span> == &lt;span style="color:#434f54">EntityState&lt;/span>.&lt;span style="color:#434f54">Detached&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">SetEntityState&lt;/span>(&lt;span style="color:#434f54">entry&lt;/span>.&lt;span style="color:#434f54">GetInfrastructure&lt;/span>(), &lt;span style="color:#434f54">EntityState&lt;/span>.&lt;span style="color:#434f54">Unchanged&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">// An Added entity does not yet exist in the database. If it is then marked as deleted there is&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">// nothing to delete because it was not yet inserted, so just make sure it doesn&amp;#39;t get inserted.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">// 如果此实体的初始状态为已添加(Added)，这意味着这个实体即将（但还没有）被插入到数据库中，此时只需要将其状态更改为`Detached`来保证这次数据插入不会发生即可&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">// 否则，则标记此实体状态为已删除(Deleted)，在稍后调用SaveChanges方法时，EF Core会生成并执行相应的删除语句&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">entry&lt;/span>.&lt;span style="color:#434f54">State&lt;/span> =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">initialState&lt;/span> == &lt;span style="color:#434f54">EntityState&lt;/span>.&lt;span style="color:#434f54">Added&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ? &lt;span style="color:#434f54">EntityState&lt;/span>.&lt;span style="color:#434f54">Detached&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : &lt;span style="color:#434f54">EntityState&lt;/span>.&lt;span style="color:#434f54">Deleted&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="软删除">软删除&lt;/h2>
&lt;p>通常，实现软删除是通过设置一个类似&lt;code>IsDeleted&lt;/code>的字段，在删除实体时，将字段值更新为&lt;code>true&lt;/code>，并在查询时，过滤掉所有&lt;code>IsDeleted=true&lt;/code>的记录&lt;/p>
&lt;p>这就需要对实体模型进行相关配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">public&lt;/span> &lt;span style="color:#728e00">static&lt;/span> &lt;span style="color:#434f54">EntityTypeBuilder&lt;/span>&amp;lt;&lt;span style="color:#434f54">TEntity&lt;/span>&amp;gt; &lt;span style="color:#434f54">EnableSoftDelete&lt;/span>&amp;lt;&lt;span style="color:#434f54">TEntity&lt;/span>&amp;gt;(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">this&lt;/span> &lt;span style="color:#434f54">EntityTypeBuilder&lt;/span>&amp;lt;&lt;span style="color:#434f54">TEntity&lt;/span>&amp;gt; &lt;span style="color:#434f54">builder&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">where&lt;/span> &lt;span style="color:#434f54">TEntity&lt;/span> : &lt;span style="color:#728e00">class&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// 添加一个注释，标志着此实体启用了软删除&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">builder&lt;/span>.&lt;span style="color:#434f54">HasAnnotation&lt;/span>(&lt;span style="color:#7f8c8d">&amp;#34;soft_delete&amp;#34;&lt;/span>, &lt;span style="color:#00979d">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// 添加相关字段&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">builder&lt;/span>.&lt;span style="color:#434f54">Property&lt;/span>&amp;lt;&lt;span style="color:#00979d">bool?&lt;/span>&amp;gt;(&lt;span style="color:#7f8c8d">&amp;#34;is_deleted&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#434f54">HasDefaultValue&lt;/span>(&lt;span style="color:#00979d">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">builder&lt;/span>.&lt;span style="color:#434f54">HasIndex&lt;/span>(&lt;span style="color:#7f8c8d">&amp;#34;is_deleted&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">builder&lt;/span>.&lt;span style="color:#434f54">Property&lt;/span>&amp;lt;&lt;span style="color:#434f54">DateTimeOffset&lt;/span>?&amp;gt;(&lt;span style="color:#7f8c8d">&amp;#34;deleted_at&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#434f54">HasDefaultValue&lt;/span>(&lt;span style="color:#00979d">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">builder&lt;/span>.&lt;span style="color:#434f54">Property&lt;/span>&amp;lt;&lt;span style="color:#00979d">string?&lt;/span>&amp;gt;(&lt;span style="color:#7f8c8d">&amp;#34;deleted_by&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#434f54">HasDefaultValue&lt;/span>(&lt;span style="color:#00979d">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// 配置查询过滤器，在查询时，使其忽略所有is_deleted字段值为true的记录&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">builder&lt;/span>.&lt;span style="color:#434f54">HasQueryFilter&lt;/span>(&lt;span style="color:#434f54">x&lt;/span> =&amp;gt; &lt;span style="color:#434f54">EF&lt;/span>.&lt;span style="color:#434f54">Property&lt;/span>&amp;lt;&lt;span style="color:#00979d">bool?&lt;/span>&amp;gt;(&lt;span style="color:#434f54">x&lt;/span>, &lt;span style="color:#7f8c8d">&amp;#34;is_deleted&amp;#34;&lt;/span>) != &lt;span style="color:#00979d">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">return&lt;/span> &lt;span style="color:#434f54">builder&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="使用interceptor拦截ef-core对实体的删除操作">使用Interceptor拦截EF Core对实体的删除操作&lt;/h2>
&lt;p>创建一个&lt;code>SoftDeleteInterceptor&lt;/code>，实现&lt;code>ISaveChangesInterceptor&lt;/code>接口：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">public&lt;/span> &lt;span style="color:#728e00">class&lt;/span> &lt;span style="color:#434f54">SoftDeleteInterceptor&lt;/span> : &lt;span style="color:#434f54">ISaveChangesInterceptor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">public&lt;/span> &lt;span style="color:#434f54">ValueTask&lt;/span>&amp;lt;&lt;span style="color:#00979d">int&lt;/span>&amp;gt; &lt;span style="color:#434f54">SavedChangesAsync&lt;/span>(&lt;span style="color:#434f54">SaveChangesCompletedEventData&lt;/span> &lt;span style="color:#434f54">eventData&lt;/span>, &lt;span style="color:#00979d">int&lt;/span> &lt;span style="color:#434f54">result&lt;/span>, &lt;span style="color:#434f54">CancellationToken&lt;/span> &lt;span style="color:#434f54">cancellationToken&lt;/span> = &lt;span style="color:#728e00">default&lt;/span>) { }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">public&lt;/span> &lt;span style="color:#434f54">ValueTask&lt;/span>&amp;lt;&lt;span style="color:#434f54">InterceptionResult&lt;/span>&amp;lt;&lt;span style="color:#00979d">int&lt;/span>&amp;gt;&amp;gt; &lt;span style="color:#434f54">SavingChangesAsync&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">DbContextEventData&lt;/span> &lt;span style="color:#434f54">eventData&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">InterceptionResult&lt;/span>&amp;lt;&lt;span style="color:#00979d">int&lt;/span>&amp;gt; &lt;span style="color:#434f54">result&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">CancellationToken&lt;/span> &lt;span style="color:#434f54">cancellationToken&lt;/span> = &lt;span style="color:#728e00">default&lt;/span>) { }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">#if&lt;/span> &lt;span style="color:#434f54">NET6_0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">public&lt;/span> &lt;span style="color:#434f54">InterceptionResult&lt;/span>&amp;lt;&lt;span style="color:#00979d">int&lt;/span>&amp;gt; &lt;span style="color:#434f54">SavingChanges&lt;/span>(&lt;span style="color:#434f54">DbContextEventData&lt;/span> &lt;span style="color:#434f54">eventData&lt;/span>, &lt;span style="color:#434f54">InterceptionResult&lt;/span>&amp;lt;&lt;span style="color:#00979d">int&lt;/span>&amp;gt; &lt;span style="color:#434f54">result&lt;/span>) =&amp;gt; &lt;span style="color:#434f54">result&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">public&lt;/span> &lt;span style="color:#00979d">int&lt;/span> &lt;span style="color:#434f54">SavedChanges&lt;/span>(&lt;span style="color:#434f54">SaveChangesCompletedEventData&lt;/span> &lt;span style="color:#434f54">eventData&lt;/span>, &lt;span style="color:#00979d">int&lt;/span> &lt;span style="color:#434f54">result&lt;/span>) =&amp;gt; &lt;span style="color:#434f54">result&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">public&lt;/span> &lt;span style="color:#728e00">void&lt;/span> &lt;span style="color:#434f54">SaveChangesFailed&lt;/span>(&lt;span style="color:#434f54">DbContextErrorEventData&lt;/span> &lt;span style="color:#434f54">eventData&lt;/span>) { }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">public&lt;/span> &lt;span style="color:#434f54">Task&lt;/span> &lt;span style="color:#434f54">SaveChangesFailedAsync&lt;/span>(&lt;span style="color:#434f54">DbContextErrorEventData&lt;/span> &lt;span style="color:#434f54">eventData&lt;/span>, &lt;span style="color:#434f54">CancellationToken&lt;/span> &lt;span style="color:#434f54">cancellationToken&lt;/span> = &lt;span style="color:#728e00">default&lt;/span>) =&amp;gt; &lt;span style="color:#434f54">Task&lt;/span>.&lt;span style="color:#434f54">CompletedTask&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">#endif&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>ISaveChangesInterceptor&lt;/code>用于拦截EF Core的&lt;code>SaveChanges&lt;/code>行为，其中&lt;code>SavingChanges&lt;/code>会在&lt;code>SaveChanges&lt;/code>操作之前触发，&lt;code>SavedChanges&lt;/code>会在&lt;code>SaveChanges&lt;/code>成功后触发，而&lt;code>SaveChangesFailed&lt;/code>会在&lt;code>SaveChanges&lt;/code>失败后触发&lt;/p>
&lt;p>这里我们只需要实现&lt;code>SavingChangesAsync&lt;/code>和&lt;code>SaveChangesFailedAsync&lt;/code>即可（以及它们对应的同步方法，这里忽略了）&lt;/p>
&lt;p>在&lt;code>SavingChangesAsync&lt;/code>中，我们需要将EF Core的删除操作拦截，改为更新操作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">public&lt;/span> &lt;span style="color:#434f54">ValueTask&lt;/span>&amp;lt;&lt;span style="color:#434f54">InterceptionResult&lt;/span>&amp;lt;&lt;span style="color:#00979d">int&lt;/span>&amp;gt;&amp;gt; &lt;span style="color:#434f54">SavingChangesAsync&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">DbContextEventData&lt;/span> &lt;span style="color:#434f54">eventData&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">InterceptionResult&lt;/span>&amp;lt;&lt;span style="color:#00979d">int&lt;/span>&amp;gt; &lt;span style="color:#434f54">result&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">CancellationToken&lt;/span> &lt;span style="color:#434f54">cancellationToken&lt;/span> = &lt;span style="color:#728e00">default&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">context&lt;/span> = &lt;span style="color:#434f54">eventData&lt;/span>.&lt;span style="color:#434f54">Context&lt;/span>!;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// 获取所有状态为`Deleted`并被标记为软删除的实体&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">deletedEntities&lt;/span> = &lt;span style="color:#434f54">context&lt;/span>.&lt;span style="color:#434f54">ChangeTracker&lt;/span>.&lt;span style="color:#434f54">Entries&lt;/span>().&lt;span style="color:#434f54">Where&lt;/span>(&lt;span style="color:#434f54">entry&lt;/span> =&amp;gt; &lt;span style="color:#434f54">entry&lt;/span>.&lt;span style="color:#434f54">State&lt;/span> == &lt;span style="color:#434f54">EntityState&lt;/span>.&lt;span style="color:#434f54">Deleted&lt;/span> &amp;amp;&amp;amp; &lt;span style="color:#434f54">entry&lt;/span>.&lt;span style="color:#434f54">Metadata&lt;/span>.&lt;span style="color:#434f54">FindAnnotation&lt;/span>(&lt;span style="color:#434f54">Annotations&lt;/span>.&lt;span style="color:#434f54">SoftDelete&lt;/span>) &lt;span style="color:#728e00">is&lt;/span> &lt;span style="color:#434f54">not&lt;/span> &lt;span style="color:#00979d">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">foreach&lt;/span> (&lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">entry&lt;/span> &lt;span style="color:#728e00">in&lt;/span> &lt;span style="color:#434f54">deletedEntities&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// 将实体状态改为Modified，稍后EF Core则会因此对此实体生成并执行更新语句&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">entry&lt;/span>.&lt;span style="color:#434f54">State&lt;/span> = &lt;span style="color:#434f54">EntityState&lt;/span>.&lt;span style="color:#434f54">Modified&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">entry&lt;/span>.&lt;span style="color:#434f54">CurrentValues&lt;/span>[&lt;span style="color:#434f54">PropertyNames&lt;/span>.&lt;span style="color:#434f54">IsDeleted&lt;/span>] = &lt;span style="color:#00979d">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">entry&lt;/span>.&lt;span style="color:#434f54">CurrentValues&lt;/span>[&lt;span style="color:#434f54">PropertyNames&lt;/span>.&lt;span style="color:#434f54">DeletedAt&lt;/span>] = &lt;span style="color:#434f54">DateTimeOffset&lt;/span>.&lt;span style="color:#434f54">UtcNow&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">entry&lt;/span>.&lt;span style="color:#434f54">CurrentValues&lt;/span>[&lt;span style="color:#434f54">PropertyNames&lt;/span>.&lt;span style="color:#434f54">DeletedBy&lt;/span>] = &lt;span style="color:#434f54">GetOperator&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// 添加一个运行时注释，记录此实体已被软删除&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">entry&lt;/span>.&lt;span style="color:#434f54">Metadata&lt;/span>.&lt;span style="color:#434f54">AddRuntimeAnnotation&lt;/span>(&lt;span style="color:#434f54">Annotations&lt;/span>.&lt;span style="color:#434f54">HasSoftDeleted&lt;/span>, &lt;span style="color:#00979d">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">return&lt;/span> &lt;span style="color:#434f54">ValueTask&lt;/span>.&lt;span style="color:#434f54">FromResult&lt;/span>(&lt;span style="color:#434f54">result&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在&lt;code>SavedChangesAsync&lt;/code>中，找到被软删除后的实体，将其状态同步为&lt;code>Detached&lt;/code>，来保证其一致：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">softDeletedEntries&lt;/span> = &lt;span style="color:#434f54">eventData&lt;/span>.&lt;span style="color:#434f54">Context&lt;/span>!.&lt;span style="color:#434f54">ChangeTracker&lt;/span>.&lt;span style="color:#434f54">Entries&lt;/span>().&lt;span style="color:#434f54">Where&lt;/span>(&lt;span style="color:#434f54">entry&lt;/span> =&amp;gt; &lt;span style="color:#434f54">entry&lt;/span>.&lt;span style="color:#434f54">Metadata&lt;/span>.&lt;span style="color:#434f54">FindRuntimeAnnotation&lt;/span>(&lt;span style="color:#434f54">Annotations&lt;/span>.&lt;span style="color:#434f54">HasSoftDeleted&lt;/span>) != &lt;span style="color:#00979d">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">foreach&lt;/span> (&lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">entries&lt;/span> &lt;span style="color:#728e00">in&lt;/span> &lt;span style="color:#434f54">softDeletedEntries&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">entries&lt;/span>.&lt;span style="color:#434f54">State&lt;/span> = &lt;span style="color:#434f54">EntityState&lt;/span>.&lt;span style="color:#434f54">Detached&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">return&lt;/span> &lt;span style="color:#434f54">ValueTask&lt;/span>.&lt;span style="color:#434f54">FromResult&lt;/span>(&lt;span style="color:#434f54">result&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="启用软删除拦截器">启用软删除拦截器&lt;/h3>
&lt;p>通常通过覆写&lt;code>DbContext.OnConfiguring&lt;/code>方法来启用拦截器：&lt;/p>
&lt;pre tabindex="0">&lt;code>public class MyContext : DbContext
{
private readonly SoftDeleteInterceptor _softDeleteInterceptor = new SoftDeleteInterceptor();
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
=&amp;gt; optionsBuilder
.AddInterceptors(_softDeleteInterceptor)
}
&lt;/code>&lt;/pre>&lt;p>拦截器启用后，即可将EF Core的删除操作拦截修改为更新操作，实现软删除
可以通过不适用过滤器的查询来进行验证：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">deleted&lt;/span> = &lt;span style="color:#728e00">await&lt;/span> &lt;span style="color:#434f54">dbContext&lt;/span>.&lt;span style="color:#434f54">Set&lt;/span>&amp;lt;&lt;span style="color:#434f54">MyEntity&lt;/span>&amp;gt;().&lt;span style="color:#434f54">IgnoreQueryFilters&lt;/span>().&lt;span style="color:#434f54">FirstOrDefaultAsync&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">deleted&lt;/span>.&lt;span style="color:#434f54">Should&lt;/span>().&lt;span style="color:#434f54">NotBeNull&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="缺陷">缺陷&lt;/h2>
&lt;p>这种方案还有着一些缺陷，比如：&lt;/p>
&lt;ol>
&lt;li>无法对引用实体进行级联的软删除&lt;/li>
&lt;li>无法“硬”删除，这个问题可以通过使用添加一个&lt;code>RuntimeAnnotation&lt;/code>来解决&lt;/li>
&lt;/ol>
&lt;h2 id="拦截器的更多用法">拦截器的更多用法&lt;/h2>
&lt;p>拦截器还有一些其它玩法，比如&lt;a href="https://learn.microsoft.com/en-us/ef/core/logging-events-diagnostics/interceptors#savechanges-interception">官方文档&lt;/a>中介绍了一个自动生成审计记录的案例&lt;/p>
&lt;p>另外也许还能利用拦截器实现一个简易的&amp;rsquo;Change Data Capture&amp;rsquo;机制，但是感觉不是很靠谱，不在数据库上做CDC的话，数据可靠性不够&lt;/p></description></item><item><title>浅谈架构设计之分层</title><link>http://suraciii.github.io/posts/arch-layering/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/arch-layering/</guid><description>&lt;p>&lt;em>本文是某次分享的摘要&lt;/em>&lt;/p>
&lt;h3 id="架构分层">架构分层&lt;/h3>
&lt;ul>
&lt;li>将复杂的系统分割成位于不同层次的模块&lt;/li>
&lt;li>将实现细节隐藏在各个层面的模块中&lt;/li>
&lt;li>降低认知负担，改动成本和风险&lt;/li>
&lt;/ul>
&lt;h3 id="分层的原则">分层的原则&lt;/h3>
&lt;p>总结的三个主要原则：&lt;/p>
&lt;ul>
&lt;li>不同的分层，建立不同的抽象&lt;/li>
&lt;li>关注点分离&lt;/li>
&lt;li>层内高内聚、层间低耦合&lt;/li>
&lt;/ul>
&lt;p>其它一些分层原则：&lt;/p>
&lt;ul>
&lt;li>层与层之间不应有循环依赖&lt;/li>
&lt;li>业务层不应该包括非业务代码，反之亦然&lt;/li>
&lt;li>各层应能够独立测试&lt;/li>
&lt;li>低层不应依赖高层&lt;/li>
&lt;li>分层是逻辑上的抽象，不一定意味着物理上的分离&lt;/li>
&lt;/ul>
&lt;p>&lt;em>这些分层原则主要来自于 1. 《A Philosophy of Software Design》 John Ousterhout, 2. 《LayeringPrinciples》 Martin Fowler&lt;/em>&lt;/p>
&lt;h3 id="三层架构">三层架构&lt;/h3>
&lt;p>&lt;img src="http://suraciii.github.io/arch-layering/3tiers.png" alt="">&lt;/p>
&lt;p>人（前端/客户端）&amp;lt;-&amp;gt; 应用 &amp;lt;-&amp;gt; 数据库&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/arch-layering/3layers.png" alt="">&lt;/p>
&lt;ul>
&lt;li>展示层：人和应用的交互&lt;/li>
&lt;li>数据层：应用对数据的存取&lt;/li>
&lt;li>依赖方向从上至下&lt;/li>
&lt;/ul>
&lt;h3 id="六边形架构">六边形架构&lt;/h3>
&lt;p>&lt;img src="http://suraciii.github.io/arch-layering/hex.png" alt="">&lt;/p>
&lt;ul>
&lt;li>核心层：应用逻辑&lt;/li>
&lt;li>外层：UI、HTTP API、日志、配置、数据库、缓存、邮件通知等 - &lt;em>虽然这些模块有着不同的关注点，但是在层次上是在同一层&lt;/em>&lt;/li>
&lt;li>依赖方向：从左到右&lt;/li>
&lt;/ul>
&lt;h3 id="存在的问题">存在的问题&lt;/h3>
&lt;p>&lt;img src="http://suraciii.github.io/arch-layering/3layers-problem.png" alt="">&lt;/p>
&lt;p>对于业务系统：&lt;/p>
&lt;ul>
&lt;li>业务的数据结构和关系存在于数据库中，&lt;strong>业务逻辑和应用逻辑&lt;/strong>混淆在一起&lt;/li>
&lt;li>业务模型的&lt;strong>数据和行为分离&lt;/strong>，导致认知负担及改动风险&lt;/li>
&lt;li>基于数据库设计数据结构产生不准确的模型&lt;/li>
&lt;/ul>
&lt;h3 id="领域驱动设计四层架构">领域驱动设计：四层架构&lt;/h3>
&lt;p>&lt;img src="http://suraciii.github.io/arch-layering/4layers-1.png" alt="">&lt;/p>
&lt;ul>
&lt;li>领域层：新的抽象&lt;/li>
&lt;li>区分于应用层，领域层内由体现业务领域中的知识的同时具备数据和行为的领域模型构成，不包含和应用相关的代码&lt;/li>
&lt;/ul>
&lt;p>依赖反转——&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/arch-layering/4layers-2.png" alt="">&lt;/p>
&lt;ul>
&lt;li>应用层是控制面&lt;/li>
&lt;li>领域层中是纯粹的领域模型&lt;/li>
&lt;li>领域层不依赖基础设施，不关心应用逻辑&lt;/li>
&lt;/ul>
&lt;h3 id="洋葱架构">洋葱架构&lt;/h3>
&lt;p>&lt;img src="http://suraciii.github.io/arch-layering/onion.png" alt="">&lt;/p>
&lt;ul>
&lt;li>依赖流由外向内&lt;/li>
&lt;li>以领域层中的领域模型为核心&lt;/li>
&lt;li>核心领域模型专注于对业务领域进行抽象&lt;/li>
&lt;li>首先建立领域模型，围绕领域模型建立数据库表结构，填充应用功能&lt;/li>
&lt;/ul>
&lt;h4 id="具备领域层的六边形架构">具备领域层的六边形架构&lt;/h4>
&lt;p>&lt;img src="http://suraciii.github.io/arch-layering/hex-2.png" alt="">&lt;/p>
&lt;h4 id="整洁架构">整洁架构&lt;/h4>
&lt;p>&lt;img src="http://suraciii.github.io/arch-layering/clean.png" alt="">&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;ul>
&lt;li>总体分为核心层和非核心层&lt;/li>
&lt;li>应用层比较薄，不涉及业务逻辑和知识，只负责协调任务并将工作传递到下一层来处理&lt;/li>
&lt;li>&lt;strong>如无必要、勿增抽象&lt;/strong> &lt;em>层次越多，抽象越多，理解越困难&lt;/em>&lt;/li>
&lt;/ul>
&lt;h3 id="纵向切分">纵向切分&lt;/h3>
&lt;ul>
&lt;li>主要关注于对模块边界的识别&lt;/li>
&lt;li>在多个层面中分别进行&lt;/li>
&lt;/ul></description></item><item><title>.NET 7 预览</title><link>http://suraciii.github.io/posts/net7-preview/</link><pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/net7-preview/</guid><description>&lt;p>2月17日，.NET团队&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-net-7-preview-1/">发布了.NET 7的第一个预览版本&lt;/a>，此时正值.NET发布20周年，距离&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-net-6/">.NET 6的正式发布&lt;/a>才过了不到4个月，在这个预览版本里，没有特别重要的新特性，但是可以一窥.NET 7的一些规划和展望&lt;/p>
&lt;h3 id="现代客户端开发net-maui">现代客户端开发：.NET MAUI&lt;/h3>
&lt;p>&lt;a href="https://github.com/dotnet/maui">MAUI&lt;/a>是&lt;code>Xamarin.Forms&lt;/code>的新（改名）版本，被看作是.NET跨平台原生UI开发的未来，其在BUILD 2020大会上宣布以来，至今已经发布了13个预览版本，将在今年第二季度发布支持.NET 6的正式版本，并在之后跟随.NET 7的发布正式成为.NET的一部分。&lt;/p>
&lt;h3 id="现代云原生应用">现代云原生应用&lt;/h3>
&lt;p>.NET 7将寻找对开发体验上的改进从而帮助开发者更轻松地开发云原生应用，例如：&lt;/p>
&lt;ul>
&lt;li>简化实现身份认证和授权所需的设置和配置&lt;/li>
&lt;li>改进应用的启动速度和运行时性能&lt;/li>
&lt;/ul>
&lt;p>.NET 7将在开发容器应用的体验上做出改进，包括：&lt;/p>
&lt;ol>
&lt;li>改进.NET镜像使其更小、更快、更安全&lt;/li>
&lt;li>增强遥测以改进容器的可观测性&lt;/li>
&lt;li>尝试通过dotnet SDK直接构建容器（我觉得这个还是蛮有用的，目前几乎所有语言/平台的工具链里都不包括容器镜像的构建，这在开发时挺不方便——比如需要安装docker环境等，需要维护繁杂的构建脚本、makefile等，即使有更轻量的podman等工具，也不如直接集成到语言/平台本身的工具链上来得方便）&lt;/li>
&lt;/ol>
&lt;h3 id="帮助升级net应用">帮助升级.NET应用&lt;/h3>
&lt;p>一方面是提供从.NET 6到.NET 7的&lt;a href="https://dotnet.microsoft.com/platform/upgrade-assistant">升级助手&lt;/a>，通过代码分析器、自动代码修复等功能，帮助开发者更轻松自信地升级到.NET 7，来获得更好的性能和更多的新特性。&lt;br>
另一方面是对于传统.NET应用提供更完善的升级指引、文档和工具。&lt;/p>
&lt;p>（这个好像意义不大，很多应用之所以不升级不是因为升级容易或者困难，而是只有在不得不升级的时候才会去考虑升级）&lt;/p>
&lt;h3 id="aspnet-core">ASP.NET Core&lt;/h3>
&lt;p>在.NET 7, ASP.NET Core投入在如下几个地方：&lt;/p>
&lt;ul>
&lt;li>性能上，&lt;a href="https://www.techempower.com/benchmarks/#section=test&amp;amp;runid=b3d7b2dd-c903-47a0-9e01-7ab3168f03a1&amp;amp;hw=ph&amp;amp;test=plaintext&amp;amp;p=zik0zi-zik0zj-ziimf3-zijxtr-b8jj&amp;amp;a=2">目前ASP.NET Core的性能大约是Java Servlet的3倍，Node.js的10倍&lt;/a>，在.NET 7，ASP.NET Core会继续投入在对性能的提升上&lt;/li>
&lt;li>HTTP/3在.NET 6中是预览功能，在.NET 7将会正式支持并默认启用，并且会带来一些高级TLS特性和更多的性能提升&lt;/li>
&lt;li>为Minimal APIs提供endpoint过滤器和路由分组的原生支持，并简化其在认证鉴权上的通用配置&lt;/li>
&lt;li>支持gRPC JSON转码，使开发者可以通过类似RESTful API的方式以JSON编码调用gRPC服务&lt;/li>
&lt;li>为SignalR支持强类型客户端和在客户端调用时支持返回结果&lt;/li>
&lt;li>提高Razor编译器的性能、可靠性和工具易用性&lt;/li>
&lt;li>Blazor上会进行AOT、多线程（这个应该是目前比较需要的）、热重载等改进&lt;/li>
&lt;li>改进MVC中的路由、链接生成、参数绑定等&lt;/li>
&lt;/ul>
&lt;h3 id="orleans">Orleans&lt;/h3>
&lt;p>&lt;a href="https://github.com/dotnet/orleans">Orleans&lt;/a>是.NET中的分布式开发框架，基于&lt;a href="https://www.microsoft.com/en-us/research/publication/orleans-distributed-virtual-actors-for-programmability-and-scalability">Virtual Actor Model&lt;/a>实现，并提供一系列的适用于云原生应用的组件（如状态管理、唤醒器、发布订阅、事件溯源、分布式事务等），Orleans最初启动于微软研究院并在之后很快交给了XBox部门，多年里一直为&lt;a href="https://www.youtube.com/watch?v=KhgYlvGLv9c">微软内部许多项目所使用&lt;/a>。&lt;br>
在近期，Orleans加入到了.NET团队中，将与.NET的发展方向和发布周期对齐。&lt;/p>
&lt;p>Orleans最近刚刚发布了&lt;a href="https://github.com/dotnet/orleans/releases">4.0版本的第一个预览版本&lt;/a>，实现了更易用的Grain ID和Stream ID，以及新的版本兼容的高性能序列化。&lt;/p>
&lt;p>Orleans将随着.NET 7发布4.0正式版，在这期间会专注于对易用性、可维护性和性能的提升，以及与ASP.NET Core更好地集成。&lt;/p>
&lt;p>按照惯例，.NET 7应该是在今年11月正式发布，在这期间应该还会逐渐公布更多新的特性和改进。&lt;/p></description></item><item><title>《反对结对编程》？别吧</title><link>http://suraciii.github.io/posts/against-pair-programming-please-dont/</link><pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/against-pair-programming-please-dont/</guid><description>&lt;p>最近在网上冲浪时看到了一些关于结对编程的讨论（争论），起因是一篇题为&lt;a href="https://matt-rickard.com/against-pair-programming/">《反对结对编程(Against Pair Programming)》&lt;/a>的博客文章，在文中，作者认为结对编程不仅仅是低效率的，甚至还是有害的，主要原因有：&lt;/p>
&lt;ol>
&lt;li>结对编程时，程序员们更倾向于提供那些更应该在设计审查或者代码审查中提出的反馈，整体设计应该是在写代码之前就已经确定下来的，所以留给结对程序员们的就只有对细枝末节和代码风格的计较了，这些都会拖慢速度。&lt;/li>
&lt;li>专家程序员和新手程序员结对时，专家会变得同新手一样“慢”。&lt;/li>
&lt;li>从知识传播的角度来说，相对于可以1对n地进行知识传播的代码审查、设计审查和通用文档，结对编程只能1对1地进行知识传播，且代码审查等协作可以异步地进行。&lt;/li>
&lt;/ol>
&lt;p>&lt;em>关于引用文章在推特上引起的讨论: &lt;a href="https://twitter.com/mattrickard/status/1492548554426048514">Matt Rickard&amp;rsquo;s twitter&lt;/a>&lt;/em>&lt;/p>
&lt;p>我之前也对结对编程进行过一些简单的研究，客观地说，结对编程确实有着一些缺陷，包括上文所提到的知识传播的效率问题，另外还有其没有提到的结对编程在灵活性上的问题——实践中不可能永远把两个人捆绑成一个人用，也不总是能够找到较为合适的两个程序员进行结对，并且，结对编程也是需要进行一些学习和训练才能取得比较好的效果。&lt;/p>
&lt;p>但是，结对编程绝不是引用文章所说的那样一无是处甚至有害，相反，其在很多方面具备着不可替代的价值。&lt;/p>
&lt;p>首先，结对编程是一种&lt;strong>非常强力且深入&lt;/strong>的协作方式，在结对编程时，两个开发者会实时地、持续地进行交流，这个过程中，很容易产生高价值的反馈（比如捕捉到一些隐藏比较深的bug，或是一些可能有性能隐患的缺陷等），因为双方都处于比较专注的状态，对问题的理解也在一个频道上。&lt;br>
一个最直观的场景是在故障排查时，两个人或者更多人共同地去解决一个问题，效果一定是大大好于自己一个人闷头去琢磨的。&lt;/p>
&lt;p>而结对编程中对于“细枝末节或代码风格”的斤斤计较，也未必是有害的，因为这些细枝末节并不会拖累结对程序员的速度，一个更准确的更易于理解的变量名，一行简短的注释，又或者一个简单的封装，这些反馈被提出的时机正是在开发的实时进行当中，解决它们通常也就是顺手几秒钟的事情，这不会“拖累”任何人，而如果能频繁地持续地去除代码中的晦涩之处，让代码变得更容易理解，更优雅，又有什么不好呢？&lt;/p>
&lt;p>的确，1对1的结对编程，相对于代码审查、设计审查和文档，其传播知识的效率也许是比较低的，但是效果却是非常好的，审查别人写的代码，又或者查阅一些省略了大量细节甚至有可能还过时了的文档，哪里会比得上亲身深入而专注地参与到代码地编写中去呢？&lt;/p>
&lt;p>资深开发者的速度在和新手开发者结对编程时会有所降低，但是为什么要对新人开发者在这个过程中获得的成长视而不见呢？新人可以在结对编程中有效地学习团队中的流程和工具，学习相关的业务知识，学习资深开发者的高超技艺和思路，况且即使资深开发者也是经常能从结对中学习到东西的，难道团队成员的能力提升是没有价值的吗？&lt;/p>
&lt;p>最后，最让我无法理解的是作者在文中的这么一段话：&lt;/p>
&lt;blockquote>
&lt;p>Let&amp;rsquo;s start with the economics. Since we are employing two programmers to do work on the same keyboard at the same time, the output of pair programming must be greater than 2x the output of a single programmer to make sense.&lt;br>
（从经济上讲，既然我们雇佣了两个程序员同时在同一个键盘上工作，那这对程序员的产出一定要高于单个程序员的2倍才合理）&lt;/p>
&lt;/blockquote>
&lt;p>我无语，这是什么种植园思维啊，即使不提这种话背后的血腥味，现实上，这个结论也是不成立的：合适的结对编程实践是能够产生相对于独立编程2倍以上的产出的（除非把“产出”等同于代码行数而不考虑其质量也不考虑对团队能力的提升等），而且，即使，如果结对进行故障排查只能缩短30%解决故障的时间，如果结对编程只能让新加入团队的成员提前30%的时间到达最高生产力，这难道不值得去做吗？&lt;/p>
&lt;p>我经历过大约两年实践的结对编程实践，在那期间，从结对的同伴那里我学到了很多很多非常有价值的宝贵的知识和经验，这些都令我受益匪浅。感谢他/她们没有像引用文章的作者一样，把我当成拖慢自己速度的累赘。&lt;br>
对于团队来说，我的看法是结对编程这种实践有着其缺陷，也需要一些学习和训练才能做得够好，但是如上文所说，其所提供的价值也是十分显著的，也许可以根据团队的具体情况具体实践，比如在故障排查和新成员加入团队时完全实践，而在平常开发时，只安排一定比例的开发者结对工作在那些较为重要的功能开发中。
无论如何，我认为，如果要拒绝结对编程，一定要在清楚地认识到它的价值后，再有一个不得不拒绝它的理由。&lt;/p></description></item><item><title>来自Grafana Labs的云原生日志解决方案之 Loki</title><link>http://suraciii.github.io/posts/grafana-o11y-stack-loki/</link><pubDate>Tue, 15 Feb 2022 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/grafana-o11y-stack-loki/</guid><description>&lt;p>Loki是一个开源的日志聚合系统，其提供对日志信息的收集、存储、以及查询等功能，和其它日志存储（如ElasticSearch）不同的是，Loki主要将日志数据以标签(labels)分流，按时间分块保存在对象存储而非本地硬盘中，并且，Loki只会对日志信息的元数据(即由标签所组合的日志流及其时间区间)进行索引，而非对全文进行索引。&lt;/p>
&lt;p>这是一种非常聪明的设计，因为日志数据有两个非常重要的特点：&lt;/p>
&lt;ol>
&lt;li>日志数据本质上和指标数据类似，是一种时序数据——数据按时间顺序排列，我们查询时，总是在对某个特定时间区间内的信息进行检索&lt;/li>
&lt;li>日志数据是不可变的，只会追加新的数据而不会对旧数据进行修改
这两个特点使得Loki可以相对于主要面向全文检索场景的ElasticSearch，对日志场景做出更深入更激进的优化，比如能够建立更少的索引，以及建立更有效的缓存等。&lt;/li>
&lt;/ol>
&lt;h3 id="loki是如何工作的">Loki是如何工作的&lt;/h3>
&lt;p>Loki的架构和之前所介绍的Cortex项目非常相似，都是由&lt;strong>distributor&lt;/strong>、&lt;strong>ingester&lt;/strong>、&lt;strong>querier&lt;/strong>等组件构成，其行为也基本一样，实际上后面准备介绍的分布式追踪项目Tempo也是使用的这种设计，毕竟这些项目所解决的问题高度相似，都是对时序的遥测数据进行收集、处理、存储和查询。&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/grafana-o11y-stack-loki/arch.svg" alt="">&lt;/p>
&lt;p>日志数据首先被发送给&lt;strong>distributor&lt;/strong>, &lt;strong>distributor&lt;/strong>对数据进行检查和校验后，将数据分批并行地发送到多个&lt;strong>ingester&lt;/strong>，&lt;strong>ingester&lt;/strong>会将日志数据上传到所配置的对象存储中，并且在保存缓存在本地。&lt;br>
查询时，需要使用Loki专用的查询语言——LogQL——进行查询，&lt;strong>querier&lt;/strong>组件负责LogQL查询语句的执行，同时从&lt;strong>ingester&lt;/strong>以及后端对象存储中拉取数据进行查询。&lt;br>
另外，一个可选的&lt;strong>query frontend&lt;/strong>组件可以用来建立一个额外的查询层面，其可以将查询命令按时间分片放入查询队列按调度交由多个&lt;strong>queriers&lt;/strong>并行执行，这样一方面提高了查询的效率，另一方面也避免由于某些比较高成本的查询命令导致内存不足等。&lt;br>
此外，&lt;strong>ruler&lt;/strong>组件可以像Prometheus一样，配置规则从日志流中生成指标数据和报警信息，报警信息可以直接发到alertmanager进行管理和通知。&lt;/p>
&lt;p>对于日志数据，Loki将其按日志上的标签信息进行分流，然后按其时间进行分块保存成文件在对象存储中，比如这么一条日志：&lt;/p>
&lt;pre tabindex="0">&lt;code>labels: {cluster=&amp;#34;prod&amp;#34;,app=&amp;#34;meetingsvc&amp;#34;, pod=&amp;#34;...&amp;#34;, namespace=&amp;#34;...&amp;#34;, ...}
message: &amp;#34;Order 123 processed&amp;#34;
timestamp: 1644926567933944082
&lt;/code>&lt;/pre>&lt;p>Loki会将其完整的标签信息&lt;code>{cluster=&amp;quot;prod&amp;quot;,app=&amp;quot;meetingsvc&amp;quot;, pod=&amp;quot;...&amp;quot;, namespace=&amp;quot;...&amp;quot;, ...}&lt;/code>进行哈希，得到其所属的日志流id为&lt;code>fc98wz37&lt;/code>，这条日志会连同这个日志流其它同时间区间内的日志被打包成一个文件上传到对象存储，并对其标签建立索引。&lt;/p>
&lt;p>查询时，需要使用这样的LogQL语句：&lt;/p>
&lt;pre tabindex="0">&lt;code>{app=&amp;#34;meetingsvc&amp;#34;, cluster=&amp;#34;prod&amp;#34; } |= &amp;#34;Order 123&amp;#34;
&lt;/code>&lt;/pre>&lt;p>语句前半部分&lt;code>{app=&amp;quot;meetingsvc&amp;quot;, cluster=&amp;quot;prod&amp;quot;}&lt;/code>为标签过滤条件，后半部分&lt;code>|= &amp;quot;Order 123&amp;quot;&lt;/code>是对文本进行检索，查询时，Loki首先根据查询语句中的标签条件通过索引找到对应的日志流id，并将此日志流在指定时间内的所有文件都拉取到本地，然后遍历所有文件的内容，根据条件进行检索。&lt;/p>
&lt;p>可以看到，在这种工作方式下，日志的标签需要谨慎地设计，因为标签值的每一种组合都会产生额外的一个独立日志流，因此要避免以诸如&lt;code>OrderId&lt;/code>等数据作为标签之一。&lt;/p>
&lt;p>这种“把大块数据拉到本地然后进行遍历查找”的做法，乍一看可能很危险，但是回顾最开始我们说的日志数据的两个特点，就会发现，在正常的使用场景中，日志的查询只会触及特定流的特定时间区间，所以只会下载和遍历有限大小的文件块，而且当一个时间区间的所有日志都被打包上传后，这个文件块就不会再被更新了，因此所有对此文件块所建立的缓存都不会失效（Loki目前对于日志查询的缓存还在积极开发中，只有部分实现）。&lt;/p>
&lt;h3 id="loki的主要优势">Loki的主要优势&lt;/h3>
&lt;ol>
&lt;li>得益于Loki专门面向日志数据的设计，它大大降低了对数据的索引，其存储成本和使用成本都能够显著降低&lt;/li>
&lt;li>Loki将日志数据存储在对象存储中，可以利用上云服务中对象存储的可扩展性和可靠性&lt;/li>
&lt;li>部署维护都相对较为简单&lt;/li>
&lt;li>可以横向扩展，包括对其各个组件单独进行伸缩&lt;/li>
&lt;li>​相对于一些商用日志产品，Loki是面向云原生的，利用公共云或者私有云或者混合云上的基本的块存储和对象存储服务，就可以轻松地完整建设出一整套供应商中立的日志系统&lt;/li>
&lt;li>内建多租户支持&lt;/li>
&lt;li>由于是Grafana自家项目，Grafana里有着原生的Loki组件和面板&lt;/li>
&lt;/ol>
&lt;h3 id="plg技术栈">PLG技术栈&lt;/h3>
&lt;p>与由ElasticSearch、Fluentd、Kibana组成的EFK技术栈类似，Loki也有由Promtail、Loki、Grafana组成的PLG技术栈，其中Promtail是一个类似Fluentd的对日志进行采集、处理和转发的代理，与Fluentd不同的是，Promtail是为Kubernetes和Loki专门设计的，其只能对Kubernetes中的容器日志文件进行采集，并且自动关联相关Pod的labels作为日志消息的标签。&lt;br>
不过Promtail并不是Loki的唯一选择，Loki也支持Fluentd、Logstash等其它转发器。&lt;/p>
&lt;p>在Grafana dashboard中，内置有原生的Loki组件，添加Loki作为数据源后，即可在Explore页面进行自定义查询：
&lt;img src="http://suraciii.github.io/grafana-o11y-stack-loki/explore.svg" alt="">&lt;/p>
&lt;p>也可以创建特定的面板来根据配置的LogQL展示日志信息：
&lt;img src="http://suraciii.github.io/grafana-o11y-stack-loki/panel.svg" alt="">&lt;/p>
&lt;h3 id="最后">最后&lt;/h3>
&lt;p>总体来说，Loki的设计和行为都和Cortex高度一致，其对待日志数据的方式也和Prometheus相似，正如其介绍中的那样：“Like prometheus, but for logs”，原因上面也说过了，日志数据和其它遥测数据一样，都是时序性的，正是基于这样的设计和架构，在不丢失功能和性能的前提下，得以将日志数据保存在更低成本更高可扩展性更易于管理的对象存储中。&lt;/p>
&lt;p>就我目前使用Loki的体验来说，其整体上已经基本成熟完备了，只是在某些较为边缘的功能上还有所缺乏，偶尔也会出一些小问题，不过得益于其积极的开发者们和活跃的开源社区都得到了较好的解决，加上其相对较低的维护难度和使用条件以及成本，和其可扩展性，无论场景规模大小，都可以说是一个非常优秀的云原生日志解决方案。&lt;/p></description></item><item><title>来自Grafana Labs的云原生可观测性全家桶之 Cortex</title><link>http://suraciii.github.io/posts/grafana-observability-stack-cortex/</link><pubDate>Fri, 11 Feb 2022 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/grafana-observability-stack-cortex/</guid><description>&lt;p>日志(logs)、指标(metrics)和分布式追踪(traces)被称作可观测性的三大支柱。我们通过一系列的工具和手段，对这些遥测信息进行收集、处理和分析，从而能够帮助我们更及时有效地响应故障和更有信心地发布新的功能。&lt;/p>
&lt;p>Grafana Labs以其当家产品Grafana面板为人熟知，这里分别介绍一些Grafana Labs提供的可观测领域中的其它开源产品，并和一些其它同类产品进行简单的对比。&lt;/p>
&lt;h2 id="cortex">Cortex&lt;/h2>
&lt;p>目前，Prometheus是当前常见且主流的指标监控解决方案，它能够收集指标信息并将其以时序数据保存，并支持服务发现、报警以及灵活的查询能力等，但是单纯使用Prometheus作为指标监控的解决方案，在当前有着一系列的局限：&lt;/p>
&lt;ul>
&lt;li>无法水平扩展&lt;/li>
&lt;li>非高可用&lt;/li>
&lt;li>不能很好地支持多租户&lt;/li>
&lt;li>不支持对多集群的指标采集&lt;/li>
&lt;li>数据只能保存在本地硬盘中，随着数据规模的增长变得难以维护
这些问题都限制了Prometheus无法作为中心化、中台化的监控解决方案，而这又恰恰是我们所需要的&lt;/li>
&lt;/ul>
&lt;p>Cortex项目就是为了解决这些问题，为Prometheus增强其上面列出的所缺少的这些能力。
Cortex摄取来自各个Prometheus实例的数据，将其转储到对象存储（如s3、Azure Storage等）中——对象存储具备更高的扩展性，数据更易于维护、成本也要更低。
此外、Cortex也提供了指标数据的并行化查询和缓存，从而提高了查询性能。&lt;/p>
&lt;p>下图为Cortex的整体架构：
&lt;img src="http://suraciii.github.io/grafana-observability-stack/1.png" alt="">&lt;/p>
&lt;p>Cortex的工作方式：&lt;/p>
&lt;ol>
&lt;li>各个&lt;strong>prometheus&lt;/strong>实例通过&lt;code>Remote Write&lt;/code>接口将采集到的指标数据发送到&lt;strong>distributor&lt;/strong>&lt;/li>
&lt;li>&lt;strong>distributor&lt;/strong>在对指标数据进行一系列的检查校验后，将其分批、并行地发送到多个&lt;strong>ingester&lt;/strong>中&lt;/li>
&lt;li>&lt;strong>ingester&lt;/strong>负责将收到的指标数据缓存并定时提交到对象存储中&lt;/li>
&lt;li>&lt;strong>querier&lt;/strong>负责指标数据的查询，它会分别从对象存储以及&lt;strong>ingester中同时进行查询&lt;/strong>（因为最新的数据还在ingester中未被提交）&lt;/li>
&lt;li>&lt;strong>query frontend&lt;/strong>是一个可选的额外查询层面，它可以将查询命令按时间分片放入查询队列，并分别交由多个&lt;strong>queriers&lt;/strong>并行地进行查询，然后再进行整合，并将查询结果进行缓存，从而提高查询效率。&lt;/li>
&lt;li>&lt;strong>query scheduler&lt;/strong>是一个可选的位于&lt;strong>query frontende&lt;/strong>和&lt;strong>querier&lt;/strong>之间的查询层，其主要是为了能够独立地对查询队列进行伸缩&lt;/li>
&lt;li>&lt;strong>ruler&lt;/strong>可以通过执行配置的查询来记录规则和警报，并将产生的警报发送给&lt;strong>alert manager&lt;/strong>，将计算后的指标发送给&lt;strong>ingester&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>其中，大多数组件都是无状态的，另外有部分（比如&lt;strong>ingester&lt;/strong>）是依赖一致性哈希的有状态组件，这些组件都可以独立地进行水平伸缩。&lt;/p>
&lt;h4 id="与thanos对比">与Thanos对比&lt;/h4>
&lt;p>Thanos是另一个流行的给Prometheus加buff的方案，其作用和功能与Cortex类似，但是工作方式有所不同。&lt;/p>
&lt;p>Thanos的设计非常简洁且优雅：
&lt;img src="http://suraciii.github.io/grafana-observability-stack/2.png" alt="">&lt;/p>
&lt;ol>
&lt;li>Thanos为每个prometheus实例添加一个&lt;strong>sidecar&lt;/strong>，sidecar定时地将prometheus中的指标数据上传到对象存储中&lt;/li>
&lt;li>&lt;strong>store gateway&lt;/strong>负责对象存储中的指标数据的读取&lt;/li>
&lt;li>&lt;strong>querier&lt;/strong>负责执行PromQL查询，它会向&lt;strong>store gateway&lt;/strong>、&lt;strong>sidecar&lt;/strong>s以及其它&lt;strong>querier&lt;/strong>中读取数据并进行聚合&lt;/li>
&lt;/ol>
&lt;p>可以看出，thanos的能力更侧重于“数据备份”和“视图整合”这两个方面，其查询层的设计使得可以非常方便地实现多集群的指标收集和查询，得益于其简洁的设计，部署和配置的复杂度也相对较低。
相比thanos，cortex的能力更为全面，比如：&lt;/p>
&lt;ul>
&lt;li>cortex支持通过API的形式配置指标规则和告警，这点对于没有很好地实践DevOps的团队来说更为友好&lt;/li>
&lt;li>通过二者的查询实现可以看出，cortex的查询性能会相对来说更好一些&lt;/li>
&lt;li>cortex的水平扩展能力相对较高&lt;/li>
&lt;li>cortex对多租户的支持更完善一些（比如支持对每个租户的用量控制等）&lt;/li>
&lt;/ul></description></item><item><title>使用dotnet-monitor收集k8s中.NET应用的诊断数据</title><link>http://suraciii.github.io/posts/dotnet-monitor-diag-memory-threading/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/dotnet-monitor-diag-memory-threading/</guid><description>&lt;p>平常在用Visual Studio开发.NET应用时，可以在调试时使用性能诊断工具对应用进行诊断，调查其中诸如内存泄露、线程阻塞等问题。&lt;/p>
&lt;p>但是对于线上尤其是运行在容器中的应用来说，收集诊断数据是非常麻烦的，这里介绍使用dotnet-monitor来方便地收集.NET应用诊断数据。&lt;/p>
&lt;p>只需要按如下方式对应用的deployment/statefulset进行修改：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">apiVersion&lt;/span>: apps/v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">kind&lt;/span>: Deployment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">template&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">app&lt;/span>: myapp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">containers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#434f54">name&lt;/span>: myapp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">image&lt;/span>: myapp:latest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#434f54">name&lt;/span>: DOTNET_DiagnosticPorts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">value&lt;/span>: /diag/port
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">volumeMounts&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#434f54">mountPath&lt;/span>: /diag
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">name&lt;/span>: diagvol
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#434f54">mountPath&lt;/span>: /dumps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">name&lt;/span>: dumpsvol
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#434f54">name&lt;/span>: monitor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">image&lt;/span>: mcr.microsoft.com/dotnet/monitor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">args&lt;/span>: [ &lt;span style="color:#7f8c8d">&amp;#34;--no-auth&amp;#34;&lt;/span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#434f54">name&lt;/span>: DOTNETMONITOR_Urls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">value&lt;/span>: http://localhost:52323
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#434f54">name&lt;/span>: DOTNETMONITOR_DiagnosticPort__ConnectionMode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">value&lt;/span>: Listen
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#434f54">name&lt;/span>: DOTNETMONITOR_DiagnosticPort__EndpointName
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">value&lt;/span>: /diag/port
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#434f54">name&lt;/span>: DOTNETMONITOR_Storage__DumpTempFolder
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">value&lt;/span>: /dumps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">volumeMounts&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#434f54">mountPath&lt;/span>: /diag
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">name&lt;/span>: diagvol
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#434f54">mountPath&lt;/span>: /dumps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">name&lt;/span>: dumpsvol
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">resources&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">requests&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">cpu&lt;/span>: 50m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">memory&lt;/span>: 32Mi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">limits&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">cpu&lt;/span>: 250m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">memory&lt;/span>: 256Mi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#434f54">name&lt;/span>: diagvol
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">emptyDir&lt;/span>: {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#434f54">name&lt;/span>: dumpsvol
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">emptyDir&lt;/span>: {}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面进行了三个改动：&lt;/p>
&lt;ol>
&lt;li>添加了名为&lt;code>monitor&lt;/code>的容器作为sidecar&lt;/li>
&lt;li>分别添加了两个名为&lt;code>diagvol&lt;/code>和&lt;code>dumpsvol&lt;/code>的空目录volumes，并挂载到被诊断应用和monitor中&lt;/li>
&lt;li>为被诊断应用配置&lt;code>DOTNET_DiagnosticPorts&lt;/code>环境变量&lt;/li>
&lt;/ol>
&lt;p>Pod启动后，dotnet-monitor会同被诊断应用的.NET运行时进行IPC通讯，并且dotnet-monitor会将控制命令以API的形式对我们开放。&lt;/p>
&lt;p>API列表：&lt;/p>
&lt;ul>
&lt;li>&lt;code>/processes&lt;/code> 获取相关进程的详细信息&lt;/li>
&lt;li>&lt;code>/dump&lt;/code> 获取内存dump&lt;/li>
&lt;li>&lt;code>/gcdump&lt;/code> 获取GCdump&lt;/li>
&lt;li>&lt;code>/trace&lt;/code> 获取进程追踪数据&lt;/li>
&lt;li>&lt;code>/metrics&lt;/code> 以Prometheus格式发布指标数据&lt;/li>
&lt;li>&lt;code>/livemetrics&lt;/code> 获取进程的实时指标&lt;/li>
&lt;li>&lt;code>/logs&lt;/code> 获取进程所产生的日志&lt;/li>
&lt;li>&lt;code>/info&lt;/code> 获取dotnet-monitor的信息&lt;/li>
&lt;li>&lt;code>/operations&lt;/code> 获取或取消当前进行中的操作&lt;/li>
&lt;/ul>
&lt;p>这里以两个主要的诊断场景&lt;code>trace&lt;/code>和&lt;code>gcdump&lt;/code>举例演示诊断一个有内存泄露和线程阻塞问题的应用&lt;/p>
&lt;p>通过&lt;code>kubectl port-forward&lt;/code>命令，转发monitor容器的请求到本机，在浏览器中访问&lt;code>http://localhost:52323/gcdump&lt;/code>，即可捕获并下载被诊断应用的gcdump。&lt;/p>
&lt;p>下载完成后，通过perfview打开：&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/dotnet-monitor-diag-memory-threading/2.png" alt="">
&lt;img src="http://suraciii.github.io/dotnet-monitor-diag-memory-threading/3.png" alt="">&lt;/p>
&lt;p>可以看到内存主要被一个保存了大量&lt;code>Mail&lt;/code>对象的&lt;code>ConcurrentBag&lt;/code>所占用。&lt;/p>
&lt;h4 id="关于线程阻塞及线程池饥饿问题的诊断">关于线程阻塞及线程池饥饿问题的诊断&lt;/h4>
&lt;p>访问&lt;code>http://localhost:52323/trace?profile=cpu&lt;/code>，即可捕捉应用的跟踪信息并下载，默认会记录30秒的数据，可以通过&lt;code>durationSeconds&lt;/code>参数更改记录时间。
下载完成后，通过perfview打开&lt;/p>
&lt;p>dotnet-monitor内部使用的是和dotnet-trace同样的方式记录追踪信息，而它们都是无法获得线程阻塞时间的数据的，想要获得线程阻塞时间数据，需要使用perfcollect并开启-threadtime选项来收集诊断信息（或者在windows上使用perfview开启/threadTime进行收集）&lt;/p>
&lt;p>但是我们依然可以通过dotnet-monitor来得知应用当前线程池的大小、线程队列的长度、线程的调用堆栈等信息，从中也一定程度上可以识别线程池饥饿、定位到导致线程阻塞的代码，如图：
&lt;img src="http://suraciii.github.io/dotnet-monitor-diag-memory-threading/9.png" alt="">&lt;br>
从上图可以看到.NET运行时在不断地创建新的线程&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/dotnet-monitor-diag-memory-threading/11.png" alt="">&lt;br>
从上图可以看到由于&lt;code>Starvation&lt;/code>，线程池大小在发生变化（增加）&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/dotnet-monitor-diag-memory-threading/10.png" alt="">
在调用堆栈中可以看到有导致线程阻塞的代码&lt;/p></description></item><item><title>如何在不中断作业执行的情况下更新Kubernetes中的应用版本</title><link>http://suraciii.github.io/posts/upgrade-job-execution-app-in-k8s/</link><pubDate>Mon, 31 Jan 2022 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/upgrade-job-execution-app-in-k8s/</guid><description>&lt;p>有这么一个案例：&lt;/p>
&lt;blockquote>
&lt;p>Q部门在开发一个应用，应用部署在Kubernetes中，应用中有一个功能是定时或即时地运行用户所配置的作业任务，这些作业通常要耗时几分钟到十几分钟，应用的部署和更新由Kubernetes中的deployment控制，每次部署更新，都是修改deployment中的容器镜像版本，Kubernetes就会逐步把旧版本pod删除掉，并创建出新版本的pod，现在Q部门遇到了这么一个问题：每次部署更新应用的版本时，总是会导致应用中作业执行被中断，他们想在更新版本时避免任务中断&lt;/p>
&lt;/blockquote>
&lt;p>怎么解决这个问题呢？&lt;/p>
&lt;p>这里我有两个思路，这两个思路有些类似又有些不同。&lt;/p>
&lt;p>类似的地方在于，这两个思路都需要将应用分成两部分，一部分为控制侧，一部分为工作侧，控制侧负责作业的管理、配置、调度等，工作侧负责作业的执行，我们的部署更新只会更新控制侧，工作侧的更新交由给控制侧来控制。
&lt;img src="http://suraciii.github.io/upgrade-job-execution-app-in-k8s/1.png" alt="">&lt;/p>
&lt;p>具体来讲，第一个思路里，工作侧会是若干个工作节点，工作节点是常驻的，有任务就执行，没任务就待机，工作节点可以主动从控制侧拉取任务，或者是由控制侧向工作节点发送任务执行命令。&lt;/p>
&lt;p>在部署更新时，我们首先只更新控制侧的应用版本，然后由控制侧通过Kubernetes API更新工作节点，更新节点前首先确认当前节点是否正在执行任务，只有节点处于空闲状态时才会进行更新，并且在更新前会将节点状态设为“维护中”，使其在更新完成前不会接受新的任务。&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/upgrade-job-execution-app-in-k8s/2.png" alt="">&lt;/p>
&lt;p>节点的更新可以自动触发，或者是设置一个管理按钮，点一下即可开始升级各个节点。&lt;/p>
&lt;p>另一个思路和上面的类似，只是工作侧从常驻的工作节点换成了暂态的作业执行器，每次需要执行作业时，都创建出一个作业执行器，由执行器负责作业的执行。&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/upgrade-job-execution-app-in-k8s/3.png" alt="">&lt;/p>
&lt;p>在这里，控制侧永远只会创建作业执行器，而不会对其进行更新，作业执行器所负责的作业执行完成后就不再工作等待销毁，新作业会由新创建的执行器负责执行。&lt;/p>
&lt;p>这两个思路都是将应用分成了&lt;strong>控制侧&lt;/strong>和&lt;strong>工作侧&lt;/strong>，应用部署时只更新控制侧的应用版本，&lt;strong>工作侧的更新由控制侧通过Kubernetes的API来控制进行&lt;/strong>，区别是，第一个方案里，工作侧是&lt;strong>长生命周期&lt;/strong>的不停执行作业的工作节点，第二个方案里工作侧是只执行一次特定作业的&lt;strong>短生命周期&lt;/strong>的一次性执行器。&lt;/p>
&lt;p>很可惜的是，这两个方案都没有被Q部门采用，因为Q部门不愿意将作业执行部分从应用中分离出来（我猜可能是认为做起来比较麻烦吧），而选择容忍应用部署更新时对作业执行的中断。
不过如果遇到&lt;strong>无法容忍应用更新导致作业中断的场景&lt;/strong>的话，这两个思路应该是值得参考的。&lt;/p>
&lt;p>如果您有其它思路的话，欢迎同我分享~&lt;/p></description></item><item><title>使用领域建模梳理业务和分离复杂性</title><link>http://suraciii.github.io/posts/domain-modeling-for-coupon-lottery/</link><pubDate>Sun, 30 Jan 2022 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/domain-modeling-for-coupon-lottery/</guid><description>&lt;p>一日，同事C来找我交流，问如何做一个抽奖的功能——&lt;/p>
&lt;blockquote>
&lt;p>“我们给每个新注册的用户都赠送了一次抽奖的机会，用户进行购买也能够获得更多抽奖次数，我们会不定时开放一些转盘抽奖活动，用户抽奖的时候我们要先用他账号里的注册时赠送的抽奖机会，如果没有的话再用用户消费获得的抽奖次数，一个抽奖次数只能用一次要防止并发冲突导致被多次使用……我们准备把抽奖次数放到redis中，用户每次使用就把次数减一，但是又需要优先使用系统赠送的抽奖次数数，然后抽奖机会又需要有过期时间——”&lt;/p>
&lt;/blockquote>
&lt;p>作为一个&lt;strong>愚钝&lt;/strong>的程序员，我的大脑的思考能力实在是有限的紧，在听了前面一大串已经晕晕乎乎的，听到用redis来实现抽奖次数扣减和过期时间检查这里更是头昏脑胀，仿佛一团乱麻，什么也想不清楚，更别说给出什么有价值的意见了。&lt;/p>
&lt;p>我对C说：“你已经把我说晕了，咱们先别说redis什么的了。”&lt;/p>
&lt;p>说着我拿出纸笔，开始和C进行对话：&lt;/p>
&lt;p>我首先关注的是“抽奖”这个关键词，当然是因为C之前那一大段话都是围绕着“抽奖”讲述的，更具体地，是在讲述使用抽奖次数的策略，在捕捉到“抽奖次数”这个概念后，我在纸上写下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">type&lt;/span> &lt;span style="color:#a61717">抽奖机会&lt;/span> &lt;span style="color:#728e00">=&lt;/span> { };
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同时我对C说：“我们来用‘抽奖机会’来表示‘抽奖次数’吧。”，抽奖次数是一个比较模糊和口头化的概念，它蕴含着数量上的表达，我偏爱更严谨的词汇。&lt;/p>
&lt;p>“按照你刚才的描述，抽奖机会有两种，一种是用户注册时赠送的，另一种是用户消费后获得的。”&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">type&lt;/span> &lt;span style="color:#a61717">抽奖机会&lt;/span> &lt;span style="color:#728e00">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a61717">类型&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#39;注册赠送的&amp;#39;&lt;/span> &lt;span style="color:#728e00">|&lt;/span> &lt;span style="color:#7f8c8d">&amp;#39;消费获取的&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我问C：“除了类型，你认为抽奖机会还应该具备什么属性呢？”&lt;/p>
&lt;p>“过期时间！”，C回答。
于是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">type&lt;/span> &lt;span style="color:#a61717">抽奖机会&lt;/span> &lt;span style="color:#728e00">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a61717">类型&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#39;注册赠送的&amp;#39;&lt;/span> &lt;span style="color:#728e00">|&lt;/span> &lt;span style="color:#7f8c8d">&amp;#39;消费获取的&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">过期时间&lt;/span>: &lt;span style="color:#00979d">DateTime&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我接着说：“抽奖机会是发送给用户的，所以应该还应该记录其所有者。”，C表示同意。
“每个抽奖机会都是独立被使用的，应该也是需要可以被追溯的，那它应该有一个编号作为标识。”&lt;/p>
&lt;p>最终，我们有了一个映射&lt;code>抽奖机会&lt;/code>的模型：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">type&lt;/span> &lt;span style="color:#a61717">抽奖机会&lt;/span> &lt;span style="color:#728e00">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a61717">编号：抽奖机会&lt;/span>&lt;span style="color:#728e00">ID&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">持有人&lt;/span>: &lt;span style="color:#00979d">用户ID&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a61717">类型&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#39;注册赠送的&amp;#39;&lt;/span> &lt;span style="color:#728e00">|&lt;/span> &lt;span style="color:#7f8c8d">&amp;#39;消费获取的&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">过期时间&lt;/span>: &lt;span style="color:#00979d">DateTime&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接着用同样的方法，我们整理出来了这个业务场景中另外一个相关概念的模型：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">type&lt;/span> &lt;span style="color:#a61717">抽奖活动&lt;/span> &lt;span style="color:#728e00">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">编号&lt;/span>: &lt;span style="color:#00979d">抽奖活动ID&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">类型&lt;/span>: &lt;span style="color:#00979d">活动类型&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a61717">过期时间：&lt;/span>&lt;span style="color:#728e00">DateTime&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有了这两个模型后，我对C说：“现在我们有了对&lt;code>抽奖机会&lt;/code>和&lt;code>抽奖活动&lt;/code>这两个业务概念的描述，现在我们来分析这个抽奖业务的具体行为吧。”&lt;/p>
&lt;p>通过分析整理，我们找到了下面几个关键点：&lt;/p>
&lt;ol>
&lt;li>抽奖发生在一个具体的抽奖活动中&lt;/li>
&lt;li>抽奖时会选取用户的一个抽奖机会&lt;/li>
&lt;li>优先选择‘注册赠送的’抽奖机会&lt;/li>
&lt;li>优先选择临近过期的抽奖机会&lt;/li>
&lt;li>一个抽奖机会只能被使用一次&lt;/li>
&lt;/ol>
&lt;p>根据这些，我给出了一段伪代码来对抽奖行为进行描述：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">function&lt;/span> &lt;span style="color:#a61717">抽奖&lt;/span>(&lt;span style="color:#728e00">活动&lt;/span>: &lt;span style="color:#00979d">抽奖活动&lt;/span>, &lt;span style="color:#728e00">用户ID&lt;/span>: &lt;span style="color:#00979d">用户ID&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">if&lt;/span>(&lt;span style="color:#a61717">已过期&lt;/span>(&lt;span style="color:#a61717">活动&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">throw&lt;/span> &lt;span style="color:#7f8c8d">&amp;#39;活动已过期&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">const&lt;/span> &lt;span style="color:#a61717">机会&lt;/span> &lt;span style="color:#728e00">=&lt;/span> &lt;span style="color:#a61717">获取抽奖机会&lt;/span>(&lt;span style="color:#a61717">用户&lt;/span>&lt;span style="color:#728e00">ID&lt;/span>) &lt;span style="color:#95a5a6">// 优先注册赠送 优先临近过期
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a61717">使用抽奖机会&lt;/span>(&lt;span style="color:#a61717">机会&lt;/span>, &lt;span style="color:#a61717">活动&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这里，我们发现，为了保证“一个抽奖机会只能被使用一次”，我们需要有一个属性来识别抽奖机会是否已经被使用，于是我们更新了抽奖机会的模型：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">type&lt;/span> &lt;span style="color:#a61717">抽奖机会&lt;/span> &lt;span style="color:#728e00">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a61717">编号：抽奖机会&lt;/span>&lt;span style="color:#728e00">ID&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">持有人&lt;/span>: &lt;span style="color:#00979d">用户ID&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a61717">类型&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#39;注册赠送的&amp;#39;&lt;/span> &lt;span style="color:#728e00">|&lt;/span> &lt;span style="color:#7f8c8d">&amp;#39;购买获取的&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">过期时间&lt;/span>: &lt;span style="color:#00979d">DateTime&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">+&lt;/span> &lt;span style="color:#a61717">状态&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#39;已使用&amp;#39;&lt;/span> &lt;span style="color:#728e00">|&lt;/span> &lt;span style="color:#7f8c8d">&amp;#39;未使用&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>并且在使用抽奖机会时，更新抽奖机会的状态。&lt;/p>
&lt;p>接着，我们又发现，为了避免在并发请求中，获取到已被其它请求获取但是还并未被使用的抽奖机会，我们需要额外一个状态来标志这个抽奖机会已经被某个抽奖请求获取到了，随时可能会被更新为&lt;code>已使用&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">type&lt;/span> &lt;span style="color:#a61717">抽奖机会&lt;/span> &lt;span style="color:#728e00">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">&lt;/span> &lt;span style="color:#a61717">状态&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#39;已使用&amp;#39;&lt;/span> &lt;span style="color:#728e00">|&lt;/span> &lt;span style="color:#7f8c8d">&amp;#39;未使用&amp;#39;&lt;/span> &lt;span style="color:#728e00">|&lt;/span> &lt;span style="color:#7f8c8d">&amp;#39;已被获取&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">function&lt;/span> &lt;span style="color:#a61717">抽奖&lt;/span>(&lt;span style="color:#728e00">活动&lt;/span>: &lt;span style="color:#00979d">抽奖活动&lt;/span>, &lt;span style="color:#728e00">用户ID&lt;/span>: &lt;span style="color:#00979d">用户ID&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">const&lt;/span> &lt;span style="color:#a61717">机会&lt;/span> &lt;span style="color:#728e00">=&lt;/span> &lt;span style="color:#a61717">获取未使用抽奖机会&lt;/span>(&lt;span style="color:#a61717">用户&lt;/span>&lt;span style="color:#728e00">ID&lt;/span>) &lt;span style="color:#95a5a6">// 同时更新其状态为&amp;#39;已被获取&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">&lt;/span> &lt;span style="color:#95a5a6">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>到了这里，C说，“那我明白该怎么做了”&lt;/p>
&lt;p>可以看到，经过了这番对话，我们将这个抽奖的业务场景进行分析梳理，写清楚其中的各个概念、规则、行为后，发现其实根本不需要什么redis，而所谓的‘抽奖次数’实际上是具备完整的自己的生命周期的对象，而非是一个加加减减的标量。&lt;/p>
&lt;p>有学习过领域驱动设计的朋友应该可以明显看出，上面我和C在做的的其实是在进行简略的领域建模。&lt;/p>
&lt;h2 id="关于领域建模">关于领域建模&lt;/h2>
&lt;p>&lt;strong>领域建模就是对特定业务问题进行梳理、探索、提炼，将其从一个松散的口头信息描述，抽象转化为一系列能够帮助我们解决问题的概念、关系和流程模型。&lt;/strong>&lt;/p>
&lt;p>就像是问开车到商场要多久，我们并不能直接得到答案，而是先将这个场景转化为：车的&lt;strong>时速&lt;/strong>是多少？从这里到商场的&lt;strong>路程&lt;/strong>要多远？然后再套用&lt;strong>速率公式&lt;/strong>，有了这些，我们才能得到想要的答案。&lt;/p>
&lt;p>而对于软件开发，虽然有所不同，但是也有着一样的道理，我们开发软件总是为了解决一些问题，尤其是对于许多业务系统来说，要解决这些业务问题，就一定要对它的业务领域有所了解，领域建模就是一个帮助我们学习目标业务领域中的知识，并将业务问题抽象成可以帮助我们解决这个问题的模型的方法。&lt;/p>
&lt;p>事实上，无论我们是否有这个意识，只要我们是在开发业务系统，其相关的业务领域中的知识就或清晰或混乱地存在于我们的代码中，而在开发时，我们一定也会主动或被动地对相关业务领域进行建模——我们设计的类、数据库表结构、模块等，无一不是在对真实世界中的业务进行的抽象，它们都在一定程度上以某种角度描述了相关的业务领域。&lt;/p>
&lt;p>但是许多时候，这些领域知识或者说模型，总是松散而重复地分散在系统各处，这边一点，那边一点，又同应用逻辑杂糅在一起，这为我们造成了相当程度上的认知负担，尤其是对于我这样愚钝的程序员来说，接收到的信息稍微多一点混乱一点，我的脑袋就什么都想不清楚了。&lt;/p>
&lt;p>所以我们要把我们开发时被动地做的学习业务中的知识，整理业务中的概念等事情，变成在开发时首先做、主动做、专注做。&lt;/p>
&lt;p>这么做有几个好处：&lt;/p>
&lt;ol>
&lt;li>帮助我们更准确地理解业务&lt;/li>
&lt;li>隔离应用逻辑和数据库实现，专注于对业务领域的探索和分析，降低问题的复杂度&lt;/li>
&lt;li>模型成果作为代码存在于项目之中，代码中的业务逻辑更容易理解&lt;/li>
&lt;li>团队成员尤其是新成员可以有效地从代码中学习到领域知识，并且有着统一的认识&lt;/li>
&lt;/ol>
&lt;p>上面说过，我和C所做的是“简略”的领域建模，与完整的领域建模有着许多不同，比如在真正进行完整的领域建模时，我应该和C首先以业务专用语言进行用户叙事，来尽量获得业务场景的全貌，又比如还有实体和值对象的识别，领域上下文的整理和映射等。
不过由于这是一个非常有限的业务场景，而我也只是需要来借助领域建模来帮助我梳理这个特定业务场景，帮助我能看清楚这个问题的本质，所以也就不需要那么麻烦。&lt;/p></description></item><item><title>使用Pulumi在Kubernetes中部署应用</title><link>http://suraciii.github.io/posts/use-pulumi-to-deploy-app-in-k8s/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/use-pulumi-to-deploy-app-in-k8s/</guid><description>&lt;p>Pulumi是一个现代&lt;code>基础设施即代码(infrastructure as code)&lt;/code>平台，通过它，我们可以使用我们熟悉的编程语言和工具来构建、部署和管理云及云原生基础设施。&lt;/p>
&lt;p>来看一个最简单的例子，准备如下typescript代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">import&lt;/span> &lt;span style="color:#728e00">*&lt;/span> &lt;span style="color:#00979d">as&lt;/span> &lt;span style="color:#728e00">pulumi&lt;/span> &lt;span style="color:#00979d">from&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;@pulumi/pulumi&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">import&lt;/span> &lt;span style="color:#728e00">*&lt;/span> &lt;span style="color:#00979d">as&lt;/span> &lt;span style="color:#728e00">aws&lt;/span> &lt;span style="color:#00979d">from&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;@pulumi/aws&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">const&lt;/span> &lt;span style="color:#728e00">group&lt;/span> &lt;span style="color:#728e00">=&lt;/span> &lt;span style="color:#728e00">new&lt;/span> &lt;span style="color:#728e00">aws&lt;/span>.&lt;span style="color:#728e00">ec2&lt;/span>.&lt;span style="color:#728e00">SecurityGroup&lt;/span>(&lt;span style="color:#7f8c8d">&amp;#34;web-sg&amp;#34;&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">description&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;Enable HTTP access&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">ingress&lt;/span>&lt;span style="color:#728e00">:&lt;/span> [{ &lt;span style="color:#728e00">protocol&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;tcp&amp;#34;&lt;/span>, &lt;span style="color:#728e00">fromPort&lt;/span>: &lt;span style="color:#00979d">80&lt;/span>, &lt;span style="color:#728e00">toPort&lt;/span>: &lt;span style="color:#00979d">80&lt;/span>, &lt;span style="color:#728e00">cidrBlocks&lt;/span>&lt;span style="color:#728e00">:&lt;/span> [&lt;span style="color:#7f8c8d">&amp;#34;0.0.0.0/0&amp;#34;&lt;/span>] }],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">const&lt;/span> &lt;span style="color:#728e00">server&lt;/span> &lt;span style="color:#728e00">=&lt;/span> &lt;span style="color:#728e00">new&lt;/span> &lt;span style="color:#728e00">aws&lt;/span>.&lt;span style="color:#728e00">ec2&lt;/span>.&lt;span style="color:#728e00">Instance&lt;/span>(&lt;span style="color:#7f8c8d">&amp;#34;web-server&amp;#34;&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">ami&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;ami-6869aa05&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">instanceType&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;t2.micro&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">vpcSecurityGroupIds&lt;/span>&lt;span style="color:#728e00">:&lt;/span> [ &lt;span style="color:#728e00">group&lt;/span>.&lt;span style="color:#728e00">name&lt;/span> ], &lt;span style="color:#95a5a6">// reference the security group resource above
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">&lt;/span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行&lt;code>pulumi up&lt;/code>命令，即可在AWS中创建一个ec2实例并配置其安全组。&lt;/p>
&lt;p>如果我们需要修改其安全组配置，加上443端口的入口，那么只需要更改代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">const&lt;/span> &lt;span style="color:#728e00">group&lt;/span> &lt;span style="color:#728e00">=&lt;/span> &lt;span style="color:#728e00">new&lt;/span> &lt;span style="color:#728e00">aws&lt;/span>.&lt;span style="color:#728e00">ec2&lt;/span>.&lt;span style="color:#728e00">SecurityGroup&lt;/span>(&lt;span style="color:#7f8c8d">&amp;#34;web-sg&amp;#34;&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">description&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;Enable HTTP access&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">ingress&lt;/span>&lt;span style="color:#728e00">:&lt;/span> [{ &lt;span style="color:#728e00">protocol&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;tcp&amp;#34;&lt;/span>, &lt;span style="color:#728e00">fromPort&lt;/span>: &lt;span style="color:#00979d">80&lt;/span>, &lt;span style="color:#728e00">toPort&lt;/span>: &lt;span style="color:#00979d">80&lt;/span>, &lt;span style="color:#728e00">cidrBlocks&lt;/span>&lt;span style="color:#728e00">:&lt;/span> [&lt;span style="color:#7f8c8d">&amp;#34;0.0.0.0/0&amp;#34;&lt;/span>] },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { &lt;span style="color:#728e00">protocol&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;tcp&amp;#34;&lt;/span>, &lt;span style="color:#728e00">fromPort&lt;/span>: &lt;span style="color:#00979d">443&lt;/span>, &lt;span style="color:#728e00">toPort&lt;/span>: &lt;span style="color:#00979d">443&lt;/span>, &lt;span style="color:#728e00">cidrBlocks&lt;/span>&lt;span style="color:#728e00">:&lt;/span> [&lt;span style="color:#7f8c8d">&amp;#34;0.0.0.0/0&amp;#34;&lt;/span>] }],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再次运行&lt;code>pulumi up&lt;/code>命令，即可对相关安全组进行更新。&lt;/p>
&lt;p>这里的例子是使用tyescript代码管理AWS中的资源，此外，Pulumi还支持python、C#、go等编程语言，以及Azure、GCP、阿里云、Kubernetes等平台。&lt;/p>
&lt;p>Pulumi作为一个基础设施即代码工具，首先其当然也具备基础设施即代码这种实践的优点，如：&lt;/p>
&lt;ul>
&lt;li>基础设施的定义作为代码可以被版本控制&lt;/li>
&lt;li>因此可以被review和revert&lt;/li>
&lt;li>实践基础设施即代码可以帮助团队以可靠、可重复、可控制的方式部署系统资源&lt;/li>
&lt;li>也可以为自动化部署和减少人工出错提供帮助&lt;/li>
&lt;li>此外还有：提高不同环境中的基础设施的一致性，降低基础设施及其部署过程的复杂性等&lt;/li>
&lt;/ul>
&lt;p>具体关于基础设施即代码这里不再赘述，重点是，Pulumi相对于其它基础设施即代码的平台和工具，如Terraform、ARM、Ksonnet等，具备如何的优势呢？&lt;/p>
&lt;h3 id="pulumi的优势">Pulumi的优势&lt;/h3>
&lt;p>首先Pulumi最大的优点是其学习成本低，学习曲线平缓。&lt;br>
能够采用基础设施即代码实践的团队，基本上要么就是实践的DevOps，授权开发者来管理产品基础设施，要么团队运维人员也会掌握编程技能，而Pulumi使用go、typescript等常用的编程语言作为其管理基础设施的代码，这些语言对于上面说的使用者来说算得上是轻车熟路了，只需要使用自己常用的编程语言，不需要面对任何自创的五花八门奇奇怪怪的语法和模板。&lt;/p>
&lt;p>另外，如typescript、go、C#这些编程语言，功能上都十分完备，也有着非常完善的IDE支持，比如我们可以在代码中使用栈和队列等数据结构，可以进行抽象、封装，定义类和函数等，甚至我们可以对这些基础设施代码进行调试和单元测试，这在其它依靠Json/Yaml或者模板为主的工具上基本是无法做到的。&lt;/p>
&lt;h3 id="使用pulumi在kubernetes中部署应用">使用Pulumi在Kubernetes中部署应用&lt;/h3>
&lt;p>这里简单演示如何使用Pulumi在Kubernetes中部署应用。&lt;/p>
&lt;p>首先我们需要安装Pulumi CLI，通过macOS上的Homebrew和Windows上的Chocolatey等工具都可以直接安装Pulumi CLI，Linux下可以通过&lt;code>curl -fsSL https://get.pulumi.com | sh&lt;/code>命令安装。&lt;/p>
&lt;p>安装完成后，我们需要配置Pulumi存储资源状态的方式及路径，可以选择&lt;code>pulumi login https://api.pulumi.com&lt;/code>使用Pulumi平台存储状态，也可以选择&lt;code>pulumi login file://.&lt;/code>将状态保存到本地&lt;code>.pulumi&lt;/code>（相对或绝对）路径下，也支持通过Azure KeyVault等密文管理产品来存储&lt;/p>
&lt;p>然后选择一个合适的路径，运行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ pulumi new kubernetes-typescript
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>（这里以使用typescript为例，也可以使用其它编程语言。）&lt;/p>
&lt;p>跟着指引一步步填写相关信息，如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>project name: demo-meetingsvc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>project description: A meeting service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stack name: dev &lt;span style="color:#95a5a6"># stack可以简单理解为环境&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行完成后，Pulumi会在目录中生成项目以及初始实例代码，可以打开&lt;code>index.ts&lt;/code>查看：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">import&lt;/span> &lt;span style="color:#728e00">*&lt;/span> &lt;span style="color:#00979d">as&lt;/span> &lt;span style="color:#728e00">k8s&lt;/span> &lt;span style="color:#00979d">from&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;@pulumi/kubernetes&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">const&lt;/span> &lt;span style="color:#728e00">appLabels&lt;/span> &lt;span style="color:#728e00">=&lt;/span> { &lt;span style="color:#728e00">app&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;nginx&amp;#34;&lt;/span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">const&lt;/span> &lt;span style="color:#728e00">deployment&lt;/span> &lt;span style="color:#728e00">=&lt;/span> &lt;span style="color:#728e00">new&lt;/span> &lt;span style="color:#728e00">k8s&lt;/span>.&lt;span style="color:#728e00">apps&lt;/span>.&lt;span style="color:#728e00">v1&lt;/span>.&lt;span style="color:#728e00">Deployment&lt;/span>(&lt;span style="color:#7f8c8d">&amp;#34;nginx&amp;#34;&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">spec&lt;/span>&lt;span style="color:#728e00">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">selector&lt;/span>&lt;span style="color:#728e00">:&lt;/span> { &lt;span style="color:#728e00">matchLabels&lt;/span>: &lt;span style="color:#00979d">appLabels&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">replicas&lt;/span>: &lt;span style="color:#00979d">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">template&lt;/span>&lt;span style="color:#728e00">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">metadata&lt;/span>&lt;span style="color:#728e00">:&lt;/span> { &lt;span style="color:#728e00">labels&lt;/span>: &lt;span style="color:#00979d">appLabels&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">spec&lt;/span>&lt;span style="color:#728e00">:&lt;/span> { &lt;span style="color:#728e00">containers&lt;/span>&lt;span style="color:#728e00">:&lt;/span> [{ &lt;span style="color:#728e00">name&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;nginx&amp;#34;&lt;/span>, &lt;span style="color:#728e00">image&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;nginx&amp;#34;&lt;/span> }] }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">export&lt;/span> &lt;span style="color:#00979d">const&lt;/span> &lt;span style="color:#728e00">name&lt;/span> &lt;span style="color:#728e00">=&lt;/span> &lt;span style="color:#728e00">deployment&lt;/span>.&lt;span style="color:#728e00">metadata&lt;/span>.&lt;span style="color:#728e00">name&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码的作用是创建一个nginx部署，我们可以删掉这段代码，改成我们想要的。&lt;/p>
&lt;p>首先，新建一个命名空间：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">import&lt;/span> &lt;span style="color:#728e00">*&lt;/span> &lt;span style="color:#00979d">as&lt;/span> &lt;span style="color:#728e00">pulumi&lt;/span> &lt;span style="color:#00979d">from&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;@pulumi/pulumi&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">import&lt;/span> &lt;span style="color:#728e00">*&lt;/span> &lt;span style="color:#00979d">as&lt;/span> &lt;span style="color:#728e00">kubernetes&lt;/span> &lt;span style="color:#00979d">from&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;@pulumi/kubernetes&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">const&lt;/span> &lt;span style="color:#00979d">namespace&lt;/span> &lt;span style="color:#728e00">=&lt;/span> &lt;span style="color:#728e00">new&lt;/span> &lt;span style="color:#728e00">kubernetes&lt;/span>.&lt;span style="color:#728e00">core&lt;/span>.&lt;span style="color:#728e00">v1&lt;/span>.&lt;span style="color:#728e00">Namespace&lt;/span>(&lt;span style="color:#7f8c8d">&amp;#34;my-namespace&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行&lt;code>pulumi up&lt;/code>，会首先进行变更预览：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>Previewing update &lt;span style="color:#728e00">(&lt;/span>dev&lt;span style="color:#728e00">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Type Name Plan
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> + pulumi:pulumi:Stack demo-meetingsvc-dev create
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> + └─ kubernetes:core/v1:Namespace my-namespace create
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Resources:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> + &lt;span style="color:#8a7b52">2&lt;/span> to create
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Do you want to perform this update? &lt;span style="color:#728e00">[&lt;/span>Use arrows to move, enter to &lt;span style="color:#728e00">select&lt;/span>, &lt;span style="color:#728e00">type&lt;/span> to filter&lt;span style="color:#728e00">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; no
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> details
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>选择&lt;code>details&lt;/code>可以查看即将进行的改动详情：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>Do you want to perform this update? details
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+ pulumi:pulumi:Stack: &lt;span style="color:#728e00">(&lt;/span>create&lt;span style="color:#728e00">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">[&lt;/span>&lt;span style="color:#434f54">urn&lt;/span>&lt;span style="color:#728e00">=&lt;/span>urn:pulumi:dev::demo-meetingsvc::pulumi:pulumi:Stack::demo-meetingsvc-dev&lt;span style="color:#728e00">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> + kubernetes:core/v1:Namespace: &lt;span style="color:#728e00">(&lt;/span>create&lt;span style="color:#728e00">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">[&lt;/span>&lt;span style="color:#434f54">urn&lt;/span>&lt;span style="color:#728e00">=&lt;/span>urn:pulumi:dev::demo-meetingsvc::kubernetes:core/v1:Namespace::my-namespace&lt;span style="color:#728e00">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">[&lt;/span>&lt;span style="color:#434f54">provider&lt;/span>&lt;span style="color:#728e00">=&lt;/span>urn:pulumi:dev::demo-meetingsvc::pulumi:providers:kubernetes::default_3_14_1::04da6b54-80e4-46f7-96ec-b56ff0331ba9&lt;span style="color:#728e00">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apiVersion: &lt;span style="color:#7f8c8d">&amp;#34;v1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind : &lt;span style="color:#7f8c8d">&amp;#34;Namespace&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadata : &lt;span style="color:#728e00">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> annotations: &lt;span style="color:#728e00">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pulumi.com/autonamed: &lt;span style="color:#7f8c8d">&amp;#34;true&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> labels : &lt;span style="color:#728e00">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> app.kubernetes.io/managed-by: &lt;span style="color:#7f8c8d">&amp;#34;pulumi&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name : &lt;span style="color:#7f8c8d">&amp;#34;my-namespace-20a6saph&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>选择&lt;code>yes&lt;/code>便会真正进行相应的改动:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>Do you want to perform this update? yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Updating &lt;span style="color:#728e00">(&lt;/span>dev&lt;span style="color:#728e00">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Type Name Status
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> + pulumi:pulumi:Stack demo-meetingsvc-dev created
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> + └─ kubernetes:core/v1:Namespace my-namespace created
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Resources:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> + &lt;span style="color:#8a7b52">2&lt;/span> created
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Duration: 4s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用kubectl查看，可以看到创建出了一个新的namespace：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ kubectl get ns
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME STATUS AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>my-namespace-ifywo1p0 Active 1m
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到新创建的namespace带了一个后缀，这是Pulumi为了维护&lt;code>不可变基础设施&lt;/code>而故意设计的一种行为，它的好处这里先不做介绍，如果不想要这个后缀，可以显示指定资源名字而非自动生成：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">const&lt;/span> &lt;span style="color:#00979d">namespace&lt;/span> &lt;span style="color:#728e00">=&lt;/span> &lt;span style="color:#728e00">new&lt;/span> &lt;span style="color:#728e00">k8s&lt;/span>.&lt;span style="color:#728e00">core&lt;/span>.&lt;span style="color:#728e00">v1&lt;/span>.&lt;span style="color:#728e00">Namespace&lt;/span>(&lt;span style="color:#7f8c8d">&amp;#34;my-namespace&amp;#34;&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">metadata&lt;/span>&lt;span style="color:#728e00">:&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">name&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;my-namespace&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>命名空间创建好后，接着添加deployment和service：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">const&lt;/span> &lt;span style="color:#728e00">appName&lt;/span> &lt;span style="color:#728e00">=&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;meetingsvc&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">const&lt;/span> &lt;span style="color:#728e00">image&lt;/span> &lt;span style="color:#728e00">=&lt;/span> &lt;span style="color:#7f8c8d">`&lt;/span>&lt;span style="color:#7f8c8d">${&lt;/span>&lt;span style="color:#728e00">imageRepo&lt;/span>&lt;span style="color:#7f8c8d">}&lt;/span>&lt;span style="color:#7f8c8d">/&lt;/span>&lt;span style="color:#7f8c8d">${&lt;/span>&lt;span style="color:#728e00">imageName&lt;/span>&lt;span style="color:#7f8c8d">}&lt;/span>&lt;span style="color:#7f8c8d">:&lt;/span>&lt;span style="color:#7f8c8d">${&lt;/span>&lt;span style="color:#728e00">imageTag&lt;/span>&lt;span style="color:#7f8c8d">}&lt;/span>&lt;span style="color:#7f8c8d">`&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">const&lt;/span> &lt;span style="color:#728e00">selector&lt;/span> &lt;span style="color:#728e00">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f8c8d">&amp;#34;app.kubernetes.io/app&amp;#34;&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#728e00">appName&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">const&lt;/span> &lt;span style="color:#728e00">labels&lt;/span> &lt;span style="color:#728e00">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f8c8d">&amp;#34;app.kubernetes.io/part-of&amp;#34;&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;demo&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...&lt;span style="color:#728e00">selector&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">const&lt;/span> &lt;span style="color:#728e00">deployment&lt;/span> &lt;span style="color:#728e00">=&lt;/span> &lt;span style="color:#728e00">new&lt;/span> &lt;span style="color:#728e00">k8s&lt;/span>.&lt;span style="color:#728e00">apps&lt;/span>.&lt;span style="color:#728e00">v1&lt;/span>.&lt;span style="color:#728e00">Deployment&lt;/span>(&lt;span style="color:#728e00">appName&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">metadata&lt;/span>&lt;span style="color:#728e00">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">namespace&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#00979d">namespace&lt;/span>.&lt;span style="color:#728e00">metadata&lt;/span>.&lt;span style="color:#728e00">name&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">labels&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">spec&lt;/span>&lt;span style="color:#728e00">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">selector&lt;/span>&lt;span style="color:#728e00">:&lt;/span> { &lt;span style="color:#728e00">matchLabels&lt;/span>: &lt;span style="color:#00979d">selector&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">template&lt;/span>&lt;span style="color:#728e00">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">metadata&lt;/span>&lt;span style="color:#728e00">:&lt;/span> { &lt;span style="color:#728e00">labels&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">spec&lt;/span>&lt;span style="color:#728e00">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">containers&lt;/span>&lt;span style="color:#728e00">:&lt;/span> [{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">name&lt;/span>: &lt;span style="color:#00979d">appName&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">image&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">ports&lt;/span>&lt;span style="color:#728e00">:&lt;/span> [{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">containerPort&lt;/span>: &lt;span style="color:#00979d">80&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">name&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;http&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00979d">const&lt;/span> &lt;span style="color:#728e00">svc&lt;/span> &lt;span style="color:#728e00">=&lt;/span> &lt;span style="color:#728e00">new&lt;/span> &lt;span style="color:#728e00">k8s&lt;/span>.&lt;span style="color:#728e00">core&lt;/span>.&lt;span style="color:#728e00">v1&lt;/span>.&lt;span style="color:#728e00">Service&lt;/span>(&lt;span style="color:#728e00">appName&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">metadata&lt;/span>&lt;span style="color:#728e00">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">namespace&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#00979d">namespace&lt;/span>.&lt;span style="color:#728e00">metadata&lt;/span>.&lt;span style="color:#728e00">name&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">labels&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">spec&lt;/span>&lt;span style="color:#728e00">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">ports&lt;/span>&lt;span style="color:#728e00">:&lt;/span> [{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">port&lt;/span>: &lt;span style="color:#00979d">80&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">targetPort&lt;/span>&lt;span style="color:#728e00">:&lt;/span> &lt;span style="color:#7f8c8d">&amp;#34;http&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">selector&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}, { &lt;span style="color:#728e00">dependsOn&lt;/span>: &lt;span style="color:#00979d">deployment&lt;/span> });
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行&lt;code>pulumi up&lt;/code>即可预览并进行相关变更。
如果应用需要ingress，也可以通过相同的方式创建。&lt;/p>
&lt;h2 id="最后">最后&lt;/h2>
&lt;p>虽说Pulumi支持多种编程语言及运行时(node.js上的javascript、typescript，.net core上的C#、vb、F#，以及go和python），但是就个人经验来说，用起来最得心应手的还是typescript，主要是因为typescript有着十分完备、强大的类型系统，也一定程度上继承了javascript的灵活性，能用上一些很有意思的小花招，后面可以慢慢介绍。&lt;/p>
&lt;p>这篇就先写到这，后面准备写一下怎么用Pulumi做自动化部署，用Pulumi做更复杂的部署，组件的封装和打包等。&lt;/p>
&lt;p>如果有任何疑惑或者想法，欢迎找我交流~&lt;/p></description></item><item><title>.NET Activity API中的一个小陷阱</title><link>http://suraciii.github.io/posts/dotnet-activity-pitfall/</link><pubDate>Thu, 27 Jan 2022 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/dotnet-activity-pitfall/</guid><description>&lt;p>最近在为Orleans改进其分布式追踪组件(&lt;a href="https://github.com/dotnet/orleans/pull/7443">Use DistributedContextPropagator to propagate Activities&lt;/a>)的时候，从AspNetCore中抄了一些代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">// https://github.com/dotnet/aspnetcore/blob/9da42b9fab4c61fe46627ac0c6877905ec845d5a/src/Hosting/Hosting/src/Internal/HostingApplicationDiagnostics.cs#L272&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">private&lt;/span> &lt;span style="color:#434f54">Activity&lt;/span>? &lt;span style="color:#434f54">StartActivity&lt;/span>(&lt;span style="color:#434f54">HttpContext&lt;/span> &lt;span style="color:#434f54">httpContext&lt;/span>, &lt;span style="color:#00979d">bool&lt;/span> &lt;span style="color:#434f54">loggingEnabled&lt;/span>, &lt;span style="color:#00979d">bool&lt;/span> &lt;span style="color:#434f54">diagnosticListenerActivityCreationEnabled&lt;/span>, &lt;span style="color:#728e00">out&lt;/span> &lt;span style="color:#00979d">bool&lt;/span> &lt;span style="color:#434f54">hasDiagnosticListener&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">activity&lt;/span> = &lt;span style="color:#434f54">_activitySource&lt;/span>.&lt;span style="color:#434f54">CreateActivity&lt;/span>(&lt;span style="color:#434f54">ActivityName&lt;/span>, &lt;span style="color:#434f54">ActivityKind&lt;/span>.&lt;span style="color:#434f54">Server&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">headers&lt;/span> = &lt;span style="color:#434f54">httpContext&lt;/span>.&lt;span style="color:#434f54">Request&lt;/span>.&lt;span style="color:#434f54">Headers&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">_propagator&lt;/span>.&lt;span style="color:#434f54">ExtractTraceIdAndState&lt;/span>(&lt;span style="color:#434f54">headers&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">static&lt;/span> (&lt;span style="color:#00979d">object?&lt;/span> &lt;span style="color:#434f54">carrier&lt;/span>, &lt;span style="color:#00979d">string&lt;/span> &lt;span style="color:#434f54">fieldName&lt;/span>, &lt;span style="color:#728e00">out&lt;/span> &lt;span style="color:#00979d">string?&lt;/span> &lt;span style="color:#434f54">fieldValue&lt;/span>, &lt;span style="color:#728e00">out&lt;/span> &lt;span style="color:#434f54">IEnumerable&lt;/span>&amp;lt;&lt;span style="color:#00979d">string&lt;/span>&amp;gt;? &lt;span style="color:#434f54">fieldValues&lt;/span>) =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">fieldValues&lt;/span> = &lt;span style="color:#728e00">default&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">headers&lt;/span> = (&lt;span style="color:#434f54">IHeaderDictionary&lt;/span>)&lt;span style="color:#434f54">carrier&lt;/span>!;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">fieldValue&lt;/span> = &lt;span style="color:#434f54">headers&lt;/span>[&lt;span style="color:#434f54">fieldName&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">out&lt;/span> &lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">requestId&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">out&lt;/span> &lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">traceState&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">activity&lt;/span>.&lt;span style="color:#434f54">SetParentId&lt;/span>(&lt;span style="color:#434f54">requestId&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">if&lt;/span> (!&lt;span style="color:#00979d">string&lt;/span>.&lt;span style="color:#434f54">IsNullOrEmpty&lt;/span>(&lt;span style="color:#434f54">traceState&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">activity&lt;/span>.&lt;span style="color:#434f54">TraceStateString&lt;/span> = &lt;span style="color:#434f54">traceState&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段代码的作用是，创建Activity后，从请求头中尝试获取追踪信息（traceid等），如果存在的话，就通过&lt;code>activity.SetParentId(requestId)&lt;/code>将这个新创建的Activity与请求头中的追踪上下文关联，即进入链路成为其中的一个子片段。&lt;/p>
&lt;p>这个逻辑看起来没什么问题，也有相关的单元测试覆盖，于是我把这段代码抄到了Orleans里并最终合并进主干，但是不久后有一个开发者提了issue，报告了其中的问题——&lt;/p>
&lt;blockquote>
&lt;p>在使用OpenTelemetry SDK捕获Activities从而产生分布式追踪信息后，这些Activity所代表的Span并没有根据请求链路关联起来，而是各自成为了独立的链路。&lt;/p>
&lt;/blockquote>
&lt;p>这就十分令人好奇了——这是从AspNetCore代码库里抄来的代码，也有相关测试覆盖，为什么还会有问题？
于是使用OpenTelemetry SDK重现了这个bug并仔细调试后，发现了问题出现的原因：&lt;/p>
&lt;p>OpenTelemetry SDK记录应用的Activity时，有一个默认的采样器(Sampler)，在这个采样器中它会在创建Activity时访问相关&lt;code>ActivityCreationOptions&lt;/code>中的&lt;code>.TraceId&lt;/code>属性，再看其源码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">// https://github.com/dotnet/runtime/blob/970d347a1b06951692cfecc1cc12a500158708b1/src/libraries/System.Diagnostics.DiagnosticSource/src/System/Diagnostics/ActivityCreationOptions.cs#L128&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">public&lt;/span> &lt;span style="color:#434f54">ActivityTraceId&lt;/span> &lt;span style="color:#434f54">TraceId&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">get&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">if&lt;/span> (&lt;span style="color:#434f54">Parent&lt;/span> &lt;span style="color:#728e00">is&lt;/span> &lt;span style="color:#434f54">ActivityContext&lt;/span> &amp;amp;&amp;amp; &lt;span style="color:#434f54">IdFormat&lt;/span> == &lt;span style="color:#434f54">ActivityIdFormat&lt;/span>.&lt;span style="color:#434f54">W3C&lt;/span> &amp;amp;&amp;amp; &lt;span style="color:#434f54">_context&lt;/span> == &lt;span style="color:#728e00">default&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">Func&lt;/span>&amp;lt;&lt;span style="color:#434f54">ActivityTraceId&lt;/span>&amp;gt;? &lt;span style="color:#434f54">traceIdGenerator&lt;/span> = &lt;span style="color:#434f54">Activity&lt;/span>.&lt;span style="color:#434f54">TraceIdGenerator&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">ActivityTraceId&lt;/span> &lt;span style="color:#434f54">id&lt;/span> = &lt;span style="color:#434f54">traceIdGenerator&lt;/span> == &lt;span style="color:#00979d">null&lt;/span> ? &lt;span style="color:#434f54">ActivityTraceId&lt;/span>.&lt;span style="color:#434f54">CreateRandom&lt;/span>() : &lt;span style="color:#434f54">traceIdGenerator&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">Unsafe&lt;/span>.&lt;span style="color:#434f54">AsRef&lt;/span>(&lt;span style="color:#728e00">in&lt;/span> &lt;span style="color:#434f54">_context&lt;/span>) = &lt;span style="color:#728e00">new&lt;/span> &lt;span style="color:#434f54">ActivityContext&lt;/span>(&lt;span style="color:#434f54">id&lt;/span>, &lt;span style="color:#728e00">default&lt;/span>, &lt;span style="color:#434f54">ActivityTraceFlags&lt;/span>.&lt;span style="color:#434f54">None&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">return&lt;/span> &lt;span style="color:#434f54">_context&lt;/span>.&lt;span style="color:#434f54">TraceId&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也就是说，访问&lt;code>.TraceId&lt;/code>时，如果它还没有traceid，就生成一个并返回，最终被配置到新创建的Activity中，而Activity的TraceId只能被配置一次，也就是说如果traceid已经存在，后面的&lt;code>activity.SetParentId(requestId)&lt;/code>就不会产生作用。&lt;/p>
&lt;p>所以最终，每个Activity都单独生成了自己的traceid，没有使用进入父级链路。&lt;/p>
&lt;p>查看&lt;code>SetParentId&lt;/code>这个API的文档时，也发现了建议谨慎使用的注释：&lt;/p>
&lt;blockquote>
&lt;p>This is intended to be used only at &amp;lsquo;boundary&amp;rsquo; scenarios where an activity from another process logically started this activity.&lt;/p>
&lt;/blockquote>
&lt;h4 id="为什么单元测试里没有问题">为什么单元测试里没有问题？&lt;/h4>
&lt;p>单元测试里虽然也使用了采样器，但是并没有在采样器中访问&lt;code>TraceId&lt;/code>，所以不会出现上述问题，而在采样器中加入了对&lt;code>TraceId&lt;/code>的访问后，也成功复现了这个bug&lt;/p>
&lt;h4 id="为什么opentelemetry-sdk采集aspnetcore的activities就没有这个问题">为什么OpenTelemetry SDK采集AspNetCore的Activities就没有这个问题？&lt;/h4>
&lt;p>因为OpenTelemetry SDK没有直接采集AspNetCore生成的Activities，而是hook了相关生命周期事件，生成并采集自定义的Activities，如果它直接采集AspNetCore产生的Activities，也会有这个问题，这是AspNetCore代码中的一个缺陷，有一个&lt;a href="https://github.com/dotnet/aspnetcore/issues/37471#issuecomment-972083624">issue&lt;/a>记录了它&lt;/p>
&lt;p>总结和教训：&lt;/p>
&lt;ul>
&lt;li>只有单元测试是不够的，还要进行端到端的测试&lt;/li>
&lt;li>不能盲目信任“权威”代码，它也有bug&lt;/li>
&lt;li>这种明明只是访问一个属性却产生了副作用的做法是不好的，一方面它容易引入错误，另一方面出错后也很难进行相关的debug&lt;/li>
&lt;/ul></description></item><item><title>设计案例：多优先级规则的分布式任务调度</title><link>http://suraciii.github.io/posts/design-job-scheduler/</link><pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/design-job-scheduler/</guid><description>&lt;h2 id="项目背景">项目背景&lt;/h2>
&lt;p>&lt;em>&lt;strong>这个项目我并未全程参与，只是在方案设计遇到问题时参与了讨论，所以文中对于业务场景和需求的描述并不全面，只记录了讨论中获取到的信息&lt;/strong>&lt;/em>&lt;/p>
&lt;p>一个分布式的数据采集应用，其基本功能为采集各个电商平台上的商品信息，具体要求如下：&lt;/p>
&lt;ul>
&lt;li>应用有多个用户，用户可以上传采集任务&lt;/li>
&lt;li>应用能够并行执行多个任务，可以水平伸缩&lt;/li>
&lt;li>采集任务的执行模块和管理模块&lt;strong>分别独立地部署在独立的两个网络环境中&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="初始方案">初始方案&lt;/h2>
&lt;p>在此之上，开发者设计出一个初步的方案：&lt;/p>
&lt;p>由一个任务调度中心（manager）负责接收和管理所有由用户上传的任务，并根据相应的设定，分配各个任务给各个采集器（worker）执行，如图所示：&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/design-job-scheduler/1.png" alt="">&lt;/p>
&lt;p>这样的模式中，有两个特点&lt;/p>
&lt;ul>
&lt;li>应用被分离成manager和worker，manager负责接收和管理任务，worker负责任务的执行&lt;/li>
&lt;li>master中维护了一个任务队列，如果所有worker都在忙碌状态中时，任务可以在队列中进行排队，并以先进先出的方式等待执行&lt;/li>
&lt;/ul>
&lt;h2 id="出现的问题和新的需求">出现的问题和新的需求&lt;/h2>
&lt;p>这个方案有一些问题：&lt;/p>
&lt;ul>
&lt;li>manager作为任务的控制和调度中心，需要知道每个worker的位置，manager需要监控所有worker的地址、状态等，这样才能有效地将任务分配到一个已启动且空闲的节点&lt;/li>
&lt;li>由于worker和manager处于分离的网络空间，manager获得各个worker的地址会非常麻烦，可能需要配置和维护一个worker列表&lt;/li>
&lt;li>由于worker所处的网络环境的特殊性，甚至需要运维部门协助配置端口转发&lt;/li>
&lt;/ul>
&lt;p>而在开发过程中，也出现了新的需求：&lt;/p>
&lt;ul>
&lt;li>worker有不同的分组，专属任务只能被特定分组的worker执行&lt;/li>
&lt;li>特定分组的worker优先执行专属任务，如果没有专属任务，则执行未被分类的普通任务&lt;/li>
&lt;li>用户上传任务时，可以指定某任务优先执行&lt;/li>
&lt;/ul>
&lt;p>这样的需求下，任务的调度决策开始变得复杂，事情开始变得混乱起来&lt;/p>
&lt;p>对于熟悉一些基本数据结构的开发者来说，如果没有全面详细地了解其需求的话，在这里可能容易想到优先队列，在任务入队时指定任务的优先级，优先队列则会按照相应的优先级将任务出队。
但是了解其具体需求后，则会发现优先队列无法解决上面的专属任务问题，甚至对于“上传优先执行任务”这个需求，其真实的数据结构甚至不是一个先进先出的队列，而是后进先出的栈。&lt;/p>
&lt;h2 id="来自线程调度的启发">来自线程调度的启发&lt;/h2>
&lt;p>这个问题和线程池调度有些类似，在许多编程语言的线程池调度中，也有着类似的&amp;quot;worker&amp;quot;，即线程。这里以我最熟悉的.NET线程池调度为例（Java和Rust中也有类似的机制）：&lt;/p>
&lt;p>在.NET线程池中，每个工作线程都有着自己专属的任务队列(local queue)，也有一个全局队列(global queue)，任务在创建时根据需要被放进相应的队列中。工作线程则按照以下规则来获取和执行任务：&lt;/p>
&lt;ol>
&lt;li>首先尝试从本地队列头部获取任务&lt;/li>
&lt;li>如果本地队列为空，则尝试从全局队列头部获取任务&lt;/li>
&lt;li>如果全局队列也为空，则尝试从其它工作线程的本地队列的尾部获取任务&lt;/li>
&lt;li>如果其它工作线程的本地队列也为空，则进入休眠&lt;/li>
&lt;/ol>
&lt;p>这个机制被叫做work-stealing，能够帮助线程池更有效率、更均衡的进行多线程任务调度。它与前面提到的问题有些不同，比如在采集任务调度中，不需要也不可以“偷取”其它worker的任务&lt;/p>
&lt;p>但是总体上，它给了我一些启发：&lt;/p>
&lt;h3 id="1-这里存在着两种优先级一种是队列中的优先级如先进先出另一个是不同队列之间的优先级本地队列--全局队列--其它线程的本地队列">1. 这里存在着两种优先级，一种是队列中的优先级（如先进先出），另一个是不同队列之间的优先级（本地队列 &amp;gt; 全局队列 &amp;gt; 其它线程的本地队列）&lt;/h3>
&lt;p>结合对需求的梳理，可以得出在这个采集任务的调度中这里面大体上存在3个任务通道，分别是：&lt;/p>
&lt;ul>
&lt;li>先进先出的普通任务通道&lt;/li>
&lt;li>先进先出的专属任务通道&lt;/li>
&lt;li>后进先出的优先任务通道&lt;/li>
&lt;/ul>
&lt;h3 id="2-对不同队列优先级决策属于各个工作线程是工作线程在决定自己应该优先从哪个队列中获取任务">2. 对不同队列优先级决策属于各个工作线程，是工作线程在决定自己应该优先从哪个队列中获取任务&lt;/h3>
&lt;p>这里可以看出，将选择任务通道的决策点转移给worker，并结合“竞争消费”的机制后，任务的调度被简化了许多，每个worker只需要按照既定的规则，从各个任务通道中“抢”任务。&lt;/p>
&lt;p>进一步还发现，由于选择任务通道的决策点被转移到了worker中，这使得manager和worker之间的交互方式，由之前的 manager选择任务然后分配给worker，得以变化为 worker选择通道然后从manager中获取任务
这种交互方式下，manager不再需要知道所有节点的物理位置及状况，只需要worker知道manager的位置就可以了&lt;/p>
&lt;p>基于这些启发，给出了新的解决方案：&lt;/p>
&lt;ul>
&lt;li>用户上传的任务，会根据其分类，分别进入普通通道、专属通道或优先通道&lt;/li>
&lt;li>worker以竞争的方式，从manager中获取任务，任务一旦被某worker获取后，不能再被其它worker获取&lt;/li>
&lt;li>worker首先访问优先通道，再访问自己对应分组的专属通道，最后访问全局通道&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://suraciii.github.io/design-job-scheduler/2.png" alt="">&lt;/p>
&lt;p>在和开发者对此方案进行讨论后，确认了其可以较好地满足需求&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>在这个设计方案中，我其实并没有创新出任何一丁点的东西，所有的思路和答案都来自于已存在的案例和设计模式：&lt;br>
除了上面介绍的.NET线程池调度，对于任务调度这个领域，还有很多值得参考的案例，比如一些CI/CD任务的调度，如Azure DevOps、GitLab和GitHub的CI/CD agent，都能提供非常有价值的参考和启发，又比如在Hangfire项目中，其也有着类似的“多通道”任务调度的设计，任务队列的具体实现就可以参考它。
另外这个设计里还使用了一些其它设计模式，比如一开始的manager/worker模式，比如worker获取任务时使用的竞争消费者模式等。&lt;/p>
&lt;p>而这些模式基本也都是从一些项目中学习来的，比如manager/worker是从Azure DevOps Agent中学到的，竞争消费者是从kafka的消费行为中学到的。&lt;/p>
&lt;p>所以平常对于一些产品和工具，除了学习如何使用它们，学习它们的设计和实现原理也十分有价值，在遇到类似的问题时也许就可以用得上。&lt;/p>
&lt;p>&lt;em>&lt;strong>参考：&lt;/strong>&lt;/em>&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Work_stealing">Work stealing (Wikipedia)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler?view=net-6.0#the-default-task-scheduler-and-the-thread-pool">.NET TaskScheduler&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://levelup.gitconnected.com/manager-worker-communication-patterns-c3580b9db5db">Manager-Worker Communication Patterns&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/HangfireIO/Hangfire">Hangfire&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>更有效率地生产更好的应用</title><link>http://suraciii.github.io/posts/build-better-apps/</link><pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/build-better-apps/</guid><description>&lt;p>想象一个产品，比如一辆汽车，它是如何出现，又是如何成为我们在街上见到的那样，而它又结束在何处呢？&lt;/p>
&lt;p>首先，任何产品都不是凭空出现的，它们都是凝结了人类的智慧和劳动，被人们生产出来的，那么，这些产品最开始都是出现在人类的大脑中。&lt;/p>
&lt;blockquote>
&lt;p>蜘蛛的活动与织工的活动相似，蜜蜂建筑蜂房的本领使人间的许多建筑师感到惭愧。但是，最蹩脚的建筑师从一开始就比最灵巧的蜜蜂高明的地方，是他在建筑蜂房以前，已经在自己的头脑中把它建成了。&lt;/p>
&lt;/blockquote>
&lt;p>一开始，我们要思考——这些即将被我们制造出来的汽车，它们满足了哪些人的哪些需要？它们应该是什么形状，它们应该具备哪些功能？对此，我们进行了一些想象和假设，有了一个模糊的蓝图。&lt;br>
接着，我们对生产过程进行规划和分工，我们设计出产品的原型，建设生产线，估计各种零件制造和组装的工时和损耗等，我们规划这些过程并安排相应的任务，追踪进度和问题。&lt;br>
随后，生产线被打造出来，零件被车铣、打磨，组装成型，成为完整的汽车。&lt;br>
我们将这些运输到世界各地，最终交付到了客户手中。&lt;br>
但这还没有结束——如果我们想要业务持续地进行下去并增长地话。&lt;br>
我们要为客户维修故障车辆，我们要聆听客户的抱怨以及他们新的、更深层的需要，我们总结这批汽车的优点和缺陷，我们继续进行新的市场调查和技术研究，然后打造更快，更舒适，更安全的新的汽车。&lt;/p>
&lt;h2 id="应用的生命周期">应用的生命周期&lt;/h2>
&lt;p>类似的，应用的生命周期通常有着如下几个阶段：&lt;/p>
&lt;ol>
&lt;li>计划。在这个阶段，我们收集用户需求，对应用的功能和形态进行假设和描绘，设计产品原型。拆解开发任务，评估任务的开发成本和难度，规划任务的优先级和排期，追踪任务的进度和开发过程中出现的缺陷。&lt;/li>
&lt;li>开发。这个阶段中，我们进行应用的编码和测试等工作，最终生成可部署的制品。&lt;/li>
&lt;li>交付。应用开发完成后，我们要将其部署到生产环境，配置相应的基础设施，如服务器和数据库等，直到用户能够使用到它。&lt;/li>
&lt;li>运维。应用交付后，我们需要对其进行观察和维护，如果它出现了故障，我们需要进行响应处理。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="http://suraciii.github.io/build-better-apps/1.png" alt="">&lt;/p>
&lt;p>而对于绝大多数现代应用来说，无论是web服务还是客户端应用，它们都是需要持续进行迭代和改进的，一个版本上线后，我们总是会不断地收集或者开发到更多的用户需求，我们会不断地识别到其中隐藏着的商业空间和发展潜力，我们会不断地尝试对其调整，以响应市场的变化，也会不断地进行改进，以图拓宽用户群体和商业渠道，或是为了应对来自竞争对手的压力。&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/build-better-apps/2.png" alt="">&lt;/p>
&lt;p>而应用的每一次改进和调整，也都有着上面讲的四个阶段，形成一个迭代周期，这样，应用的生产成为了一个多周期的、持续性的活动。&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/build-better-apps/3.png" alt="">&lt;/p>
&lt;p>在这样的活动中，在不断的改进和调整中，产品的价值不断增长，业务更加成功，而这正是我们所追求的。&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/build-better-apps/4.png" alt="">&lt;/p>
&lt;h2 id="恶性循环和黑天鹅">恶性循环和黑天鹅&lt;/h2>
&lt;p>然而真的有这么乐观吗？来看看现实中的情况吧：&lt;/p>
&lt;ul>
&lt;li>工期评估是否足够&lt;strong>准确&lt;/strong>？计划是否总是被意外打乱？&lt;/li>
&lt;li>新功能需要多久时间才能够完全上线？在这期间出现过多少次&lt;strong>返工&lt;/strong>？&lt;/li>
&lt;li>我们多久可以进行一次&lt;strong>部署&lt;/strong>？部署总是可以顺利进行吗？&lt;/li>
&lt;li>线上产品出现过多少次在开发阶段没有测试出来的&lt;strong>缺陷&lt;/strong>？&lt;/li>
&lt;li>线上产品出现过多少次&lt;strong>服务中断&lt;/strong>？我们花费了多少时间来定位问题？又花了多少时间使其恢复正常？&lt;/li>
&lt;li>花费大量人力和时间投入打造的新功能，是否被客户所接受？是否具备与成本相符合的&lt;strong>价值&lt;/strong>？&lt;/li>
&lt;li>&lt;strong>变更&lt;/strong>是否很可能会导致失败？是否经常会破坏已有的功能？团队是否已经开始恐惧对产品进行变更？&lt;/li>
&lt;li>团队能花费多少力气在新功能的开发交付上？又有多少力气用在了不停地修复不断产生的问题？&lt;/li>
&lt;li>如果我们扩充团队，团队的生产力能随之有效增长吗？&lt;/li>
&lt;/ul>
&lt;p>思考清楚这些问题后，再看：&lt;/p>
&lt;ul>
&lt;li>我们能够对变化莫测的市场及时做出有效的响应吗？&lt;/li>
&lt;li>竞争对手们呢？&lt;/li>
&lt;/ul>
&lt;p>软件开发中存在着一个常见地恶性循环：&lt;/p>
&lt;ol>
&lt;li>新功能的开发总是会难以避免地在代码和基础设施中引入混乱，如果不及时进行干预，这些混乱会使得软件和基础设施变得越来越复杂和脆弱。&lt;/li>
&lt;li>复杂和脆弱的代码及基础设施，导致了更高的开发难度，更高的返工率，以及线上产品更高的故障率，也使得我们的任务和成本预估变得更加不准确。&lt;/li>
&lt;li>我们花费了更多的资源用来调查和修复问题，而新功能的开发又会需要更高的资源投入，为了满足工期要求，我们不得不暂时（我们是这么说服自己的）地去快而脏地处理故障和进行新的开发，从而引入了更多的混乱。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>所有事情都变得更加困难——所有人都越来越忙，工作所消耗的时间越来越多，沟通变得更加缓慢，工作积压得越来越多。我们的工作耦合得更加紧密，即使是很小的行动也会导致较大的事故，我们更加害怕和拒绝做出变更。工作需要更多的沟通、协调和审批；团队必须等待更长的时间，等待相关的工作完成；我们的工作质量持续恶化。车轮开始嘎嘎作响地缓慢移动，要想使之继续转动，就需要付出更多的努力。&lt;/p>
&lt;/blockquote>
&lt;p>最终，黑天鹅出现了：&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/build-better-apps/5.png" alt="">&lt;/p>
&lt;p>也许是一个政策的变更，也许是一次疫情的发生，或者是一个新生的更有活力的竞争对手的崛起，总之，灾难似乎是在慢慢地逼近，又仿佛在一瞬间降临，一个产品迎来了自己的终点。
也许企业会开发出新的应用，会去追求新的商机，团队也会有新的项目，或者有新的东家，但是这个应用的一切都死亡了。&lt;/p>
&lt;p>这个产品结束了，我们失败了。&lt;/p>
&lt;h2 id="改变状况的三个关键">改变状况的三个关键&lt;/h2>
&lt;p>如何避免这样的结局呢？这其中有三个关键点：&lt;/p>
&lt;h3 id="1-缩短交付周期">1. 缩短交付周期：&lt;/h3>
&lt;p>更短的交付周期意味着能够更快更及时更有效地获得来自客户的反馈，这有助于我们发掘客户的真实需要并去实现这些需求。
而更短的交付周期里，我们的交付计划能够做到更为准确，每次交付过程中的风险也会相对较小，出现的问题也更容易处理。
最终，更短的交付周期使得我们能够更迅捷、更频繁、更准确地向客户交付更多的价值。&lt;/p>
&lt;p>从：&lt;br>
&lt;img src="http://suraciii.github.io/build-better-apps/3.png" alt="">&lt;br>
到：&lt;br>
&lt;img src="http://suraciii.github.io/build-better-apps/6.png" alt="">&lt;/p>
&lt;h3 id="2-建立快速高效持续的反馈机制">2. 建立快速、高效、持续的反馈机制：&lt;/h3>
&lt;p>在应用交付的每个阶段里，我们建立快速、高效、持续的反馈机制，缩短问题检测周期，一方面，这可以帮助我们更及时准确地发现问题，从而以更低的成本实现更及时快速的修复，另一方面，也帮助我们打造安全可靠且高质量的应用。&lt;/p>
&lt;h3 id="3-持续学习和持续改善">3. 持续学习和持续改善&lt;/h3>
&lt;p>通过持续地，制度性地学习和改善，提高团队技能水平，将局部的经验快速转化为全局的改进，帮助整个组织尝试和实践新技术，通过科学的方式改进流程和开发产品，从成功和失败中积累经验教训，持续不断地进行改善，从而提高产品质量和生产力。&lt;/p>
&lt;h2 id="一些实践方法和工具">一些实践、方法和工具&lt;/h2>
&lt;p>具体来说，会有多种实践方法和工具来帮助我们做到这些：&lt;/p>
&lt;h3 id="1-持续集成">1. 持续集成&lt;/h3>
&lt;p>频繁持续地将个人的代码变更集成到主干分支，能够避免解决冲突成本过高，bug难以修复，开发者之间代码互相影响或重复相同工作等。
持续集成流水线中的自动化测试能够帮助我们在更早的阶段发现和解决问题，并避免问题在将来被重复引入。
自动化代码质量检查能够持续地帮助我们改善代码质量，减少代码中的混乱和隐患。&lt;/p>
&lt;h3 id="2-持续交付">2. 持续交付&lt;/h3>
&lt;p>通过高效、可靠、自动化的发布流水线，减少应用交付流程中的人工和停滞环节，降低过程中的阻力和风险，从而使应用可以更频繁、轻松地进行发布。&lt;/p>
&lt;h3 id="3-建立应用可观测性">3. 建立应用可观测性&lt;/h3>
&lt;p>为应用建立可观测性，提供完善的日志收集、链路追踪和监控能力，使开发者能够更好的理解应用内部的行为，从而减少应用故障的发现和定位所需要的时间，提高线上可用性。
完善的监控也提供了基于线上应用的反馈回路，能够在故障恶化或产生严重影响之前提前发现，也能够通过对用量指标的收集为应用的后续增强和改善提供信息。&lt;/p>
&lt;h3 id="4-技术债务管理">4. 技术债务管理&lt;/h3>
&lt;p>通过持续性地、组织性地、制度性的对技术债务进行管理，降低应用代码中存在的风险，减少新功能开发时可能导致的额外成本。&lt;/p>
&lt;h3 id="5-代码评审">5. 代码评审&lt;/h3>
&lt;p>通过代码评审，增强业务知识和技术知识在团队成员之间传播，增强团队成员的生产力，减少bug出现的风险，提高代码质量，获得可能的更优解决方案等。&lt;/p>
&lt;h3 id="6-基础设施即代码">6. 基础设施即代码&lt;/h3>
&lt;p>通过以代码形式管理幂等、不可变的基础设施，解决应用发布过程中因环境偏移（如随时间发展各个环境中的配置逐渐变得不同）而导致的各种问题，降低应用交付过程中的阻碍和风险。
同时，基础设施即代码也提高了管理基础设施的可靠性和效率等。&lt;/p>
&lt;h3 id="7-待续">7. 待续&lt;/h3>
&lt;p>&lt;em>引用：&lt;/em>&lt;/p>
&lt;p>&lt;em>1. The DevOps Handbook&lt;/em>&lt;br>
&lt;em>2. &lt;a href="https://azure.microsoft.com/en-us/overview/what-is-devops/">What is DevOps?&lt;/a>&lt;/em>&lt;br>
&lt;em>3. State Of DevOps 2021&lt;/em>&lt;/p></description></item><item><title>解决吞吐性能问题时的思路</title><link>http://suraciii.github.io/posts/throughput-issue-solutions/</link><pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/throughput-issue-solutions/</guid><description>&lt;h2 id="什么是throughput">什么是Throughput&lt;/h2>
&lt;p>Throughput指的是应用处理任务的速率，它所描述的是应用在单位时间内能够处理多大数量的任务&lt;/p>
&lt;p>如下，如果应用能够在1s中处理3个task，我们可以说它的throughput是3tps&lt;/p>
&lt;p>&lt;img src="https://fulu-item11-zjk.oss-cn-zhangjiakou.aliyuncs.com/images/1.png" alt="1">&lt;/p>
&lt;p>值得注意的是，throughput这个指标所代表的是速率，它并不代表同时性（Concurrency），比如图一中的3tps的应用，我们能说它可以在1s中处理3个task，但是并不意味着3个task是同时被处理的，而可能是顺序、线性地被处理&lt;/p>
&lt;p>如果应用可以支持同时处理多个任务，比如应用（系统）中有2个worker，每个worker都可以并行地在1s中内处理3个task，它的throughput则是6tps&lt;/p>
&lt;p>&lt;img src="https://fulu-item11-zjk.oss-cn-zhangjiakou.aliyuncs.com/images/2.png" alt="2">&lt;/p>
&lt;p>如何提高throughput呢？显然可以想到：&lt;/p>
&lt;ol>
&lt;li>缩短每个任务处理的耗时&lt;/li>
&lt;li>让更多的任务可以被同时处理 - 增加并行能力&lt;/li>
&lt;/ol>
&lt;p>下图中的应用（系统）可以支持同时处理3个任务，并且每个任务的处理耗时缩短到一半，其throughput是18tps&lt;/p>
&lt;p>&lt;img src="https://fulu-item11-zjk.oss-cn-zhangjiakou.aliyuncs.com/images/3.png" alt="3">&lt;/p>
&lt;p>##并行中的共享资源和锁&lt;/p>
&lt;p>如果对任务的处理需要访问/修改共享资源呢？比如在扣减库存的任务中，每个任务都需要去访问（校验）当前库存余量，并且要修改（扣减）它&lt;/p>
&lt;p>对共享资源的并发访问和修改会产生冲突和一致性问题，比如有两个扣减库存的任务正在同时进行，此时库存余量为1，两个任务都从存储中拿到了当前的库存余量，当其中一个任务完成后，库存余量被扣减为0，此时另一个任务已经完成了校验过程，再去扣减库存的时候，库存余量就被更新成了-1&lt;/p>
&lt;p>我们通常使用锁来解决对共享资源的争用所导致的并发冲突与一致性问题，使用资源锁来隔离对资源的操作，保证数据的一致性（正确性）&lt;/p>
&lt;p>&lt;img src="https://fulu-item11-zjk.oss-cn-zhangjiakou.aliyuncs.com/images/4.png" alt="4">&lt;/p>
&lt;p>如图，在试图使用某个资源之前，先获取锁从而占用住这个资源，隔离掉其它任务对此资源的访问/修改，从而在占用时间里保证资源的一致性，再使用结束后则释放锁，使资源可以被其它任务访问&lt;/p>
&lt;p>为了避免并发冲突以及获取一致性，并非一定要通过锁，也会有其它的方法（比如原子操作），但是总体上还是在对资源的访问/修改制造隔离&lt;/p>
&lt;p>隔离的后果是什么呢？&lt;/p>
&lt;h3 id="锁共享资源的争用和等待">锁（共享资源）的争用和等待&lt;/h3>
&lt;p>&lt;img src="https://fulu-item11-zjk.oss-cn-zhangjiakou.aliyuncs.com/images/5.png" alt="5">&lt;/p>
&lt;p>争用会导致wait time&lt;/p>
&lt;p>也因为我们对资源的访问/修改进行了隔离，导致了多个任务的处理无法同时使用共享资源，每个任务都要等待其它任务对资源的占用结束后才可以继续进行处理，这个等待就会产生wait time&lt;/p>
&lt;p>这些wait time意味着：&lt;/p>
&lt;ol>
&lt;li>任务的处理时间被延长 - 体现为latency&lt;/li>
&lt;li>并行的任务越多，wait time越长 - 破坏了并行处理任务的能力&lt;/li>
&lt;/ol>
&lt;h4 id="降低锁的成本">降低锁的成本&lt;/h4>
&lt;h5 id="降低使用锁的费用">降低使用锁的费用&lt;/h5>
&lt;p>锁的创建、获取、释放和销毁都是有代价的，降低使用锁本身的费用，比如把数据库锁换成redis锁，甚至换成本地内存锁&lt;/p>
&lt;p>以减库存为例： 提前把库存放到redis里，从redis中扣减&lt;/p>
&lt;h5 id="降低锁的占用时间">降低锁的占用时间&lt;/h5>
&lt;p>在获取到资源锁之后，应该尽快地释放它，尽量不要在占用锁的期间里做比较花费时间的事情，比如：1）发送HTTP请求 2）执行昂贵的SQL语句 3）超时等待 等等&lt;/p>
&lt;p>但是它有局限，如果我们尝试增加任务的并行数，wait time就会继续随之增长&lt;/p>
&lt;p>&lt;img src="https://fulu-item11-zjk.oss-cn-zhangjiakou.aliyuncs.com/images/6.png" alt="6">
&lt;img src="https://fulu-item11-zjk.oss-cn-zhangjiakou.aliyuncs.com/images/6-1.png" alt="6-1">&lt;/p>
&lt;h4 id="使用更细粒度的锁共享资源">使用更细粒度的锁（共享资源）&lt;/h4>
&lt;p>通过尽量使用更细粒度的锁（共享资源），可以使锁争用（碰撞）的概率更低，出现等待的情况也就更少&lt;/p>
&lt;p>&lt;img src="https://fulu-item11-zjk.oss-cn-zhangjiakou.aliyuncs.com/images/7.png" alt="7">&lt;/p>
&lt;p>以减库存为例： 把库存分布到多个篮子里，100=10*10，随机或者按策略去某个篮子里扣减，这样原本是所有任务都使用单一的库存余量，现在变成分散地使用10个库存余量，出现等待的概率就会变少&lt;/p>
&lt;p>无论是降低锁成本还是降低锁粒度，其目的都是减少争用的发生，减少任务的wait time，从而可以提高对多任务的并行处理能力&lt;/p>
&lt;h3 id="缓冲请求合并任务批量处理buffer-merge-process">缓冲请求，合并任务，批量处理（Buffer-Merge-Process）&lt;/h3>
&lt;p>&lt;img src="https://fulu-item11-zjk.oss-cn-zhangjiakou.aliyuncs.com/images/8.png" alt="8">&lt;/p>
&lt;p>以减库存为例：&lt;/p>
&lt;ol>
&lt;li>把减库存请求丢进队列中&lt;/li>
&lt;li>每次从队列中取出多个减库存请求，合并成一个减库存任务&lt;/li>
&lt;li>处理合并后的减库存任务&lt;/li>
&lt;/ol>
&lt;p>这种方式会导致单个任务的耗时增加 - 因为任务不会立即被处理，但是可以增加总体的throughput，某种程度上是用延迟交换了吞吐，需要考虑这个交换是否值得&lt;/p>
&lt;h4 id="总体思路">总体思路&lt;/h4>
&lt;p>1.首先定位争用&lt;/p>
&lt;p>2.减少争用，减少Wait Time&lt;/p>
&lt;p>3.最后才尝试Buffer-Merge-Process&lt;/p>
&lt;p>通常这三个方法都可以尝试，都有着一些成本和副作用，也经常需要结合使用，但是在考虑解决方案时，优先考虑解决锁争用&lt;/p>
&lt;p>共享资源争用是个很糟糕的质量信号，即使在当前看起来它没有产生很严重的后果，但是实际上它有着非常大的隐患&lt;/p>
&lt;p>它会导致应用在性能上变得脆弱：我们可以通过减少锁的费用和占用时间来减少争用从而提高性能，相反的，当锁的费用上升以及占用时间增加时，很容易大量争用导致性能急剧下降，而这时想要解决性能问题很可能要付出非常大的成本 。比如网络环境变化导致使用锁时的延迟增高，又或者一个业务需求或者bugfix需要你在占用锁时执行一个昂贵的sql语句或者http请求，甚至可能只是一个轻微的网络波动，都可能导致应用的吞吐剧烈下降&lt;/p>
&lt;h4 id="资源争用下的scalability问题">资源争用下的Scalability问题&lt;/h4>
&lt;p>当我们在开发应用的时候，对于应用的吞吐性能可以有三种要求：&lt;/p>
&lt;ol>
&lt;li>够用就行，只要能满足当前需求即可&lt;/li>
&lt;li>吞吐性能不仅要够用，还要出色，比如当前业务只需要我们的应用有30tps，但是我们在设计和开发时，要以1000tps的性能质量来要求它&lt;/li>
&lt;li>当前的吞吐性能需要满足当前的业务需求，不要求应用具备过高的吞吐性能，但是要求在将来它可以通过较低的成本来提升到更高的吞吐性能&lt;/li>
&lt;/ol>
&lt;p>第三种要求实际上就是对于应用的scalability的要求，它不要求过高的吞吐性能，但是它需要应用能够快速地响应业务需求对于吞吐性能要求的提升&lt;/p>
&lt;p>即当外部环境变化时 - 比如业务规模的增长，比如一个重要的feature带来了性能的降低，比如云迁移导致了应用运行环境发生了变化，这时我们需要能够通过调配资源能够简单快速的提升应用的吞吐性能来适应新的需求，先快速地做到&amp;quot;Doing more&amp;quot;，然后再去&amp;quot;With less&amp;quot;&lt;/p></description></item><item><title>愚钝程序员的生存之道 - Part0: 复杂性</title><link>http://suraciii.github.io/posts/how-to-survive-as-an-01x-developer-0/</link><pubDate>Wed, 22 Apr 2020 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/how-to-survive-as-an-01x-developer-0/</guid><description>&lt;p>工作几年，我发现自己身上有着一些现象：&lt;/p>
&lt;p>别人讲给我的东西要讲很多遍我才能理解&lt;/p>
&lt;p>学习技术要花很多时间才能掌握&lt;/p>
&lt;p>写代码平均每写十几行就会引入一个错误&lt;/p>
&lt;p>…&lt;/p>
&lt;p>这些现象似乎都指向着一个现实——我是一个愚钝的程序员。&lt;/p>
&lt;p>作为一个愚钝的程序员，想要产出平均水平的质量和产量从而生存下去，又不想被无尽的加班和焦头烂额吞噬自己的生活，就不得不掌握一些属于愚钝程序员的生存之道，从而可以不用很辛苦很累也可以交付出高质量的软件。&lt;/p>
&lt;h2 id="从复杂到复杂性">从复杂到复杂性&lt;/h2>
&lt;p>愚钝程序员在开发活动中总是面临诸多的挑战，这些挑战让愚钝程序员们感到自己愚钝，当我：&lt;/p>
&lt;ul>
&lt;li>总是难以搞明白一些代码是如何工作的&lt;/li>
&lt;li>总是需要花费很长时间来实现一个很小的改进&lt;/li>
&lt;li>或者总是不清楚自己应该去修改代码的哪些地方来实现这些改进&lt;/li>
&lt;li>总是难以快速修复一个bug&lt;/li>
&lt;li>或者总是难以在修复一个bug的同时而不引入另一个bug&lt;/li>
&lt;/ul>
&lt;p>当这一系列的状况发生，让我感觉自己无能为力去轻松解决问题，让我感觉自己难以处理，无从下手，让我怀疑自己是否不适合这个行业的时候，我发出了抱怨：&lt;/p>
&lt;p>——“这太复杂(Complex/Complicated)了！”&lt;/p>
&lt;h3 id="区分complex和complicated">区分Complex和Complicated&lt;/h3>
&lt;p>Complex与Complicated，二者所描述的对象都是是由存在大量互相交互的元素构成的系统，但是二者有着一些细微的不同之处：&lt;/p>
&lt;p>对于Complicated系统，它有着确定性(deterministic)，尽管系统中所有的组件都在发生交互，都在影响着系统的状态，但是这种交互是确定的，可测的，可靠的，并且系统被影响后的状态也是有限的、有界的&lt;/p>
&lt;p>而对于Complex系统，组件的交互以及对系统的影响是不确定的，系统的可能状态也是无限的、无界的&lt;/p>
&lt;p>对于Complex与Complicated，目前我还没有见到一个准确而又权威的定义，有时这两个词汇在不同领域甚至会被用来表达截然相反的两个概念，但是为了方便交流，在这里我们引用了上面这种定义，并且利用一个说法来帮助我们更清晰地识别Complex：&lt;/p>
&lt;p>&lt;em>Complex更偏向于将对象系统作为待解决的问题描述，即当我们使用Complex来描述一个系统时，Complex其实是在描述其投射在我们的大脑中的问题，那个我们正在尝试解决，并且无法轻松地理解处理的问题&lt;/em>&lt;/p>
&lt;h3 id="复杂性">复杂性&lt;/h3>
&lt;p>我们将复杂问题中那些标志其成为复杂问题的要素称作复杂性(Complexity) - 问题系统之所以复杂，正是因为其表现出了复杂性&lt;/p>
&lt;p>结合前面的分析，我们可以说：我们解决问题时所面对的复杂性，成为了我们对复杂问题的开发处理难度&lt;/p>
&lt;p>也就是说，当我们感觉问题杂乱、庞大，难以理解和处理的时候，我们大概是撞上了问题的复杂性&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/how-to-survive-as-an-01x-developer-0/1.png" alt="1">&lt;/p>
&lt;h2 id="管理复杂性">管理复杂性&lt;/h2>
&lt;h3 id="撞上复杂性">撞上复杂性&lt;/h3>
&lt;p>面对复杂性，我们通常会有这几种反应：&lt;/p>
&lt;ol>
&lt;li>无视它，我们欺骗自己，假装复杂性并不存在。这种反应体现在我们会对系统做出一些假设，来忽略复杂性，一个经典的例子就是&lt;a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing">Fallacies of distributed computing&lt;/a>，分布式系统中的网络通讯是极其常见的复杂性的来源，但是许多时候我们都会去假设网络是可靠安全稳定的&lt;/li>
&lt;li>通过启发探索(heuristic)，即调查(Probe)-感知(Sense)-响应(Respond)，这种方式也可以说是通过本能去应对——我们一步步地试探着前进，运气好的话也许可以积累一些有用经验形成本能来加速这个过程&lt;/li>
&lt;/ol>
&lt;p>在大多数情况下，人们面对复杂性时的反应都会是这两种，本质上这两种应对方式都是被动地应对，对于第一种我们可以略过不提，而第二种反应——愚钝的程序员在这条路上无法走得更远&lt;/p>
&lt;p>如果我们把一个复杂问题比作一个大泡泡，里面充满了复杂性，那么我们通过启发探索应对复杂性，就是去对问题进行探索和开发，由于学习理解能力、记忆力以及经验的差距，对于那些自身具备优秀的先天条件（学习理解能力、记忆力等）聪慧的程序员(Rockstar developer)，和那些在特定项目或特定领域上浸淫已久获得了丰富经验的地头蛇来说，这不是个很辛苦的过程，但是对于愚钝程序员来说，这里是个不公平的竞技场，一些对于愚钝程序员来说很复杂的问题，对于这些人来说却相对简单&lt;/p>
&lt;p>所以面对复杂性，愚钝的程序员要多考虑第三种应对方式&lt;/p>
&lt;h3 id="抓住复杂性的缰绳">抓住复杂性的缰绳&lt;/h3>
&lt;p>相比于被动地用本能去应对复杂性，作为人类的我们，更应该主动地去认识，识别，分析，从而有效地管理它&lt;/p>
&lt;h4 id="复杂性的来源">复杂性的来源&lt;/h4>
&lt;p>想要管理复杂性，首先就要知道在软件开发的活动中，我们所面对的复杂性&lt;strong>来源&lt;/strong>是哪里&lt;/p>
&lt;p>首先是来自现实世界的复杂性——我们开发软件是为了解决现实世界的问题，所以软件的开发必然会引入现实世界的复杂性（一些情况下我们会把它们称做“需求”）&lt;/p>
&lt;p>来自现实世界的复杂性是必要的复杂性，大多是作为开发者的我们无法控制的——经济危机可能导致公司的业务方向发生变化，孩子气的用户总是以我们预想不到的方式使用软件，GDPR，英国脱欧……这些都是我们无法改变又不可抗拒的，因为现实世界就是这么运作的&lt;/p>
&lt;p>但是作为开发者，除了来自现实世界的复杂性，我们还要面对软件本身的复杂性——随意懒散的建模，混乱的架构设计、千奇百怪的工具和框架、分布式系统的一致性问题甚至迥异的代码风格，都是开发者需要面对的&lt;/p>
&lt;p>这两种复杂性并不总是泾渭分明，通常，开发者沟通着现实世界与软件，接收来自现实的复杂性，混合进自己的理解，又通过代码输入到解决方案之中，最终又成为开发者自己需要面对的问题&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/how-to-survive-as-an-01x-developer-0/2.png" alt="2">&lt;/p>
&lt;p>现实世界是必要的复杂，但是我们软件不必复杂，软件系统也许甚至经常会是complicated，但是不必complex。&lt;strong>软件是来自开发者的极其自由的创作&lt;/strong>，我们将数百万离散的元素聚合到一起，生成新的东西，它没有来自现实世界的诸多干扰和限制，我们无法通过Pull Request来改变现实世界的物理规律，但是我们可以任意去改变我们的软件，因此我们的软件的复杂性在大多数情况下都是可以控制的&lt;/p>
&lt;h3 id="发现复杂性">发现复杂性&lt;/h3>
&lt;p>我们无法和看不见的敌人战斗&lt;/p>
&lt;p>前面提到过当我们觉得问题难以理解，难以处理的时候，说明我们很有可能正在面对问题的复杂性，那么更具体一些，软件的复杂性会以怎样的形式体现呢？&lt;/p>
&lt;p>尽管软件系统的复杂性会表现为开发者的开发难度，但是具体地来讲，软件的复杂性会体现为三种形式&lt;/p>
&lt;h4 id="1-改动扩散change-amplification">1. 改动扩散(Change amplification)&lt;/h4>
&lt;p>改动扩散是指一个看起来很简单的改动，却需要对软件的多个不同的地方进行代码修改，这种修改被我们称为散弹式修改，它不仅仅意味着劳动量的增加，它所导致的更严重的问题在于，如果一个开发者想要进行这个改动，他就必须要清楚地知道所有需要修改的地方，并且还要清楚地知道这些地方都应该怎么修改，一旦开发者缺乏这些需要的信息和知识，或者是没有充分地理解它们，就极易引入错误&lt;/p>
&lt;h4 id="2-认知负担cognitive-load">2. 认知负担(Cognitive load)&lt;/h4>
&lt;p>认知负担是指开发者为了完成一个任务，需要了解多少东西，更高的认知负担意味着开发者们需要花费更多的时间去学习所需要的信息，并且有更高的因为缺乏信息导致的错误风险。&lt;/p>
&lt;p>可以看到改动扩散会导致某种程度上的认知负担（当然，认知负担不总是来源于改动扩散，而是一切可能导致开发者们理解困难的东西）&lt;/p>
&lt;h4 id="3-未知的无知unknown-unknown">3. 未知的无知(Unknown unknown)&lt;/h4>
&lt;p>未知的无知（我不确定我有没有翻译好）是指在你想要完成一个任务时，根本不知道应该去修改那些代码，根本不知道你该具备哪些信息，它意味着你有一些需要了解学习的信息，但是你在开发时根本无法发现它们是什么，甚至你根本没有发现你需要了解学习这些，直到之后有bug出现，你才能以回顾的方式发现它们&lt;/p>
&lt;p>未知的无知是最糟糕的，它是那些我们无法利用启发探索去到达的地方，而我们却只能以启发探索的方式应对它——因为我们根本不知道它的存在&lt;/p>
&lt;p>这是复杂性会体现为的三种形式，我们也可以将这三种形式作为复杂性的信号对待——当它们出现时，我们就要警惕了&lt;/p>
&lt;p>而观察这三种形式，可以明显地看到，它们的本质都是体现为开发者信息的匮乏，收集学习必要的信息会拖慢我们的开发，遗漏必要的信息会导致错误风险的增高&lt;/p>
&lt;h3 id="未知和不确定性">未知和不确定性&lt;/h3>
&lt;p>这些信息匮乏的现象是如何产生的呢？原因总体上来自于我们对软件系统的未知和其本身的不确定性&lt;/p>
&lt;p>软件系统的不确定性，导致了我们开发软件时所需要了解的信息爆炸，我们需要处理的状况也会增加，而我们对软件系统的未知，在导致我们需要收集额外信息的同时，也容易使我们在开发软件时做出错误的假设——可以说这是一种因无知而产生的傲慢&lt;/p>
&lt;p>&lt;img src="http://suraciii.github.io/how-to-survive-as-an-01x-developer-0/3.png" alt="3">&lt;/p>
&lt;p>所以，管理软件系统复杂性的基本方向，就是通过一系列的手段减少开发时的未知，捕获其中的不确定性，最终&lt;strong>打破迷雾&lt;/strong>，让复杂的问题在我们看来变得一目了然（Obvious）&lt;/p>
&lt;h2 id="关于这篇分享">关于这篇分享&lt;/h2>
&lt;ul>
&lt;li>这篇分享里的想法最初来自于对朋友抛出的一个问题“为什么我们要避免循环依赖”的持续发散的思考，结合了一些知识的阅读学习，对一些现象的观察，以及一些从实践中总结的规律，到现在对于这个问题总算是能够给出一个能够说服我自己的答案了&lt;/li>
&lt;li>当然，观点来自于理解，理解来自于经验，由于每个人的经历不同，很可能每个人的观点和理解也都有所不同，我也无法确定自己的理解是否是足够客观的，普适的，是能够通过正确认识问题从而解决问题的，所以非常希望大家都能分享自己的理解，我也能够通过和大家的交流，有进一步的理解，从而可以不断修正和完善自己的结论&lt;/li>
&lt;li>这篇是一系列相关分享的第一篇，计划是分享一系列我认为可以提高交付效率和质量，简化开发负担的工具和方法，但是因为这些分享是建立在我对软件开发和其复杂性的理解上的，所以这篇作为第一篇，说一下我的思路，为什么会这么想，后续（如果不鸽的话），我会分享一些更为具体的，可操作的工具和方法&lt;/li>
&lt;/ul>
&lt;h4 id="管理复杂性需要团队合作">管理复杂性需要团队合作&lt;/h4>
&lt;p>复杂性是由所有的开发者每人每个提交一点一滴的积累起来的——每个人都容易说服自己引入一点点的复杂性不是什么大事，但复杂性持续地在积累中增殖，最终成为软件灾难（&lt;a href="https://en.wikipedia.org/wiki/Big_ball_of_mud">大泥球&lt;/a>）&lt;/p>
&lt;p>&lt;strong>软件发展为复杂软件（大泥球）是团队合作的产物，所以也需要团队的力量才能真正解决它&lt;/strong>&lt;/p>
&lt;h4 id="软件复杂性不只是开发者的敌人">软件复杂性不只是开发者的敌人&lt;/h4>
&lt;p>尽管软件的高复杂性会加重开发者们的负担，但是它不止对开发者们造成伤害，对于项目本身，软件复杂性也是非常危险的，它会拖慢软件的交付效率，降低软件的交付质量，&lt;strong>失控的软件复杂性是项目过于脆弱的体现&lt;/strong>，持续下去会越来越无法承受挑战的冲击
&lt;em>如果要讨论这个问题，那对象系统就不是软件本身而是整个工程项目了，所以不在此进行深入分析&lt;/em>&lt;/p>
&lt;h5 id="参考">&lt;em>参考&lt;/em>：&lt;/h5>
&lt;ol>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=pMfzxmCzThI">Antifragile Designing the Systems of the Future - Barry O&amp;rsquo;Reilly - DDD Europe 2019&lt;/a>&lt;/li>
&lt;li>Cynefin framework &lt;a href="https://en.wikipedia.org/wiki/Cynefin_framework">https://en.wikipedia.org/wiki/Cynefin_framework&lt;/a>&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://www.infoq.com/articles/software-is-synthetic">The Fundamental Truth behind Successful Development Practices: Software is Synthetic&lt;/a>&lt;/strong>
- 非常好的一篇文章，讲清楚了“当我们在开发软件时，我们究竟在做什么”&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://www.goodreads.com/en/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design&lt;/a>&lt;/strong>
- 这个分享中有很大一部分内容都是参考的这本书，我还没看完，但是就现在的体会而言，非常值得一看&lt;/li>
&lt;/ol></description></item><item><title>高并发下的高频账号余额加减方案探索</title><link>http://suraciii.github.io/posts/hot-spot-balance-reduce/</link><pubDate>Thu, 07 Mar 2019 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/hot-spot-balance-reduce/</guid><description>&lt;h2 id="问题描述">问题描述&lt;/h2>
&lt;p>打造一个服务，管理用户余额（信用点、积分、代币等），实现主要功能：&lt;/p>
&lt;ul>
&lt;li>加减款：即对余额进行增减&lt;/li>
&lt;li>冻结流程：减用户余额 加用户的冻结余额，同时生成一条冻结记录&lt;/li>
&lt;li>付款流程：减付款用户的冻结余额，加收款商户（可能为多个）的余额&lt;/li>
&lt;li>余额流水：余额的每笔变动都会产生相应流水明细&lt;/li>
&lt;/ul>
&lt;p>同时 还有以下特征：&lt;/p>
&lt;ul>
&lt;li>高并发&lt;/li>
&lt;li>多数用户均为高频账号&lt;/li>
&lt;li>强一致性&lt;/li>
&lt;/ul>
&lt;h2 id="代码层面事务与锁">代码层面：事务与锁&lt;/h2>
&lt;p>问题中存在的若干规则&lt;/p>
&lt;ul>
&lt;li>冻结与减款（减用户余额）时，校验减后余额&lt;/li>
&lt;li>付款（减用户冻结余额）时，校验减后冻结余额&lt;/li>
&lt;li>冻结时，更新余额、更新冻结余额、生成冻结记录&lt;/li>
&lt;li>付款时，各账号加减余额、冻结余额、解冻、生成付款记录&lt;/li>
&lt;/ul>
&lt;h3 id="锁的优化">锁的优化&lt;/h3>
&lt;p>总体来看，需要加锁的地方有：1)更新余额 2)解冻(更改冻结状态)&lt;/p>
&lt;p>主要拿更新余额来说，最直观的流程：&lt;/p>
&lt;ul>
&lt;li>加锁查询余额&lt;/li>
&lt;li>检查余额&lt;/li>
&lt;li>更新余额&lt;/li>
&lt;/ul>
&lt;p>即&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">SELECT&lt;/span> &lt;span style="color:#728e00">*&lt;/span> &lt;span style="color:#728e00">FROM&lt;/span> &lt;span style="color:#728e00">`&lt;/span>&lt;span style="color:#434f54">Accounts&lt;/span>&lt;span style="color:#728e00">`&lt;/span> &lt;span style="color:#728e00">WHERE&lt;/span> &lt;span style="color:#728e00">`&lt;/span>&lt;span style="color:#434f54">Id&lt;/span>&lt;span style="color:#728e00">`=@&lt;/span>&lt;span style="color:#434f54">Id&lt;/span> &lt;span style="color:#728e00">FOR&lt;/span> &lt;span style="color:#728e00">UPDATE&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">/* 检查余额 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">Update&lt;/span> &lt;span style="color:#728e00">`&lt;/span>&lt;span style="color:#434f54">Accounts&lt;/span>&lt;span style="color:#728e00">`&lt;/span> &lt;span style="color:#728e00">SET&lt;/span> &lt;span style="color:#728e00">`&lt;/span>&lt;span style="color:#434f54">Balance&lt;/span>&lt;span style="color:#728e00">`=@&lt;/span>&lt;span style="color:#434f54">Balance&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于“多数用户均为高频账号”，在高频校验更新余额时势必会产生性能问题，而在某些特殊场景下，甚至会产生死锁的问题&lt;/p>
&lt;p>那么这里的主要思路就是减少降低锁的使用频率：&lt;/p>
&lt;h4 id="a-只在减款校验时加锁">a) 只在减款校验时加锁&lt;/h4>
&lt;p>余额的更新中，只有减款时需要校验当前实时余额，而加款则不需要&lt;/p>
&lt;p>减款时流程不变，加款时直接对余额进行加操作&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">Update&lt;/span> &lt;span style="color:#728e00">`&lt;/span>&lt;span style="color:#434f54">Accounts&lt;/span>&lt;span style="color:#728e00">`&lt;/span> &lt;span style="color:#728e00">SET&lt;/span> &lt;span style="color:#728e00">`&lt;/span>&lt;span style="color:#434f54">Balance&lt;/span>&lt;span style="color:#728e00">`=@&lt;/span>&lt;span style="color:#434f54">Balance&lt;/span>&lt;span style="color:#728e00">+@&lt;/span>&lt;span style="color:#434f54">Amount&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="b-先减款再校验">b) 先减款，再校验&lt;/h4>
&lt;p>加款操作去掉了锁，减款是否也能去掉呢？
我们在减款中加锁，是为了避免在减款操作时余额被并发更改，出现校验时账号有充足的余额，但是减款时余额却变成了负数
如果我们按照之前的流程 加锁-查询-更新，的确是需要锁住这一行记录，但是如果先减款，再判断余额是否小于0，就可以避免锁的需求&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">Update&lt;/span> &lt;span style="color:#728e00">`&lt;/span>&lt;span style="color:#434f54">Accounts&lt;/span>&lt;span style="color:#728e00">`&lt;/span> &lt;span style="color:#728e00">SET&lt;/span> &lt;span style="color:#728e00">`&lt;/span>&lt;span style="color:#434f54">Balance&lt;/span>&lt;span style="color:#728e00">`=@&lt;/span>&lt;span style="color:#434f54">Balance&lt;/span>&lt;span style="color:#728e00">-@&lt;/span>&lt;span style="color:#434f54">Amount&lt;/span> &lt;span style="color:#434f54">RETURNING&lt;/span> &lt;span style="color:#728e00">`&lt;/span>&lt;span style="color:#434f54">Balance&lt;/span>&lt;span style="color:#728e00">`&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">/* 判断Balance是否小于0，如果小于0，则回滚事务 */&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样在减款操作时也避免了显式锁行&lt;/p>
&lt;p>解冻校验也可以用类似方法，比如将冻结记录的校验与更新，使用&lt;code>WHERE&lt;/code>语句合成一条SQL语句，来避免锁的使用&lt;/p>
&lt;h3 id="尝试摆脱数据库事务">尝试摆脱数据库事务&lt;/h3>
&lt;p>上一步里去除了更新余额时的显式行锁，但是对于高频账号来说，数据库事务自带的锁/隔离机制仍然会是其并发性能的一大阻碍
但是在需要多个写（更新、插入）操作同时成功同时回滚的场景下，数据库的强一致性事务似乎又是不可或缺的&lt;/p>
&lt;p>那么可以换一种思路：
只要保证所有操作&lt;em>最终&lt;/em>一定会成功，那么是否就可以去除对数据库事务的依赖了呢？&lt;/p>
&lt;p>看上面几个流程
首先单纯的加减款肯定是可以不依赖数据库事务的，那么就是冻结、付款等需要多次写操作的场景
比如冻结场景，要么 1.减款成功，生成冻结 2.减款失败，不生成冻结
减款失败的情况不需要担心，但是如果减款成功的情况下，需要保证一定有对应的一条冻结记录插入&lt;/p>
&lt;p>如何保证？
可以在生成冻结失败时，重试此操作，直到最终生成成功为止
但是我们可能不止需要重试冻结失败的操作，在程序异常中止然后重启后，有些情况下我们无从得知上次异常中止的流程中，是否已经进行了减款操作，失去了数据库事务两阶段提交(2PC)支持，我们只能重试整个冻结流程，即1.减款成功，生成冻结&lt;/p>
&lt;p>这里就有很严重一个问题，此时减款操作的重试是不安全的，每次减款，都是更新账号上的余额字段，这就需要一个幂等机制，来让减款可以安全地重试&lt;/p>
&lt;h4 id="eventsourcing">EventSourcing&lt;/h4>
&lt;p>如果了解&lt;a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing">EventSourcing&lt;/a>的话，接下来的事情就顺理成章了&lt;/p>
&lt;p>还记得需求中关于流水明细的部分吗？&lt;/p>
&lt;p>参考EventSourcing的实现，可以把每次的余额更新操作，都转换成相关的流水明细的插入操作，而插入操作是很容易实现幂等的，同时，大多数情况下，插入记录的性能要比更新记录的性能要好&lt;/p>
&lt;p>实现非常简单，即在进行加减款操作时，不更新数据库中的余额字段，而是向数据库中插入一条变动记录，如账号XXX余额减10
如何进行减款前的校验呢？我们可以预先把某账号的流水记录预先读取出来，然后将此账号的余额按照流水记录走过一遍，就在内存中得到了当前的余额，同时在插入变动记录时，同时更新内存中的余额值，当然，要保证内存中的余额变动和流水中一致&lt;/p>
&lt;h5 id="分布式">分布式？&lt;/h5>
&lt;p>前面说过，要保证内存中的余额和数据库中的流水记录一致，如果是单实例的应用，很简单，只需要创造一个单例的账号对象，并保证其余额不会被并发更新就好了，但是如果是分布式的应用怎么办？&lt;/p>
&lt;p>如何在分布式系统中避免并发冲突？和许多分布式EventSourcing框架一样，此时，Actor是唯一解决方案。Actor模型提供了&lt;em>针对每个Actor(账号)的单线程执行约束&lt;/em>，也就是说，每个账号作为Actor存在于集群中时，其代码执行是不会有并发冲突的&lt;/p>
&lt;h5 id="看起来很完美">看起来很完美？&lt;/h5>
&lt;p>实际上不是，无论是EventSourcing还是Actor模型，都不是常规的编程思想，其实现无疑会比较复杂，并且在分布式环境中，对其不够熟悉的话，很容易踩入各种各样的并发陷阱 - 当然这些陷阱在常规分布式应用中也是普遍存在的，但是在这里更容易令人疏忽大意&lt;/p>
&lt;p>并且，Actor的&lt;em>单线程执行约束&lt;/em>，本身也是并发性能的一个阻碍&lt;/p>
&lt;h2 id="高频账号问题">高频账号问题&lt;/h2>
&lt;p>在代码层面提高高频账号或者单点账号的单操作性能，从而提高其并发性能，但是在这条路上想走得更远是十分困难的。
或许可以以一个更大的视角来尝试解决&lt;/p>
&lt;p>高频账号问题，本质上其实相当类似秒杀/减库存问题
所以很大程度上，可以借用秒杀/减库存问题的解决方案&lt;/p>
&lt;h3 id="拆分高频账号">拆分高频账号&lt;/h3>
&lt;p>一个思路是将高频账号拆分为多个子账号（资金池），加减款时随机找一个子账号扣款
但是和秒杀/减库存不同，在资金的加减上，拆分子账号会引入许多问题：&lt;/p>
&lt;ol>
&lt;li>如何调度平衡各个子账号之间的资金？&lt;/li>
&lt;li>流水无法记录变动前后的总余额&lt;/li>
&lt;li>扣款时如果一个子账号的余额不够，需要扣多个子账号怎么办？&lt;/li>
&lt;/ol>
&lt;p>想到这里，除非整个业务体系能改造，我已经基本放弃此方案了&lt;/p>
&lt;h3 id="批量提交与异步">批量提交与异步&lt;/h3>
&lt;p>批量提交与异步，是提高单点吞吐量的绝佳法宝，比如很多数据库都有通过批量commit事务来提高吞吐量&lt;/p>
&lt;p>回到问题本身，资金的变动分为a)加款 b)减款&lt;/p>
&lt;p>对于加款，它属于必定会成功的操作，可以直接把它丢进一个&lt;em>可靠的&lt;/em>队列里去执行
出队时，缓冲若干个加款命令，合并成一个批量提交&lt;/p>
&lt;p>而减款是有可能会失败的（余额不足），我们需要一个手段把减款的结果通知给请求方&lt;/p>
&lt;p>如果请求是同步的（如HTTP请求），我们只能挂起相应的HTTP请求，等到扣款有结果了再唤醒，返回响应，但是这种在分布式系统中实现起来会非常麻烦
相反，如果能够将接口改造成为异步的话，实现起来就比较简单了&lt;/p>
&lt;ol>
&lt;li>接到扣款请求&lt;/li>
&lt;li>将请求添加进队列，并直接返回响应，表示已收到请求&lt;/li>
&lt;li>请求方主动查询请求结果，或处理方回调通知结果&lt;/li>
&lt;/ol>
&lt;p>这种实现并不怎么合适，因为有时上游调用方需要根据调用的结果来决定下一步的流程，比如冻结成功后才能发起付款，如果失败则需要告知用户/管理员等
所以也许使用一个异步的事件系统来控制整个业务流程会比较合适
但是这就是后话了&lt;/p></description></item><item><title>为Kubernetes集群添加用户</title><link>http://suraciii.github.io/posts/add-user-for-k8s/</link><pubDate>Wed, 29 Aug 2018 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/add-user-for-k8s/</guid><description>&lt;h2 id="kubernetes中的用户">Kubernetes中的用户&lt;/h2>
&lt;p>K8S中有两种用户(User)——服务账号(ServiceAccount)和普通意义上的用户(User)&lt;br>
ServiceAccount是由K8S管理的，而User通常是在外部管理，K8S不存储用户列表——也就是说，添加/编辑/删除用户都是在外部进行，无需与K8S API交互，虽然K8S并不管理用户，但是在K8S接收API请求时，是可以认知到发出请求的用户的，实际上，所有对K8S的API请求都需要绑定身份信息(User或者ServiceAccount)，这意味着，可以为User配置K8S集群中的请求权限&lt;/p>
&lt;h3 id="有什么区别">有什么区别？&lt;/h3>
&lt;p>最主要的区别上面已经说过了，即ServiceAccount是K8S内部资源，而User是独立于K8S之外的。从它们的本质可以看出：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>User通常是人来使用，而ServiceAccount是某个服务/资源/程序使用的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>User独立在K8S之外，也就是说User是可以作用于全局的，在任何命名空间都可被认知，并且需要在全局唯一&lt;br>
而ServiceAccount作为K8S内部的某种资源，是存在于某个命名空间之中的，在不同命名空间中的同名ServiceAccount被认为是不同的资源&lt;/p>
&lt;/li>
&lt;li>
&lt;p>K8S不会管理User，所以User的创建/编辑/注销等，需要依赖外部的管理机制，K8S所能认知的只有一个用户名
ServiceAccount是由K8S管理的，创建等操作，都通过K8S完成&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这里说的添加用户指的是普通意义上的用户，即存在于集群外的用户，为k8s的使用者。&lt;br>
实际上叫做添加用户也不准确，用户早已存在，这里所做的只是使K8S能够识别此用户，并且控制此用户在集群内的权限&lt;/p>
&lt;h2 id="用户验证">用户验证&lt;/h2>
&lt;p>尽管K8S认知用户靠的只是用户的名字，但是只需要一个名字就能请求K8S的API显然是不合理的，所以依然需要验证此用户的身份
在K8S中，有以下几种验证方式：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>X509客户端证书&lt;br>
客户端证书验证通过为API Server指定&lt;code>--client-ca-file=xxx&lt;/code>选项启用，API Server通过此ca文件来验证API请求携带的客户端证书的有效性，一旦验证成功，API Server就会将客户端证书Subject里的CN属性作为此次请求的用户名&lt;/p>
&lt;/li>
&lt;li>
&lt;p>静态token文件&lt;br>
通过指定&lt;code>--token-auth-file=SOMEFILE &lt;/code>选项来启用bearer token验证方式，引用的文件是一个包含了 token,用户名,用户ID 的csv文件
请求时，带上&lt;code>Authorization: Bearer 31ada4fd-adec-460c-809a-9e56ceb75269&lt;/code>头信息即可通过bearer token验证&lt;/p>
&lt;/li>
&lt;li>
&lt;p>静态密码文件&lt;br>
通过指定&lt;code>--basic-auth-file=SOMEFILE&lt;/code>选项启用密码验证，类似的，引用的文件时一个包含 密码,用户名,用户ID 的csv文件
请求时需要将&lt;code>Authorization&lt;/code>头设置为&lt;code>Basic BASE64ENCODED(USER:PASSWORD)&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这里只介绍客户端验证&lt;/p>
&lt;h2 id="为用户生成证书">为用户生成证书&lt;/h2>
&lt;p>假设我们操作的用户名为tom&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先需要为此用户创建一个私钥&lt;br>
&lt;code>openssl genrsa -out tom.key 2048&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接着用此私钥创建一个csr(证书签名请求)文件，其中我们需要在subject里带上用户信息(CN为用户名，O为用户组)&lt;br>
&lt;code>openssl req -new -key tom.key -out tom.csr -subj &amp;quot;/CN=tom/O=MGM&amp;quot;&lt;/code>&lt;br>
其中/O参数可以出现多次，即可以有多个用户组&lt;/p>
&lt;/li>
&lt;li>
&lt;p>找到K8S集群(API Server)的CA证书文件，其位置取决于安装集群的方式，通常会在&lt;code>/etc/kubernetes/pki/&lt;/code>路径下，会有两个文件，一个是CA证书(ca.crt)，一个是CA私钥(ca.key)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过集群的CA证书和之前创建的csr文件，来为用户颁发证书&lt;br>
&lt;code>openssl x509 -req -in tom.csr -CA path/to/ca.crt -CAkey path/to/ca.key -CAcreateserial -out tom.crt -days 365&lt;/code>&lt;br>
-CA和-CAkey参数需要指定集群CA证书所在位置，-days参数指定此证书的过期时间，这里为365天&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后将证书(tom.crt)和私钥(tom.key)保存起来，这两个文件将被用来验证API请求&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="为用户添加基于角色的访问控制rbac">为用户添加基于角色的访问控制(RBAC)&lt;/h2>
&lt;h3 id="角色role">角色(Role)&lt;/h3>
&lt;p>在RBAC中，角色有两种——普通角色(Role)和集群角色(ClusterRole)，ClusterRole是特殊的Role，相对于Role来说：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Role属于某个命名空间，而ClusterRole属于整个集群，其中包括所有的命名空间&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ClusterRole能够授予集群范围的权限，比如node资源的管理，比如非资源类型的接口请求(如&amp;quot;/healthz&amp;quot;)，比如可以请求全命名空间的资源(通过指定 &amp;ndash;all-namespaces)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="为用户添加角色">为用户添加角色&lt;/h3>
&lt;h4 id="首先创造一个角色">首先创造一个角色&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">kind&lt;/span>: Role
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">apiVersion&lt;/span>: rbac.authorization.k8s.io/v1beta1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">namespace&lt;/span>: a-1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">name&lt;/span>: admin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">rules&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#434f54">apiGroups&lt;/span>: [&lt;span style="color:#7f8c8d">&amp;#34;&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">resources&lt;/span>: [&lt;span style="color:#7f8c8d">&amp;#34;*&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">verbs&lt;/span>: [&lt;span style="color:#7f8c8d">&amp;#34;*&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是在a-1命名空间内创建了一个admin管理员角色，这里只是用admin角色举例，实际上如果只是为了授予用户某命名空间管理员的权限的话，是不需要新建一个角色的，K8S已经内置了一个名为admin的ClusterRole&lt;/p>
&lt;h4 id="将角色和用户绑定">将角色和用户绑定&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">kind&lt;/span>: RoleBinding
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">apiVersion&lt;/span>: rbac.authorization.k8s.io/v1beta1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">name&lt;/span>: admin-binding
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">namespace&lt;/span>: a-1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">subjects&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#434f54">kind&lt;/span>: User
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">name&lt;/span>: tom
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">apiGroup&lt;/span>: &lt;span style="color:#7f8c8d">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">roleRef&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">kind&lt;/span>: Role
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">name&lt;/span>: admin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">apiGroup&lt;/span>: &lt;span style="color:#7f8c8d">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如yaml中所示，RoleBinding资源创建了一个 Role-User 之间的关系，&lt;code>roleRef&lt;/code>节点指定此RoleBinding所引用的角色，&lt;code>subjects&lt;/code>节点指定了此RoleBinding的受体，可以是User，也可以是前面说过的ServiceAccount，在这里只包含了名为 tom 的用户&lt;/p>
&lt;h4 id="添加命名空间管理员的另一种方式">添加命名空间管理员的另一种方式&lt;/h4>
&lt;p>前面说过，K8S内置了一个名为admin的ClusterRole，所以实际上我们无需创建一个admin Role，直接对集群默认的admin ClusterRole添加RoleBinding就可以了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">kind&lt;/span>: RoleBinding
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">apiVersion&lt;/span>: rbac.authorization.k8s.io/v1beta1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">name&lt;/span>: admin-binding
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">namespace&lt;/span>: a-1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">subjects&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#434f54">kind&lt;/span>: User
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">name&lt;/span>: tom
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">apiGroup&lt;/span>: &lt;span style="color:#7f8c8d">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">roleRef&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">kind&lt;/span>: ClusterRole
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">name&lt;/span>: admin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">apiGroup&lt;/span>: &lt;span style="color:#7f8c8d">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里虽然引用的是作为ClusterRole的admin角色，但是其权限被限制在RoleBinding admin-binding所处的命名空间，即a-1内
如果想要添加全命名空间或者说全集群的管理员，可以使用cluster-admin角色&lt;/p>
&lt;p>到此为止，我们已经：&lt;/p>
&lt;ul>
&lt;li>为tom用户提供了基于X509证书的验证&lt;/li>
&lt;li>为a-1命名空间创造了一个admin角色&lt;/li>
&lt;li>为用户tom和角色admin创建了绑定关系&lt;/li>
&lt;/ul>
&lt;h2 id="为kubectl配置用户">为kubectl配置用户&lt;/h2>
&lt;p>tom已经是管理员了，现在我们想要通过kubectl以tom的身份来操作集群，需要将tom的认证信息添加进kubectl的配置，即~/.kube/config中&lt;/p>
&lt;p>这里假设config中已经配置好了k8s集群&lt;/p>
&lt;ol>
&lt;li>
&lt;p>通过命令&lt;code>kubectl config set-credentials tom --client-certificate=path/to/tom.crt --client-key=path/to/tom.key&lt;/code>将用户tom的验证信息添加进kubectl的配置&lt;br>
此命令会在配置中添加一个名为tom的用户&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>kubectl config set-context tom@aliyun --cluster=aliyun --namespace=a-1 --user=tom&lt;/code>&lt;br>
此命令添加了一个context配置——设定使用aliyun集群，默认使用a-1命名空间，使用用户tom进行验证&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在命令中带上 &lt;code>kubectl --context=tom@aliyun ...&lt;/code> 参数即可指定kubectl使用之前添加的名为tom@aliyun的context操作集群&lt;br>
也可以通过命令 &lt;code>kubectl config use-context tom@aliyun&lt;/code> 来设置当前使用的context&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="tips-将认证信息嵌入kubectl的配置中">Tips: 将认证信息嵌入kubectl的配置中&lt;/h4>
&lt;p>通过&lt;code>kubectl config set-credentials&lt;/code>命令添加的用户，其默认使用的是引用证书文件路径的方式，表现在~/.kube/config中，就是：&lt;/p>
&lt;pre tabindex="0">&lt;code>users:
- name: tom
user:
client-certificate: path/to/tom.crt
client-key: path/to/tom.key
&lt;/code>&lt;/pre>&lt;p>如果觉得这样总是带着两个证书文件不方便的话，可以将证书内容直接放到config文件里&lt;/p>
&lt;ol>
&lt;li>
&lt;p>将tom.crt/tom.key的内容用BASE64编码&lt;br>
&lt;code>cat tom.crt | base64 --wrap=0&lt;/code>&lt;br>
&lt;code>cat tom.key | base64 --wrap=0&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将获取的编码后的文本复制进config文件中&lt;/p>
&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>users:
- name: ich
user:
client-certificate-data: ...
client-key-data: ...
&lt;/code>&lt;/pre>&lt;p>这样就不再需要证书和私钥文件了，当然这两个文件还是保存起来比较好&lt;/p>
&lt;p>&lt;em>参考资料：&lt;/em>&lt;br>
&lt;em>&lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/">Authenticating - Kubernetes Docs&lt;/a>&lt;/em>&lt;br>
&lt;em>&lt;a href="https://docs.bitnami.com/kubernetes/how-to/configure-rbac-in-your-kubernetes-cluster/">Configure RBAC in your Kubernetes Cluster&lt;/a>&lt;/em>&lt;br>
&lt;em>&lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">Using RBAC Authorization - Kubernetes Docs&lt;/a>&lt;/em>&lt;br>
&lt;em>&lt;a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#config">Kubectl Reference Docs#config&lt;/a>&lt;/em>&lt;br>
&lt;em>&lt;a href="https://brancz.com/2017/10/16/kubernetes-auth-x509-client-certificates/">Kubernetes auth: X509 client certificates&lt;/a>&lt;/em>&lt;/p></description></item><item><title>Pipelines - .NET中的新IO API指引(二)</title><link>http://suraciii.github.io/posts/trans-pipelines-marcgravell-2/</link><pubDate>Tue, 17 Jul 2018 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/trans-pipelines-marcgravell-2/</guid><description>&lt;p>原文：&lt;a href="https://blog.marcgravell.com/2018/07/pipe-dreams-part-2.html">Pipelines - a guided tour of the new IO API in .NET, part 2&lt;/a>&lt;/p>
&lt;p>作者：marcgravell&lt;/p>
&lt;p>在&lt;a href="https://blog.marcgravell.com/2018/07/pipe-dreams-part-1.html">上一章&lt;/a>，我们讨论了以往的&lt;code>Stream&lt;/code>API中存在的一些问题，并且介绍了&lt;code>Pipe&lt;/code>,&lt;code>PipeWriter&lt;/code>,&lt;code>PipeReader&lt;/code> 等API，研究如何写出一个&lt;code>Pipe&lt;/code> 并且从中消费数据，我们也讨论了&lt;code>FlushAsync()&lt;/code> 和&lt;code>ReadAsync()&lt;/code> 是如何协同保证两端的工作，从而解决“空”和“满”的场景——在没有数据时挂起reader，并在数据到来时恢复它；在写入快过读取(Pipe满载)时挂起writer，并在reader追上后恢复它；并且我们也在线程模型的层面上探讨了什么是“挂起”。&lt;/p>
&lt;p>在这章，我们将会研究pipelines的内存模型：数据实际上存在于哪里？。我们也会开始着手研究如何在现实场景中使用pipelines以满足真实需求。&lt;/p>
&lt;h3 id="内存模型我的数据在哪里">内存模型：我的数据在哪里？&lt;/h3>
&lt;p>在上一章，我们讲了pipe如何管理所有的缓冲区，允许writer通过 &lt;code>GetMemory()&lt;/code>和&lt;code>GetSpan()&lt;/code>请求缓冲区，随后通过&lt;code>ReadAsync()&lt;/code>中的 &lt;code>.Buffer&lt;/code> 将提交后的数据暴露给reader——reader取得的数据是一个 &lt;code>ReadOnlySequence&amp;lt;byte&amp;gt;&lt;/code>，即所有数据的几个片段。&lt;/p>
&lt;p>那么其中究竟发生了什么？&lt;/p>
&lt;p>每一个&lt;code>Pipe&lt;/code>实例都有一个引用指向&lt;code>MemoryPool&amp;lt;byte&amp;gt;&lt;/code>——一个&lt;a href="https://www.nuget.org/packages/System.Memory/">&lt;code>System.Memory&lt;/code>&lt;/a> 中的新东西，顾名思义，它创建了一个内存池。在创建&lt;code>Pipe&lt;/code>的时候，你可以在选项中指定一个专门的 &lt;code>MemoryPool&amp;lt;byte&amp;gt;&lt;/code>，但是在默认情况下(我猜也是大多数情况下)——应该是使用一个应用级别共享的 (&lt;code>MemoryPool&amp;lt;byte&amp;gt;.Shared&lt;/code>) 内存池。&lt;/p>
&lt;p>&lt;code>MemoryPool&amp;lt;byte&amp;gt;&lt;/code> 的概念是非常开放的。其&lt;em>默认&lt;/em>的实现是简单地使用&lt;code>ArrayPool&amp;lt;byte&amp;gt;.Shared&lt;/code> (应用级别的数组池)，在需要的时候租借数组，并在使用完后归还。这个 &lt;code>ArrayPool&amp;lt;T&amp;gt;&lt;/code> 使用了 &lt;code>WeakReference&lt;/code>来实现，所以池化的数组在内存有压力时是可以回收的，但是，当你请求&lt;code>GetMemory(someSize)&lt;/code> 或者 &lt;code>GetSpan(someSize)&lt;/code>时，它并不是简单地向内存池请求“someSize”，相反，它在内部追踪了一个“片段(segment)”，一个新“片段”将是（默认情况下，可以通过配置改变）someSize和2048字节中的最大值，这样请求一个大小可观的内存意味着我们的系统不会充满着许多小数组，而后者会对GC造成显著碰撞。当你在writer中 &lt;code>Advance(bytesWritten)&lt;/code>，它：&lt;/p>
&lt;ul>
&lt;li>移动一个表达当前已使用多少片段的内部计数器&lt;/li>
&lt;li>更新reader的”备读(available to be read)“链的末端；如果我们刚刚对一个空片段的第一个字节进行了写入，这意味着将会向链中增加一个新片段，否则，它意味着当前链的结尾标志被增加（后移）&lt;/li>
&lt;/ul>
&lt;p>这就是我们从 &lt;code>ReadAsync()&lt;/code>中获取到的”备读“链；而当我们在reader中 &lt;code>AdvanceTo&lt;/code> ——如果整个片段都被消费掉了，那么pipe会将这些片段送回内存池。在那里，它们可以被多次复用。并且作为上述两点导致的直接结果，我们可以看到在大多数情况下(即使在writer中多次调用&lt;code>Advance&lt;/code> )，我们最终可以在reader中发现一个单独的片段；而在片段边界处，或reader落后于writer，数据开始累积的情况下，会有多个片段。&lt;/p>
&lt;p>只有使用默认池才能：&lt;/p>
&lt;ul>
&lt;li>我们不用在每次调用&lt;code>GetMemory()&lt;/code> / &lt;code>GetSpan()&lt;/code>时都要分配内存&lt;/li>
&lt;li>我们不需要每次&lt;code>GetMemory()&lt;/code> / &lt;code>GetSpan()&lt;/code>都要有一个单独的数组——通常我们只是获得同样的”片段“中的某个不同的范围&lt;/li>
&lt;li>只使用少量的大缓冲数组&lt;/li>
&lt;li>它们不需要大量的类库代码，就可以自动回收&lt;/li>
&lt;li>当不再需要时，它们可以被GC回收&lt;/li>
&lt;/ul>
&lt;p>这也解释了为什么在&lt;code>GetMemory()&lt;/code> / &lt;code>GetSpan()&lt;/code>中请求少量空间再在之后检查其大小的举动是有效的：我们可以访问&lt;em>当前段的剩下未使用的部分&lt;/em>。这意味着：一个大小为2048的片段，在之前的写入中用掉了200字节——即使我们只请求5字节，我们也可以看到我们还剩下1848字节可供使用，或者更多——记住：从&lt;code>ArrayPool.Shared&lt;/code> 中获取到的数组也是一个”至少这么大“的操作。&lt;/p>
&lt;h3 id="零复制缓冲区">零复制缓冲区&lt;/h3>
&lt;p>在此还有需要注意的地方是，我们获取数据缓冲的时候，&lt;em>没有进行任何数据的复制&lt;/em>。writer申请一个缓冲区，然后第一次写入数据到需要的位置。这就成了writer和reader之间的缓冲区，无需复制数据。而如果reader当前无法处理完所有的数据，它能够通过显示声明其”未被消费“地方式将数据放回pipe。这样无需为reader维护一个单独的数据积压处，而这在使用&lt;code>Stream&lt;/code>的协议处理代码中是&lt;em>非常&lt;/em>常见的。&lt;/p>
&lt;p>正是这种功能间的组合使得pipeline代码在内存层面显得非常友好。你可以用&lt;code>Stream&lt;/code>做到所有的这些，但是却需要大量令人痛苦的易出错的代码去实现，如果你想做好，甚至需要更多——并且你几乎必须去为每个场景单独地实现它。Pipelines让良好的内存处理变为默认的简单的途径——落入成功之中&lt;/p>
&lt;h3 id="更多奇特的内存池">更多奇特的内存池&lt;/h3>
&lt;p>你并不受限于使用我们之前讨论的内存池；你可以实现你自己的自定义内存池！默认内存池的优点在于它很简单。尤其是我们是否100%完美地返回每个片段并不重要——如果我们以某种方式丢弃某个pipe，最坏的情况会是GC将在某个时刻回收掉被丢弃的片段。它们不会回到池中，但那没关系。&lt;/p>
&lt;p>但是，你可以做很多有趣的东西。想象一下，比如一个 &lt;code>MemoryPool&amp;lt;byte&amp;gt;&lt;/code>承载巨量的内存——通过一些非常大的数组得到的托管内存，或是通过 &lt;code>Marshal.AllocHGlobal&lt;/code> 获得的非托管内存（注意 &lt;code>Memory&lt;/code> 和 &lt;code>Span&lt;/code> 并&lt;em>不受限于&lt;/em>数组——它们需要的不过是某种连续内存），按需使用这些巨大的内存块。这有很大的潜在场景，但是它会使片段的可靠回收变得更加重要。大多数系统不应该这么做，但是提供这样的灵活性是好的。&lt;/p>
&lt;h3 id="在真实系统中有用的pipes">在真实系统中有用的pipes&lt;/h3>
&lt;p>我们在第一部分中用的例子，是一个读写均在同一代码的单独&lt;code>Pipe&lt;/code>。很明显这不是个真实场景（除非我们是在试图模拟一个&amp;quot;echo&amp;quot;服务器），所以我们在更真实的场景中可以做什么呢？首先，我们需要把我们的pipelines连接到什么东西上。我们通常并不想单独地使用Pipe，相反，我们希望可以有一个&lt;em>结合一个普遍的系统或API使用&lt;/em>的pipe。所以，来让我们开始看看接下来会是什么样子吧。&lt;/p>
&lt;p>在这里，我们需要注意：发布于.NET Core 2.1的pipelines不包括任何终端实现。这意味着： &lt;code>Pipe&lt;/code> 虽然存在，但是&lt;em>在框架内&lt;/em>没有提供任何的与现有系统的实际连接——就像提供了抽象的 &lt;code>Stream&lt;/code> 基类，却没有 &lt;code>FileStream&lt;/code>,，&lt;code>NetworkStream&lt;/code>等。是的，这听起来让人感到失望，但是这只是由于时间限制，不要慌！现在在进行一些关于它们应该以哪种优先级实现的“活跃的”讨论。并且现在有少量的社区贡献来补足最明显的缺陷。&lt;/p>
&lt;p>一旦我们处于那些场景，我们可能会问：“将pipelines连接到另一个数据后端需要什么？”&lt;/p>
&lt;p>也许将一个pipe连接到一个 &lt;code>Stream&lt;/code>会是一个不错的开头。我知道你在想：“但是Marc，你在上一章你不遗余力地再说 &lt;code>Stream&lt;/code> 有多么糟糕！”。我没有改变我的看法，它不一定是完美的——对于那些特定场景的&lt;code>Stream&lt;/code>实现（比如&lt;code>NetworkStream&lt;/code>或&lt;code>FileStream&lt;/code>）我们可以有一个专门的基于pipelines的终端直接与那个服务以最小的中转进行通讯；但是这是一个有用的起步：&lt;/p>
&lt;ul>
&lt;li>它使我们可以立即访问到巨量的API——任何可以通过&lt;code>Stream&lt;/code>暴露数据，或任何通过封装的streams作为中间层的API（加密、压缩等）&lt;/li>
&lt;li>它将所有老旧的&lt;code>Stream&lt;/code>API隐藏在一个明确清晰的表层下&lt;/li>
&lt;li>它带来了&lt;em>几乎所有&lt;/em>我们之前提到过的优点&lt;/li>
&lt;/ul>
&lt;p>所以，让我们开始吧！我们首先要思考的是：这里的&lt;em>方向&lt;/em>是什么？就像刚才提到的一样，&lt;code>Stream&lt;/code>是模糊不清的——可能只读，只写，或可读可写。来假设我们想解决的是最通常的问题：一个可读可写表现为双工行为的stream——这可以让我们访问如sockets(通过&lt;code>NetworkStream&lt;/code>)之类的东西。这意味着我们实际上将会需要&lt;em>两个&lt;/em>pipe——一个用来输入，一个用来输出。Pipelines通过明确地声明&lt;code>IDuplexPipe&lt;/code>接口来帮助我们指明道路。这是一个非常简单的接口，数据传输给&lt;code>IDuplexPipe&lt;/code>就像传输给两个pipe的端点一样——一个标记为&amp;quot;in&amp;quot;，一个标记为&amp;quot;out&amp;quot;：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">interface&lt;/span> &lt;span style="color:#434f54">IDuplexPipe&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">PipeReader&lt;/span> &lt;span style="color:#434f54">Input&lt;/span> { &lt;span style="color:#728e00">get&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">PipeWriter&lt;/span> &lt;span style="color:#434f54">Output&lt;/span> { &lt;span style="color:#728e00">get&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们接下来想要做的是创建一个类来实现 &lt;code>IDuplexPipe&lt;/code>，但是其内部使用两个&lt;code>Pipe&lt;/code>实例：&lt;/p>
&lt;ul>
&lt;li>一个&lt;code>Pipe&lt;/code>会是输出缓冲区（从消费者的角度来看），它将会在调用者写入&lt;code>Output&lt;/code>是被填充——并且我们将会用一个循环来消费这个&lt;code>Pipe&lt;/code>并且将数据推入底层&lt;code>Stream&lt;/code>(被用来写入网络，或者其它任何stream可以写入的)&lt;/li>
&lt;li>一个&lt;code>Pipe&lt;/code>将会是输入缓冲区（从消费者的角度来看），我们将有一个循环来从底层&lt;code>Stream&lt;/code>&lt;em>读取&lt;/em>数据，并将其推入&lt;code>Pipe&lt;/code>，它将会在调用者从&lt;code>Input&lt;/code>中读取时排出&lt;/li>
&lt;/ul>
&lt;p>这个方法可以立即解决普遍影响着那些使用&lt;code>Stream&lt;/code>的人&lt;em>一大堆&lt;/em>的问题：&lt;/p>
&lt;ul>
&lt;li>我们现在有了input/output缓冲区，用于从读/写调用中解耦stream访问，而不用添加&lt;code>BufferedStream&lt;/code>或是其它类似的防止数据碎片的功能（对于写入代码来说）,并且这将会使我们在处理数据时很方便去接收更多数据（特别是对于读取代码来说，这样我们不用在请求更多数据时保持暂停）&lt;/li>
&lt;li>如果调用代码的写入快过stream的&lt;code>Write&lt;/code>可以处理的程度，背压特性将会展现出来，对调用代码进行节流，这样我们不会被充满未发送数据的巨大缓冲区所终结&lt;/li>
&lt;li>如果stream的&lt;code>Read&lt;/code>超过了消费这些数据的调用代码，背压特性也会在这里出场，对我们的stream读取循环进行节流，这样我们不会被充满未处理数据的巨大缓冲区所终结&lt;/li>
&lt;li>读取和写入代码都会受益于我们之前所讨论的内存池的所有优点&lt;/li>
&lt;li>调用代码从来不用担心数据的后备存储（未完成帧）等——pipe去解决它&lt;/li>
&lt;/ul>
&lt;h3 id="那么它看起来会是什么样">那么它看起来会是什么样？&lt;/h3>
&lt;p>基本上，我们需要做的就是这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">class&lt;/span> &lt;span style="color:#434f54">StreamDuplexPipe&lt;/span> : &lt;span style="color:#434f54">IDuplexPipe&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">Stream&lt;/span> &lt;span style="color:#434f54">_stream&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">Pipe&lt;/span> &lt;span style="color:#434f54">_readPipe&lt;/span>, &lt;span style="color:#434f54">_writePipe&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">public&lt;/span> &lt;span style="color:#434f54">PipeReader&lt;/span> &lt;span style="color:#434f54">Input&lt;/span> =&amp;gt; &lt;span style="color:#434f54">_readPipe&lt;/span>.&lt;span style="color:#434f54">Reader&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">public&lt;/span> &lt;span style="color:#434f54">PipeWriter&lt;/span> &lt;span style="color:#434f54">Output&lt;/span> =&amp;gt; &lt;span style="color:#434f54">_writePipe&lt;/span>.&lt;span style="color:#434f54">Writer&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// ... more here&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意我们有两个不同的pipe；调用者获取每个pipe的一个端点——然后我们的代码将会操作每个pipe的&lt;em>另一个&lt;/em>端点。&lt;/p>
&lt;h3 id="对pipe进行抽取">对pipe进行抽取&lt;/h3>
&lt;p>那么我们与stream交互的代码是什么样的呢？像之前说过的那样，我们需要两个方法。首先——很简单——一个循环，从&lt;code>_stream&lt;/code>中读取数据并且将其推入&lt;code>_readPipe&lt;/code>，然后被调用代码所消费；这个方法的核心类似这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">while&lt;/span> (&lt;span style="color:#00979d">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// note we&amp;#39;ll usually get *much* more than we ask for&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">buffer&lt;/span> = &lt;span style="color:#434f54">_readPipe&lt;/span>.&lt;span style="color:#434f54">Writer&lt;/span>.&lt;span style="color:#434f54">GetMemory&lt;/span>(&lt;span style="color:#8a7b52">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">int&lt;/span> &lt;span style="color:#434f54">bytes&lt;/span> = &lt;span style="color:#728e00">await&lt;/span> &lt;span style="color:#434f54">_stream&lt;/span>.&lt;span style="color:#434f54">ReadAsync&lt;/span>(&lt;span style="color:#434f54">buffer&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">_readPipe&lt;/span>.&lt;span style="color:#434f54">Writer&lt;/span>.&lt;span style="color:#434f54">Advance&lt;/span>(&lt;span style="color:#434f54">bytes&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">if&lt;/span> (&lt;span style="color:#434f54">bytes&lt;/span> == &lt;span style="color:#8a7b52">0&lt;/span>) &lt;span style="color:#728e00">break&lt;/span>; &lt;span style="color:#95a5a6">// source EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">flush&lt;/span> = &lt;span style="color:#728e00">await&lt;/span> &lt;span style="color:#434f54">_readPipe&lt;/span>.&lt;span style="color:#434f54">Writer&lt;/span>.&lt;span style="color:#434f54">FlushAsync&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">if&lt;/span> (&lt;span style="color:#434f54">flush&lt;/span>.&lt;span style="color:#434f54">IsCompleted&lt;/span> || &lt;span style="color:#434f54">flush&lt;/span>.&lt;span style="color:#434f54">IsCanceled&lt;/span>) &lt;span style="color:#728e00">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个循环向pipie请求一个缓冲区，然后用 &lt;code>netcoreapp2.1&lt;/code> 中&lt;code>Stream.ReadAsync&lt;/code> 的新重载接收一个 &lt;code>Memory&amp;lt;byte&amp;gt;&lt;/code> 来填充缓冲区——我们一会儿讨论如果你现在没有一个能接收 &lt;code>Memory&amp;lt;byte&amp;gt;&lt;/code> 的API该怎么办。当读取完成后，它使用&lt;code>Advance&lt;/code>向pipe提交这个数量的字节，然后它在pipe上调用 &lt;code>FlushAsync()&lt;/code> 来（如果需要的话）唤醒reader，或者在背压减轻时暂停写循环。注意我们还需要检查&lt;code>Pipe&lt;/code>的 &lt;code>FlushAsync()&lt;/code>的结果——它可以告诉我们pipe的消费者已经告知其已经读取完了所有想要的数据（&lt;code>Iscompleted&lt;/code>），或者pipe本身被关闭（&lt;code>IsCanceled&lt;/code>）。&lt;/p>
&lt;p>注意在这两种情况下，我们都希望确保在此循环退出时告诉管道，这样我们就不会最终在没有数据到来时永远在调用端等待下去。意外发生时，或者有时在调用 &lt;code>_stream.ReadAsync&lt;/code> （或其它方法）时，可能会有异常抛出，所以最好是利用&lt;code>try&lt;/code>/&lt;code>finally&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">Exception&lt;/span> &lt;span style="color:#434f54">error&lt;/span> = &lt;span style="color:#00979d">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">try&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// our loop from the previous sample&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">catch&lt;/span>(&lt;span style="color:#434f54">Exception&lt;/span> &lt;span style="color:#434f54">ex&lt;/span>) { &lt;span style="color:#434f54">error&lt;/span> = &lt;span style="color:#434f54">ex&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">finally&lt;/span> { &lt;span style="color:#434f54">_readPipe&lt;/span>.&lt;span style="color:#434f54">Writer&lt;/span>.&lt;span style="color:#434f54">Complete&lt;/span>(&lt;span style="color:#434f54">error&lt;/span>); }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你愿意的话，你可以使用两个 &lt;code>Complete&lt;/code> ——一个在try末尾（成功时），一个在catch中（失败时）。&lt;/p>
&lt;p>我们需要的第二个方法会比较复杂。我们需要一个循环来从&lt;code>_writePipe&lt;/code>中消费数据，然后将其推入&lt;code>_stream&lt;/code>。核心代码会像这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">while&lt;/span> (&lt;span style="color:#00979d">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">read&lt;/span> = &lt;span style="color:#728e00">await&lt;/span> &lt;span style="color:#434f54">_writePipe&lt;/span>.&lt;span style="color:#434f54">Reader&lt;/span>.&lt;span style="color:#434f54">ReadAsync&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">buffer&lt;/span> = &lt;span style="color:#434f54">read&lt;/span>.&lt;span style="color:#434f54">Buffer&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">if&lt;/span> (&lt;span style="color:#434f54">buffer&lt;/span>.&lt;span style="color:#434f54">IsCanceled&lt;/span>) &lt;span style="color:#728e00">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">if&lt;/span> (&lt;span style="color:#434f54">buffer&lt;/span>.&lt;span style="color:#434f54">IsEmpty&lt;/span> &amp;amp;&amp;amp; &lt;span style="color:#434f54">read&lt;/span>.&lt;span style="color:#434f54">IsCompleted&lt;/span>) &lt;span style="color:#728e00">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// write everything we got to the stream&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">foreach&lt;/span> (&lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">segment&lt;/span> &lt;span style="color:#728e00">in&lt;/span> &lt;span style="color:#434f54">buffer&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">await&lt;/span> &lt;span style="color:#434f54">_stream&lt;/span>.&lt;span style="color:#434f54">WriteAsync&lt;/span>(&lt;span style="color:#434f54">segment&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">_writePipe&lt;/span>.&lt;span style="color:#434f54">AdvanceTo&lt;/span>(&lt;span style="color:#434f54">buffer&lt;/span>.&lt;span style="color:#434f54">End&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">await&lt;/span> &lt;span style="color:#434f54">_stream&lt;/span>.&lt;span style="color:#434f54">FlushAsync&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这会等待一些数据（可能在多个缓冲区里），然后进行一些退出判断检查；像之前一样，我们可以在&lt;code>IsCanceled&lt;/code>时放弃，但是下一个检查会比较微妙：我们不希望只因为&lt;em>producer&lt;/em>表示它们已经写入了所有想要的数据（&lt;code>Iscompleted&lt;/code>）就停止写入，不然我们也许会丢失它们末尾几段数据——我们需要继续直到我们已经写入了它们所有的数据，直到&lt;code>buffer.IsEmpty&lt;/code>。这是个简化后的例子，因为我们一直写入所有数据——我们之后会看到更复杂的例子。一旦我们有了数据，我们按顺序将每个非连续缓冲区写入stream中——因为&lt;code>Stream&lt;/code>一次只能写入一个缓冲区（同样，我使用的是&lt;code>netcoreapp2.1&lt;/code>中的重载，接受&lt;code>ReadOnlyMemory&amp;lt;byte&amp;gt;&lt;/code>参数，但是我们不限于此）。一旦它写完了缓冲区，它告诉pipe我们已经消费完了所有数据，然后刷新(flush)底层的&lt;code>Stream&lt;/code>。&lt;/p>
&lt;p>在“真实”代码中，我们&lt;em>也许&lt;/em>希望更积极地优化从而减少刷新底层stream直到我们知道再也不会有可读取地数据，也许 在&lt;code>_writePipe.Reader.ReadAsync()&lt;/code>之外可以使用&lt;code>_writePipe.Reader.TryRead(...)&lt;/code> 。这个方法地工作方式类似 &lt;code>ReadAsync()&lt;/code>但是保证会同步返回——用来测试“在我忙的时候writer是否附加了什么？”。但是上面的内容已经讲述了这一点。&lt;/p>
&lt;p>另外，像之前一样，我们也许需要添加一个 &lt;code>try&lt;/code>/&lt;code>finally&lt;/code>，这样在我们退出时总是会调用&lt;code>_writePipe.Reader.Complete()&lt;/code>。&lt;/p>
&lt;p>我们可以使用 &lt;code>PipeScheduler&lt;/code> 来启动这两个泵(pumps)，这会确保它们在预期环境中运行，然后我们的循环开始泵送数据。我们要添加&lt;em>一些&lt;/em>格外的内容（我们可能需要一种机制来 &lt;code>Close()&lt;/code>/&lt;code>Dispose()&lt;/code> 底层stream等）——但是像你所看到的，将 &lt;code>IDuplexPipe&lt;/code> 连接到没有pipeline设计的源不需要是一项&lt;em>艰巨&lt;/em>的任务。&lt;/p>
&lt;h3 id="这是我之前做的">这是我之前做的&amp;hellip;&lt;/h3>
&lt;p>我已经将上面的内容简化了一些（说真的，不是太多），以便让它适合讨论，但是你可能仍然不应该从这里复制粘贴代码来尝试让它工作。我并没有声称它们时适用于所有情况的完美解决方案，但是作为&lt;a href="https://github.com/StackExchange/StackExchange.Redis/issues/871">StackExchange.Redis 2.0版&lt;/a>工作的一部分，我们实现了一系列pipelines的绑定放在nuget上——毫无创意地命名为 &lt;code>Pipelines.Sockets.Unofficial&lt;/code> （&lt;a href="https://www.nuget.org/packages/Pipelines.Sockets.Unofficial/">nuget&lt;/a>,github(&lt;a href="https://github.com/mgravell/Pipelines.Sockets.Unofficial">https://github.com/mgravell/Pipelines.Sockets.Unofficial&lt;/a>)，它包括：&lt;/p>
&lt;ul>
&lt;li>将双工的&lt;code>Stream&lt;/code>转换为 &lt;code>IDuplexPipe&lt;/code> （就像上面说的）&lt;/li>
&lt;li>将只读&lt;code>Stream&lt;/code>转换为&lt;code>PipeReader&lt;/code>&lt;/li>
&lt;li>将只写&lt;code>Stream&lt;/code>转换为&lt;code>PipeWriter&lt;/code>&lt;/li>
&lt;li>将 &lt;code>IDuplexPipe&lt;/code> 转换为双工的&lt;code>Stream&lt;/code>&lt;/li>
&lt;li>将&lt;code>PipeReader&lt;/code>转换为只读&lt;code>Stream&lt;/code>&lt;/li>
&lt;li>将&lt;code>PipeWriter&lt;/code>转换为只写&lt;code>Stream&lt;/code>&lt;/li>
&lt;li>将&lt;code>Socket&lt;/code>直接转换成&lt;code>IDuplexPipe&lt;/code>（不经过&lt;code>NetworkStream&lt;/code>）&lt;/li>
&lt;/ul>
&lt;p>前六个在 &lt;code>StreamConnection&lt;/code>的静态方法中，最后一个在&lt;code>SocketConnection&lt;/code>里。&lt;/p>
&lt;p>&lt;code>StackExchange.Redis&lt;/code> 牵涉着大量&lt;code>Socket&lt;/code>工作，所以我们对如何将pipeline连接到socket上非常感兴趣，对于没有TLS的redis连接，我们可以直接将我们的&lt;code>Socket&lt;/code>连接到pipeline：&lt;/p>
&lt;ul>
&lt;li>&lt;code>Socket&lt;/code>  ⇔ &lt;code>SocketConnection&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>对于需要TLS的redis连接（比如云redis提供商），我们可以这样连接：&lt;/p>
&lt;ul>
&lt;li>&lt;code>Socket&lt;/code> ⇔ &lt;code>NetworkStream&lt;/code> ⇔ &lt;code>SslStream&lt;/code> ⇔ &lt;code>StreamConnection&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>所有这两种配置都是一个&lt;code>Socket&lt;/code>在其中一端，一个&lt;code>IDuplexPipe&lt;/code>在另一端，它开始展示我们如何将pipeline作为更复杂系统的一部分。也许更重要的是，它为我们在未来实施改变提供了空间。将来有可能的例子：&lt;/p>
&lt;ul>
&lt;li>Tim Seaward一直在折腾&lt;a href="https://github.com/Drawaes/Leto">&lt;code>Leto&lt;/code>&lt;/a>，它提供了不需要 &lt;code>SslStream&lt;/code> ，直接用&lt;code>IDuplexPipe&lt;/code>实现TLS的能力（并且不需要stream逆变器）&lt;/li>
&lt;li>在 Tim Seaward，David Fowler 和Ben Adams之间，有&lt;em>一系列&lt;/em>直接实现pipelines而不用托管sockets的实验性/正在进行的网络层工作，包括&amp;quot;libuv&amp;quot;，&amp;ldquo;RIO&amp;rdquo;（Registerd IO），和最近的&amp;quot;magma&amp;quot;——它将整个TCP栈推入用户代码从而减少系统调用。&lt;/li>
&lt;/ul>
&lt;p>看这个空间如何发展将会非常有趣！&lt;/p>
&lt;h3 id="但是我当前的api不会使用span或者memory">但是我当前的API不会使用 &lt;code>Span&lt;/code> 或者 &lt;code>Memory&lt;/code>！&lt;/h3>
&lt;p>当在写将数据从pipe中泵送到其它系统（比如一个&lt;code>Socket&lt;/code>）时，很有可能你会遇到不接收 &lt;code>Span&lt;/code> 或者 &lt;code>Memory&lt;/code>的API。不要慌，这没有大碍，你依然可以有很多种变通方案使其变得更……传统。&lt;/p>
&lt;p>在你有一个 &lt;code>Memory&lt;/code> 或者 &lt;code>ReadOnlyMemory&lt;/code>时，第一个技巧是&lt;code>MemoryMarshal.TryGetArray(...)&lt;/code>。它接收一个&lt;em>memory&lt;/em>并且尝试获取一个&lt;code>ArraySegment&lt;/code> ，它用一个&lt;code>T[]&lt;/code>vector和一个&lt;code>int&lt;/code>偏移/计数对描述相同的数据。显然，这只有在这块内存&lt;em>是基于&lt;/em>一个vector时才能用，而情况并非总是如此，所以这可能会在异种的内存池上失败。我们第二个解决办法时&lt;code>MemoryMarshal.GetReference(...)&lt;/code>，它接受一个&lt;em>span&lt;/em>然后返回一个原始数据起点的引用（实际上是一个“托管指针”，又叫做 &lt;code>ref T&lt;/code>）。一旦我们有了一个 &lt;code>ref T&lt;/code>，我们可以用&lt;code>unsafe&lt;/code>语法来获得一个这个数据的非托管指针，在这种情况下会有用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">Span&lt;/span>&amp;lt;&lt;span style="color:#00979d">byte&lt;/span>&amp;gt; &lt;span style="color:#434f54">span&lt;/span> = ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">fixed&lt;/span>(&lt;span style="color:#00979d">byte&lt;/span>* &lt;span style="color:#434f54">ptr&lt;/span> = &amp;amp;&lt;span style="color:#434f54">MemoryMarshal&lt;/span>.&lt;span style="color:#434f54">GetReference&lt;/span>(&lt;span style="color:#434f54">span&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>即使span的长度是零，你依然可以这么做，其会返回一个第0项&lt;em>将会存在&lt;/em>的位置，而且甚至在使用&lt;code>default&lt;/code>span即根本没有实际后备内存的时候，也可以这么使用。后面这个有一点需要注意，因为&lt;code>ref T&lt;/code>&lt;em>通常不被认为会是null&lt;/em>，但是在这里它是。实际上，只要你不去尝试对这种空引用进行解引用，不会有什么问题。如果你使用&lt;code>fixed&lt;/code>将其转换为一个非托管指针，你会得到一个空（零）指针，这相对来说更合理（并且在一些&lt;code>P/Invoke&lt;/code>场景中会有用），&lt;code>MemoryMarshal&lt;/code> 本质上是&lt;code>unsafe&lt;/code> 代码的同义词，即使你调用的那段代码并没有使用&lt;code>unsafe&lt;/code> 关键字。使用它是完全有效的，但是如果不恰当地使用它，它可能会坑到你——所以小心就是了。&lt;/p>
&lt;h3 id="pipe的应用端代码是什么样的">Pipe的应用端代码是什么样的？&lt;/h3>
&lt;p>OK，我们有了&lt;code>IDuplexPipe&lt;/code>，并且我们也看到了如何将两个pipe的“业务端”连接到你选择的后端数据服务。现在，我们在应用代码中如何使用它？&lt;/p>
&lt;p>按照我们上一章的例子，我们将从 &lt;code>IDuplexPipe.Output&lt;/code> 中把&lt;code>PipeWriter&lt;/code>传递给我们的出站代码，从 &lt;code>IDuplexPipe.Input&lt;/code> 中把 &lt;code>PipeReader&lt;/code> 传递给我们的入站代码。&lt;/p>
&lt;p>&lt;em>出站&lt;/em>代码相当简单，并且通常是需要直接从基于&lt;code>Stream&lt;/code>的代码移植成基于&lt;code>PipeWriter&lt;/code>的代码。关键的区别还是那样，即&lt;em>你不再手动控制缓冲区&lt;/em>。下面是一个一个典型的实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">ValueTask&lt;/span>&amp;lt;&lt;span style="color:#00979d">bool&lt;/span>&amp;gt; &lt;span style="color:#434f54">Write&lt;/span>(&lt;span style="color:#434f54">SomeMessageType&lt;/span> &lt;span style="color:#434f54">message&lt;/span>, &lt;span style="color:#434f54">PipeWriter&lt;/span> &lt;span style="color:#434f54">writer&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// (this may be multiple GetSpan/Advance calls, or a loop,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// depending on what makes sense for the message/protocol)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">span&lt;/span> = &lt;span style="color:#434f54">writer&lt;/span>.&lt;span style="color:#434f54">GetSpan&lt;/span>(...);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// TODO: ... actually write the message&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">int&lt;/span> &lt;span style="color:#434f54">bytesWritten&lt;/span> = ... &lt;span style="color:#95a5a6">// from writing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">writer&lt;/span>.&lt;span style="color:#434f54">Advance&lt;/span>(&lt;span style="color:#434f54">bytesWritten&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">return&lt;/span> &lt;span style="color:#434f54">FlushAsync&lt;/span>(&lt;span style="color:#434f54">writer&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">private&lt;/span> &lt;span style="color:#728e00">static&lt;/span> &lt;span style="color:#728e00">async&lt;/span> &lt;span style="color:#434f54">ValueTask&lt;/span>&amp;lt;&lt;span style="color:#00979d">bool&lt;/span>&amp;gt; &lt;span style="color:#434f54">FlushAsync&lt;/span>(&lt;span style="color:#434f54">PipeWriter&lt;/span> &lt;span style="color:#434f54">writer&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// apply back-pressure etc&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">flush&lt;/span> = &lt;span style="color:#728e00">await&lt;/span> &lt;span style="color:#434f54">writer&lt;/span>.&lt;span style="color:#434f54">FlushAsync&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// tell the calling code whether any more messages&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// should be written&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">return&lt;/span> !(&lt;span style="color:#434f54">flush&lt;/span>.&lt;span style="color:#434f54">IsCanceled&lt;/span> || &lt;span style="color:#434f54">flush&lt;/span>.&lt;span style="color:#434f54">IsCompleted&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Write&lt;/code> 的第一部分是我们的业务代码，我们需要把数据从writer写入到缓冲区；通常这会多次调用 &lt;code>GetSpan(...)&lt;/code> 和 &lt;code>Advance()&lt;/code>。当我们写完了数据，我们可以flush它从而保证启动泵送并且应用背压控制。对于那些非常大的消息体，我们&lt;em>也可以&lt;/em>在中间点flush，但是对于大多数场景：一个消息flush一次足够了。&lt;/p>
&lt;p>如果你好奇为什么我将&lt;code>FlushAsync&lt;/code> 分割到不同的代码中：那是因为我想&lt;code>await&lt;/code> &lt;code>FlushAsync&lt;/code>的结果来检查退出条件，所以它需要在一个&lt;code>async&lt;/code> 方法里，在这里最有效率的访问内存方式是通过 &lt;code>Span&amp;lt;byte&amp;gt;&lt;/code> API，&lt;code>Span&amp;lt;byte&amp;gt;&lt;/code> 是一个 &lt;code>ref struct&lt;/code> 类型，因此我们&lt;a href="https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.2/span-safety.md">不能在异步方法中将 &lt;code>Span&amp;lt;byte&amp;gt;&lt;/code> 作为局部变量使用&lt;/a>。一个实用的办法是简单地分割代码，这样一个方法做 &lt;code>Span&amp;lt;byte&amp;gt;&lt;/code> 工作，一个方法做&lt;code>async&lt;/code>方面的工作。&lt;/p>
&lt;h3 id="发散一下异步代码同步热路径和异步机制开销">发散一下：异步代码、同步热路径和异步机制开销&lt;/h3>
&lt;p>&lt;code>async&lt;/code> / &lt;code>await&lt;/code> 中引入的机制非常棒，但是它仍然会是一个会产生惊人栈开销的工作——你可以从 &lt;a href="https://sharplab.io/#v2:D4AQDABCCMCsDcBYAUCkBmKAmCB5ArgE4DCA9gCYCmKA3ihAxAA6ECWAbgIYAulU0ANigAOCADVOAG3yUQAgDwAjUqUkA+CADFpAZwAWAQR0BPAHYBjABQAFVk0oB1Nr0IQA7s8qEAlPUZ1kRiCIAHoQiE4mJkljCEVOcwBrAFoWSh0dIj5KbnM/YIguVwAzXT0IAF4oAE53T0IAOm18fSMzK28kQILQ8N5JSQhuPT5zKUlWUwBzCHMKPjcR4a8I01iAW1JCPnX0nU4p9PzgsIh9UnxJcjiF515TY6CQAHYIAEJLUpa9BoBJHWInAslEklGuwGAEC++j+ANI62iOTBnWOAF8UOjUFjTjomCpimCoVshiMIJQAB6cBGglCTFymKTYCC2exOVguWjHDDiKQyOTyZr6ABK6Uu3A0gsMJgslm8lQ0VGKnDFXUxOm4hHw5m4WjKIsykm4nO6DG5ylUEH+gOBoOuFQVlCVKq5mHNgyt8MRvDtDqdhtVQA=">sharplab.io&lt;/a> 中看到——看看&lt;code>OurCode.FlushAsync&lt;/code> 中生成的机制——和整个 &lt;code>struct &amp;lt;FlushAsync&amp;gt;d__0&lt;/code>。现在，这些代码并&lt;em>不是很糟糕&lt;/em>——它非常努力地尝试在同步路径上避免内存分配——但是&lt;em>没有必要&lt;/em>。&lt;/p>
&lt;p>这里有两种方法可以显著地改善它；一个是压根不去 &lt;code>await&lt;/code> ，通常如果 &lt;code>await&lt;/code> 是在方法中地最后一行并且&lt;strong>我们不需要去处理结果&lt;/strong>：不去 &lt;code>await&lt;/code> ——只要去除&lt;code>async&lt;/code>然后&lt;code>return&lt;/code>这个task——完成或者未完成。在这里我们没办法这样做，因为我们需要去检查返回的状态，但是我们可以通过检查这个task是否&lt;em>已经完成&lt;/em>来对成功的结果进行优化（通过 &lt;code>.IsCompletedSuccessfully&lt;/code> ——如果它已经结束但是有错误，我们仍然需要使用&lt;code>await&lt;/code>来让异常可以正确表现出来）。如果它&lt;em>是&lt;/em>成功完成的，我们可以请求到&lt;code>.Result&lt;/code>。所以我们&lt;em>也&lt;/em>可以将&lt;code>FlushAsync&lt;/code> 写成这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">private&lt;/span> &lt;span style="color:#728e00">static&lt;/span> &lt;span style="color:#434f54">ValueTask&lt;/span>&amp;lt;&lt;span style="color:#00979d">bool&lt;/span>&amp;gt; &lt;span style="color:#434f54">Flush&lt;/span>(&lt;span style="color:#434f54">PipeWriter&lt;/span> &lt;span style="color:#434f54">writer&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">bool&lt;/span> &lt;span style="color:#434f54">GetResult&lt;/span>(&lt;span style="color:#434f54">FlushResult&lt;/span> &lt;span style="color:#434f54">flush&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// tell the calling code whether any more messages&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// should be written&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> =&amp;gt; !(&lt;span style="color:#434f54">flush&lt;/span>.&lt;span style="color:#434f54">IsCanceled&lt;/span> || &lt;span style="color:#434f54">flush&lt;/span>.&lt;span style="color:#434f54">IsCompleted&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">async&lt;/span> &lt;span style="color:#434f54">ValueTask&lt;/span>&amp;lt;&lt;span style="color:#00979d">bool&lt;/span>&amp;gt; &lt;span style="color:#434f54">Awaited&lt;/span>(&lt;span style="color:#434f54">ValueTask&lt;/span>&amp;lt;&lt;span style="color:#434f54">FlushResult&lt;/span>&amp;gt; &lt;span style="color:#434f54">incomplete&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> =&amp;gt; &lt;span style="color:#434f54">GetResult&lt;/span>(&lt;span style="color:#728e00">await&lt;/span> &lt;span style="color:#434f54">incomplete&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// apply back-pressure etc&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">flushTask&lt;/span> = &lt;span style="color:#434f54">writer&lt;/span>.&lt;span style="color:#434f54">FlushAsync&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">return&lt;/span> &lt;span style="color:#434f54">flushTask&lt;/span>.&lt;span style="color:#434f54">IsCompletedSuccessfully&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ? &lt;span style="color:#728e00">new&lt;/span> &lt;span style="color:#434f54">ValueTask&lt;/span>&amp;lt;&lt;span style="color:#00979d">bool&lt;/span>&amp;gt;(&lt;span style="color:#434f54">GetResult&lt;/span>(&lt;span style="color:#434f54">flushTask&lt;/span>.&lt;span style="color:#434f54">Result&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : &lt;span style="color:#434f54">Awaited&lt;/span>(&lt;span style="color:#434f54">flushTask&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这在大多数情况（同步完成）下&lt;em>完全避免&lt;/em>了&lt;code>async&lt;/code>/&lt;code>await&lt;/code> 机制——如我们再次在 &lt;a href="https://sharplab.io/#v2:D4AQDABCCMCsDcBYAUCkBmKAmCB5ArgE4DCA9gCYCmKA3ihAxAA6ECWAbgIYAulU0ANggA1TgBt8lEAIA8AI1KkxAPggAxCQGcAFgAoACqyaUA6m16EIAd3OVCASnqM6yRm4gKlEAOKVuAJUpNfDFuXQ18HUDg0IgAMy1tR1d3VIB6NIheMTEs7T4AY3ExVgA7AHMIAoo+K3zufMtOUoBPCABbUkI+dqDNTnKgp1S3DIgdUhDyD1rzXlLhkYYAXlUAQl0EyO0AOgBJTWJmgsoxSmngYHjE/cPSdqYz3nJ7JFQU1JAADhFxSWl5IoVBAAIJWTisZ66UQSKSyCJRIIhbiqMrVB5PSjJJZuVY+PzRZG6EAATggaPujz8WLei1GmU4TEebTknAKAGsALQsPpEPh+Ap0xhcSxbHTSCDLay2Qg7BHaEGaFqlAq6V4oIUMEAAdmu22ktzIGOp5AAyvgCidNJo4iExC1Ne4APwQUqUKy/WEAzwqXS+AJI0KbRIGwmhezYnEMABcoPBkPOwf1AnVHwgAF8UJn3igxpomIo4ud4l08vyAB6cY0oMoWUribAQQzGMwJwi0RYYT3/eGJMMo9SJRXK1X2SWqKhxTjIt7ZzTcQgW7iD7b9jtprs+iAHI4q07FvGT6ehN5uTdA7d3Y3PccQI8zrNAA=">sharplab.io&lt;/a>中看到的一样。我要强调：如果代码是经常（或仅仅）进行&lt;em>真正的异步行为&lt;/em>时，这样做是完全没有必要的；它&lt;em>只&lt;/em>对于那些结果通常（或仅仅）会同步地产生时才有帮助。&lt;/p>
&lt;p>(译注：对于&lt;code>ValueTask&lt;/code>的&amp;quot;hot path&amp;quot;场景的使用，这里有个视频讲过一些，以及其它一些.NET中新的优化性能的方法： &lt;a href="https://www.youtube.com/watch?v=dVKUYP_YALg">Adam Sitnik - State of the .NET Performance&lt;/a>)&lt;/p>
&lt;h3 id="那么reader呢">那么Reader呢？&lt;/h3>
&lt;p>就像我们多次看到的一样，reader总是稍微复杂一些——我们无从得知一个单独的“读”操作是否会准确包含一个入站消息，我们也许需要开启循环直到我们获取到了所有所需的数据，并且我们也许需要推回一些&lt;em>额外的&lt;/em>数据。因此，让我们假设我们想要消费某种单一的消息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">async&lt;/span> &lt;span style="color:#434f54">ValueTask&lt;/span>&amp;lt;&lt;span style="color:#434f54">SomeMessageType&lt;/span>&amp;gt; &lt;span style="color:#434f54">GetNextMessage&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">PipeReader&lt;/span> &lt;span style="color:#434f54">reader&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">CancellationToken&lt;/span> &lt;span style="color:#434f54">cancellationToken&lt;/span> = &lt;span style="color:#728e00">default&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">while&lt;/span> (&lt;span style="color:#00979d">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">read&lt;/span> = &lt;span style="color:#728e00">await&lt;/span> &lt;span style="color:#434f54">reader&lt;/span>.&lt;span style="color:#434f54">ReadAsync&lt;/span>(&lt;span style="color:#434f54">cancellationToken&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">if&lt;/span> (&lt;span style="color:#434f54">read&lt;/span>.&lt;span style="color:#434f54">IsCanceled&lt;/span>) &lt;span style="color:#434f54">ThrowCanceled&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// can we find a complete frame?&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">buffer&lt;/span> = &lt;span style="color:#434f54">read&lt;/span>.&lt;span style="color:#434f54">Buffer&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">if&lt;/span> (&lt;span style="color:#434f54">TryParseFrame&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">buffer&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">out&lt;/span> &lt;span style="color:#434f54">SomeMessageType&lt;/span> &lt;span style="color:#434f54">nextMessage&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">out&lt;/span> &lt;span style="color:#434f54">SequencePosition&lt;/span> &lt;span style="color:#434f54">consumedTo&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">reader&lt;/span>.&lt;span style="color:#434f54">AdvanceTo&lt;/span>(&lt;span style="color:#434f54">consumedTo&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">return&lt;/span> &lt;span style="color:#434f54">nextMessage&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">reader&lt;/span>.&lt;span style="color:#434f54">AdvanceTo&lt;/span>(&lt;span style="color:#434f54">buffer&lt;/span>.&lt;span style="color:#434f54">Start&lt;/span>, &lt;span style="color:#434f54">buffer&lt;/span>.&lt;span style="color:#434f54">End&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">if&lt;/span> (&lt;span style="color:#434f54">read&lt;/span>.&lt;span style="color:#434f54">IsCompleted&lt;/span>) &lt;span style="color:#434f54">ThrowEOF&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里我们从pipe中获取了&lt;em>一些&lt;/em>数据，进行退出检查（比如取消）。然后我们&lt;em>尝试寻找一个消息&lt;/em>，这是什么意思取决于你具体的代码——它可以是：&lt;/p>
&lt;ul>
&lt;li>从缓冲区中寻找某些特定的值，比如一个ASCII行尾，然后把所有到这里的数据当作一个消息（丢弃行尾）&lt;/li>
&lt;li>解析一个定义良好的二进制帧头，获取其内容长度，通过检查获取这样长度的数据然后处理&lt;/li>
&lt;li>或者其它你需要的！&lt;/li>
&lt;/ul>
&lt;p>如果我们&lt;em>能够&lt;/em>获取到一个消息，我们可以告诉pipe令其丢弃我们已经消费过的数据——通过 &lt;code>AdvanceTo(consumedTo)&lt;/code>，在这里使用我们自己的帧解析代码告诉我们消费了多少。如果我们&lt;em>没能&lt;/em>获取一个消息，我们要做的第一件事就是告诉pipe我们什么也没消费，尽管我们尝试读取了所有数据——通过 &lt;code>reader.AdvanceTo(buffer.Start, buffer.End)&lt;/code>。在这里，会有两种可能：&lt;/p>
&lt;ul>
&lt;li>我们还没有获得足够的数据&lt;/li>
&lt;li>pipe已经死亡，我们&lt;em>再也不会&lt;/em>获得足够的数据&lt;/li>
&lt;/ul>
&lt;p>我们在通过 &lt;code>read.IsCompleted&lt;/code> 检查了这些，在第二种情况时报告错误；否则我们继续循环，等待更多数据。那么剩下的，就是我们的帧解析——我们已经把复杂的IO管理降低成了简单的操作；比如，如果我们的消息是以行标记分隔：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">private&lt;/span> &lt;span style="color:#728e00">static&lt;/span> &lt;span style="color:#00979d">bool&lt;/span> &lt;span style="color:#434f54">TryParseFrame&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">ReadOnlySequence&lt;/span>&amp;lt;&lt;span style="color:#00979d">byte&lt;/span>&amp;gt; &lt;span style="color:#434f54">buffer&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">out&lt;/span> &lt;span style="color:#434f54">SomeMessageType&lt;/span> &lt;span style="color:#434f54">nextMessage&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">out&lt;/span> &lt;span style="color:#434f54">SequencePosition&lt;/span> &lt;span style="color:#434f54">consumedTo&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// find the end-of-line marker&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">eol&lt;/span> = &lt;span style="color:#434f54">buffer&lt;/span>.&lt;span style="color:#434f54">PositionOf&lt;/span>((&lt;span style="color:#00979d">byte&lt;/span>)&lt;span style="color:#7f8c8d">&amp;#39;\n&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">if&lt;/span> (&lt;span style="color:#434f54">eol&lt;/span> == &lt;span style="color:#00979d">null&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">nextMessage&lt;/span> = &lt;span style="color:#728e00">default&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">consumedTo&lt;/span> = &lt;span style="color:#728e00">default&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">return&lt;/span> &lt;span style="color:#00979d">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// read past the line-ending&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">consumedTo&lt;/span> = &lt;span style="color:#434f54">buffer&lt;/span>.&lt;span style="color:#434f54">GetPosition&lt;/span>(&lt;span style="color:#8a7b52">1&lt;/span>, &lt;span style="color:#434f54">eol&lt;/span>.&lt;span style="color:#434f54">Value&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// consume the data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">var&lt;/span> &lt;span style="color:#434f54">payload&lt;/span> = &lt;span style="color:#434f54">buffer&lt;/span>.&lt;span style="color:#434f54">Slice&lt;/span>(&lt;span style="color:#8a7b52">0&lt;/span>, &lt;span style="color:#434f54">eol&lt;/span>.&lt;span style="color:#434f54">Value&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">nextMessage&lt;/span> = &lt;span style="color:#434f54">ReadSomeMessageType&lt;/span>(&lt;span style="color:#434f54">payload&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">return&lt;/span> &lt;span style="color:#00979d">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里&lt;code>PositionOf&lt;/code> 尝试获取第一个行标记的位置。如果一个也找不到，我们就放弃，否则我们将&lt;code>consumedTo&lt;/code> 设为”行标记+1“（即我们会消费行标记），然后我们分割我们的缓冲区来创建一个子集，表示&lt;em>不包括&lt;/em>行标记的内容，这样我们就可以解析了。最终，我们报告成功，并且庆祝我们可以简单地解析Linux风格的行尾。&lt;/p>
&lt;h3 id="这里的重点是什么">这里的重点是什么？&lt;/h3>
&lt;p>用这些&lt;em>和大多数最简单最简朴的&lt;code>Stream&lt;/code>版本（没有任何nice的特性）非常相似&lt;/em>的最少量的代码，我们的应用现在有了一个reader和writer，利用广泛的能力确保高效和有效的处理。你可以用&lt;code>Stream&lt;/code>&lt;em>来做所有的这些事&lt;/em>，但是这样&lt;em>真的、真的很难&lt;/em>去做好做可靠。通过将所有的这些特性集成进框架，许多代码都可以受益于这一单独的实现。并且它也给了那些直接在pipeline API上开发并且对自定义pipeline端点和修饰感兴趣的人更多的未来空间。&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>在这节，我们研究了pipeline使用的内存模型和其如何帮助我们避免分配内存，然后我们研究了怎样才可以将pipeline与现有的API和系统（如&lt;code>Stream&lt;/code>）进行交互——并且我们介绍了 &lt;code>Pipelines.Sockets.Unofficial&lt;/code> 这样的可用的工具库。我们研究了在不支持 span/memory 代码的API上集成它们的可用选项，最终我们展示了和pipeline交互的&lt;em>真正的调用代码&lt;/em>是什么样子的（并且简单地介绍了如何优化那些通常是同步的&lt;code>async&lt;/code>代码）——展示了我们的&lt;em>应用代码&lt;/em>会是什么样子。在最后一部分，我们将会研究如何在开发现实中的库，比如&lt;code>StackExchange.Redis时&lt;/code>，将我们学到的这些知识点联系起来——讨论我们在代码里需要解决哪些复杂点，而pipeline又如何将它们变得简单。&lt;/p></description></item><item><title>Pipelines - .NET中的新IO API指引(一)</title><link>http://suraciii.github.io/posts/trans-pipelines-marcgravell-1/</link><pubDate>Sun, 01 Jul 2018 00:00:00 +0000</pubDate><guid>http://suraciii.github.io/posts/trans-pipelines-marcgravell-1/</guid><description>&lt;p>原文：&lt;a href="https://blog.marcgravell.com/2018/07/pipe-dreams-part-1.html">Pipelines - a guided tour of the new IO API in .NET, part 1&lt;/a>&lt;/p>
&lt;p>作者：marcgravell&lt;/p>
&lt;p>大约两年前，我发表了一篇&lt;a href="https://blog.marcgravell.com/2016/09/channelling-my-inner-geek.html">关于.NET中即将到来的体验性新IO API&lt;/a>的博文——在那时它被叫做&amp;quot;Channels&amp;quot;；在2018年的五月末，它终于在&lt;a href="https://www.nuget.org/packages/System.IO.Pipelines/">System.IO.Pipelines&lt;/a>命名空间中落地，我对这系列API巨感兴趣，而在几个星期前，我被分配去用&amp;quot;Pipelines&amp;quot;改造&lt;code>StackExchange.Redis&lt;/code>以&lt;a href="https://github.com/StackExchange/StackExchange.Redis/issues/871">作为我们2.0更新的一部分&lt;/a>&lt;/p>
&lt;p>我希望在这个系列可以讨论：&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;Pipelines&amp;quot;是什么&lt;/li>
&lt;li>如何在代码方面使用它们&lt;/li>
&lt;li>什么时候你也许会想要使用它们&lt;/li>
&lt;/ul>
&lt;p>为了表达地更具体，在介绍完&amp;quot;Pipelines&amp;quot;后，我打算大篇幅地讲解StackExchange.Redis中的相关转换，并且作为讨论在不同场景下它分别解决了哪些问题的一部分。简略地说：在几乎所有的情况下，答案可以概括为：&lt;/p>
&lt;p>&lt;em>它非常适合那些在IO代码中复杂却普遍的痛点；使我们可以替换掉那些丑陋的封装(kludge)、变通(workaround)或妥协(compromise)——用一个在框架中设计优雅的专门的解决方案。&lt;/em>&lt;/p>
&lt;p>我敢肯定，我下面所覆盖的那些痛点，对于那些工作在&amp;quot;数据协议(data protocol)&amp;ldquo;层面的人来说，一定非常熟悉。&lt;/p>
&lt;h3 id="pipelines替代完善了什么">Pipelines替代/完善了什么？&lt;/h3>
&lt;p>首先：现有框架中最接近Pipelines的是什么？很简单，Stream ,Stream API对于那些做过序列化或是数据协议工作的人来说非常熟悉，但是，Stream其实是一个非常模糊的API——它在不同的场景表现地非常不同：&lt;/p>
&lt;ul>
&lt;li>一些Stream是只读的，一些是只写的，一些是读/写的&lt;/li>
&lt;li>一样的实体类型有时候是只读的，而有时是只写的（比如&lt;code>DeflateStream&lt;/code>)&lt;/li>
&lt;li>当一个Stream是读/写时，它像是一个磁带，读写操作全作用于同样的下层数据（&lt;code>FileStream&lt;/code>,&lt;code>MemoryStream&lt;/code>) ，而有时它像是两个不同的Stream，读写作用于本质上完全不同的两个Stream(&lt;code>NetworkStream&lt;/code>, &lt;code>SslStream&lt;/code>)——即duplex stream&lt;/li>
&lt;li>在许多deplex(双工)场景下，很难甚至根本不可能表达“之后没有新数据会到来，但是你应该继续读取数据直到结束“——只有&lt;code>Close()&lt;/code>，而它会将deplex的两部分同时关闭&lt;/li>
&lt;li>有时Stream会是可探查的(Seekable)并且支持&lt;code>Position&lt;/code>和&lt;code>Length&lt;/code>的概念，不过大多数不会&lt;/li>
&lt;li>由于API随着时间的推移，通常会有多种方法来表达同一种操作——比如，我们可以用Read(同步)，BeginRead/EndRead(IAsyncResult模式的异步)，或者ReadAsync(async/await模式的异步)；在多数情况下，调用代码无从得知到底哪种方法才是推荐的/最佳的API&lt;/li>
&lt;li>如果你使用任何一种异步API，通常很难清楚分辨它的线程模型是什么；它实质上是同步的吗？如果不是，是哪个线程会回调？它用了同步上下文吗？线程池？IO complection-port线程？&lt;/li>
&lt;li>并且在最近，有了允许使用&lt;code>Span&amp;lt;byte&amp;gt;&lt;/code>/&lt;code>Memory&amp;lt;byte&amp;gt;&lt;/code>替换&lt;code>byte[]&lt;/code>的API——再一次的，调用者无法知道哪一种才是”更好的“API&lt;/li>
&lt;li>这种API本质上&lt;em>鼓励&lt;/em>复制数据；需要缓冲区？那是将数据复制到了另一块内存中，需要一个尚未处理的数据仓库？同样是复制了数据到另一块内存中&lt;/li>
&lt;/ul>
&lt;p>所以即使在我们开始讨论现实世界中的Stream例子和使用它们所导致的问题之前，很明显Stream API本身已经有了&lt;em>很多&lt;/em>问题，所以首先显而易见的是，Pipelines解决了这些混乱&lt;/p>
&lt;h3 id="什么是pipelines">什么是Pipelines&lt;/h3>
&lt;p>说起&amp;quot;Pipelines&amp;rdquo;，我指的是一组4个关键API，它们实现对一个二进制流解耦、重叠(overlapped)的读写访问，包括缓冲区管理(池化，回收)，线程感知，丰富的积压控制，和通过背压达到的溢出保护——所有这些都基于一个围绕非连续内存设计的 API，That&amp;rsquo;s a &lt;em>heck&lt;/em> of a word salad——但是不要担心，我会讨论每一个元素来解释我的意思。&lt;/p>
&lt;h3 id="从简单的开始对一个单独的管道进行写入和读取">从简单的开始：对一个单独的管道进行写入和读取&lt;/h3>
&lt;p>让我们先准备一个对等的Stream，然后写入一些简单的东西，然后再读取回来——坚持只使用Stream API。我们将只使用ASCII文本以便不用担心有任何复杂编码的状况，并且我们的读写代码不对下层数据流做任何假设。我们只是写入数据，并且读取到流的末尾从而消费它。&lt;/p>
&lt;p>我们将先用Stream来做这些——熟悉的领域，然后我们用Pipelines重新实现它，来看其中的相似和不同之处，在之后，我们将研究在其内部究竟发生了什么，然后我们就能明白为什么它会吸引我们&lt;/p>
&lt;p>也许你会说&amp;quot;啊，我想起来了&lt;code>TextReader&lt;/code>/&lt;code>TextWriter&lt;/code>&amp;quot;，我故意不去使用它们——因为我在这里是在尝试谈论Stream API，这样我们的例子可以扩展到广泛的数据协议和场景&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">using&lt;/span> (&lt;span style="color:#434f54">MemoryStream&lt;/span> &lt;span style="color:#434f54">ms&lt;/span> = &lt;span style="color:#728e00">new&lt;/span> &lt;span style="color:#434f54">MemoryStream&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// write something&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">WriteSomeData&lt;/span>(&lt;span style="color:#434f54">ms&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// rewind - MemoryStream works like a tape&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">ms&lt;/span>.&lt;span style="color:#434f54">Position&lt;/span> = &lt;span style="color:#8a7b52">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// consume it&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">ReadSomeData&lt;/span>(&lt;span style="color:#434f54">ms&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在，要写入Stream，调用方需要获取并填充一个缓冲区然后将其传递给Stream，此时我们为了简化它，使用同步的API，并且简单地分配一个byte数组&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">void&lt;/span> &lt;span style="color:#434f54">WriteSomeData&lt;/span>(&lt;span style="color:#434f54">Stream&lt;/span> &lt;span style="color:#434f54">stream&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">byte&lt;/span>[] &lt;span style="color:#434f54">bytes&lt;/span> = &lt;span style="color:#434f54">Encoding&lt;/span>.&lt;span style="color:#434f54">ASCII&lt;/span>.&lt;span style="color:#434f54">GetBytes&lt;/span>(&lt;span style="color:#7f8c8d">&amp;#34;hello, world!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">stream&lt;/span>.&lt;span style="color:#434f54">Write&lt;/span>(&lt;span style="color:#434f54">bytes&lt;/span>, &lt;span style="color:#8a7b52">0&lt;/span>, &lt;span style="color:#434f54">bytes&lt;/span>.&lt;span style="color:#434f54">Length&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">stream&lt;/span>.&lt;span style="color:#434f54">Flush&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：如果要提高效率地话，在上面的代码中有很多可以做的，但是这不是重点。所以如果你熟悉这类代码并且看着膈应，别慌，之后我们会让它变得更丑陋——呃，我是说更有效率&lt;/p>
&lt;p>读逻辑的代码会比写逻辑更复杂，因为读代码无法假定一次单独的调用就可以获得所有的数据，一个对Stream的读操作可能会什么也不返回(表明已经读到数据末尾)，也可能填满我们的缓冲区，或者只是返回了一个字节即使我们准备了一个巨大的缓冲区。所以Stream的读代码大多数会是一个循环：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">void&lt;/span> &lt;span style="color:#434f54">ReadSomeData&lt;/span>(&lt;span style="color:#434f54">Stream&lt;/span> &lt;span style="color:#434f54">stream&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">int&lt;/span> &lt;span style="color:#434f54">bytesRead&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// note that the caller usually can&amp;#39;t know much about&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// the size; .Length is not usually usable&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">byte&lt;/span>[] &lt;span style="color:#434f54">buffer&lt;/span> = &lt;span style="color:#728e00">new&lt;/span> &lt;span style="color:#00979d">byte&lt;/span>[&lt;span style="color:#8a7b52">256&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">bytesRead&lt;/span> = &lt;span style="color:#434f54">stream&lt;/span>.&lt;span style="color:#434f54">Read&lt;/span>(&lt;span style="color:#434f54">buffer&lt;/span>, &lt;span style="color:#8a7b52">0&lt;/span>, &lt;span style="color:#434f54">buffer&lt;/span>.&lt;span style="color:#434f54">Length&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">if&lt;/span> (&lt;span style="color:#434f54">bytesRead&lt;/span> &amp;gt; &lt;span style="color:#8a7b52">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { &lt;span style="color:#95a5a6">// note this only works for single-byte encodings&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">string&lt;/span> &lt;span style="color:#434f54">s&lt;/span> = &lt;span style="color:#434f54">Encoding&lt;/span>.&lt;span style="color:#434f54">ASCII&lt;/span>.&lt;span style="color:#434f54">GetString&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">buffer&lt;/span>, &lt;span style="color:#8a7b52">0&lt;/span>, &lt;span style="color:#434f54">bytesRead&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">Console&lt;/span>.&lt;span style="color:#434f54">Write&lt;/span>(&lt;span style="color:#434f54">s&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#728e00">while&lt;/span> (&lt;span style="color:#434f54">bytesRead&lt;/span> &amp;gt; &lt;span style="color:#8a7b52">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在我们将它翻译成pipelines，一个Pipe可以大略地比作一个&lt;code>MemoryStream&lt;/code>，除了不能多次倒带(rewind)，数据是一个简单的先进先出队列，我们有一个&lt;code>writer&lt;/code>API可以在一端推入数据，而一个&lt;code>reader&lt;/code>API可以在另一端将数据取出，Pipe就是坐在二这之中的一个缓冲区。让我们重现之前的场景，但是用一个Pipe替换掉&lt;code>MemoryStream&lt;/code>（同样，实践中我们通常不会这么做，但是易于举例）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">Pipe&lt;/span> &lt;span style="color:#434f54">pipe&lt;/span> = &lt;span style="color:#728e00">new&lt;/span> &lt;span style="color:#434f54">Pipe&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">// write something&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">await&lt;/span> &lt;span style="color:#434f54">WriteSomeDataAsync&lt;/span>(&lt;span style="color:#434f54">pipe&lt;/span>.&lt;span style="color:#434f54">Writer&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">// signal that there won&amp;#39;t be anything else written&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">pipe&lt;/span>.&lt;span style="color:#434f54">Writer&lt;/span>.&lt;span style="color:#434f54">Complete&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#95a5a6">// consume it&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">await&lt;/span> &lt;span style="color:#434f54">ReadSomeDataAsync&lt;/span>(&lt;span style="color:#434f54">pipe&lt;/span>.&lt;span style="color:#434f54">Reader&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>首先我们用默认选项创造一个pipe，然后我们写入它。注意在Pipe中的IO操作通常都是异步的，所以我们需要await我们的两个帮助方法，同样注意，我们并没有将这个Pipe传入它们——和Stream不同，pipelines 对于读和写有着不同的API层面，所以我们将一个&lt;code>PipeWriter&lt;/code> 传入帮助方法用来写入数据，然后传入一个&lt;code>PipeReader&lt;/code>来读取数据，写入数据后，我们在&lt;code>PipeWriter&lt;/code>上调用&lt;code>Complete()&lt;/code>。我们不需要在&lt;code>MemoryStream&lt;/code>中做这个因为当它到达缓冲数据的末尾时会自动&lt;a href="https://en.wikipedia.org/wiki/End-of-file">EOFs&lt;/a>——但是在一些其它的Stream实现中——尤其是单向流——我们也许需要在写入数据后调用&lt;code>Close&lt;/code>&lt;/p>
&lt;p>好了，那么我们的&lt;code>WriteSomeDataAsync&lt;/code> 是什么呢？注意，我在下面的代码中故意多写了注释：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">async&lt;/span> &lt;span style="color:#434f54">ValueTask&lt;/span> &lt;span style="color:#434f54">WriteSomeDataAsync&lt;/span>(&lt;span style="color:#434f54">PipeWriter&lt;/span> &lt;span style="color:#434f54">writer&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// use an oversized size guess&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">Memory&lt;/span>&amp;lt;&lt;span style="color:#00979d">byte&lt;/span>&amp;gt; &lt;span style="color:#434f54">workspace&lt;/span> = &lt;span style="color:#434f54">writer&lt;/span>.&lt;span style="color:#434f54">GetMemory&lt;/span>(&lt;span style="color:#8a7b52">20&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// write the data to the workspace&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">int&lt;/span> &lt;span style="color:#434f54">bytes&lt;/span> = &lt;span style="color:#434f54">Encoding&lt;/span>.&lt;span style="color:#434f54">ASCII&lt;/span>.&lt;span style="color:#434f54">GetBytes&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#7f8c8d">&amp;#34;hello, world!&amp;#34;&lt;/span>, &lt;span style="color:#434f54">workspace&lt;/span>.&lt;span style="color:#434f54">Span&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// tell the pipe how much of the workspace&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// we actually want to commit&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">writer&lt;/span>.&lt;span style="color:#434f54">Advance&lt;/span>(&lt;span style="color:#434f54">bytes&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// this is **not** the same as Stream.Flush!&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">await&lt;/span> &lt;span style="color:#434f54">writer&lt;/span>.&lt;span style="color:#434f54">FlushAsync&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>首先要注意的是，在处理pipelines时：不是你控制缓冲区，而是Pipe，回想我们的Stream代码，读和写代码都创建了本地byte[]，但是在这里我们没有，相反，我们通过&lt;code>GetMemory&lt;/code> (或者它的孪生方法&lt;code>GetSpan&lt;/code>)向Pipe请求了一个缓冲区(&lt;code>workspace&lt;/code>)，就先你从名字中想到的那样，这给了我们一个&lt;code>Memory&amp;lt;byte&amp;gt;&lt;/code>或是一个&lt;code>Span&amp;lt;byte&amp;gt;&lt;/code> ——其容量为最少20字节&lt;/p>
&lt;p>获取这个缓冲区后，将我们的字符串编码进去，这意味着我们是直接写入Pipe的内存，并且记录下&lt;em>实际上&lt;/em>我们使用了多少字节，然后我们通过&lt;code>Advance&lt;/code>告诉Pipe，我们不受之前请求的20字节的限制——我们可以写入0，20，甚至50字节，最后一个看起来也许会令人意外，但是这实际上是被鼓励的！之前的重点是“至少”——writer可以时间上给我们一个比我们请求的大的很多的缓冲区。当处理较大的数据时，得陇望蜀是很常见的：请求一个我们能有效利用的最小空间，但是之后在检查提供给我们的memory/span的体积后，再决定最终实际写入多少。&lt;/p>
&lt;p>对&lt;code>Advance&lt;/code>的调用很重要，它意味着一次写操作的终结，使得Pipe中的数据可用从而被reader消费。对&lt;code>FlushAsync&lt;/code> 的调用同样重要，但是有微妙的区别，但是在我们可以充分地阐明这区别是什么前，我们需要先看一看reader。这是我们的&lt;code>ReadSomeDataAsync&lt;/code> 方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#728e00">async&lt;/span> &lt;span style="color:#434f54">ValueTask&lt;/span> &lt;span style="color:#434f54">ReadSomeDataAsync&lt;/span>(&lt;span style="color:#434f54">PipeReader&lt;/span> &lt;span style="color:#434f54">reader&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">while&lt;/span> (&lt;span style="color:#00979d">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// await some data being available&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">ReadResult&lt;/span> &lt;span style="color:#434f54">read&lt;/span> = &lt;span style="color:#728e00">await&lt;/span> &lt;span style="color:#434f54">reader&lt;/span>.&lt;span style="color:#434f54">ReadAsync&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">ReadOnlySequence&lt;/span>&amp;lt;&lt;span style="color:#00979d">byte&lt;/span>&amp;gt; &lt;span style="color:#434f54">buffer&lt;/span> = &lt;span style="color:#434f54">read&lt;/span>.&lt;span style="color:#434f54">Buffer&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// check whether we&amp;#39;ve reached the end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// and processed everything&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">if&lt;/span> (&lt;span style="color:#434f54">buffer&lt;/span>.&lt;span style="color:#434f54">IsEmpty&lt;/span> &amp;amp;&amp;amp; &lt;span style="color:#434f54">read&lt;/span>.&lt;span style="color:#434f54">IsCompleted&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">break&lt;/span>; &lt;span style="color:#95a5a6">// exit loop&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// process what we received&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#728e00">foreach&lt;/span> (&lt;span style="color:#434f54">Memory&lt;/span>&amp;lt;&lt;span style="color:#00979d">byte&lt;/span>&amp;gt; &lt;span style="color:#434f54">segment&lt;/span> &lt;span style="color:#728e00">in&lt;/span> &lt;span style="color:#434f54">buffer&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00979d">string&lt;/span> &lt;span style="color:#434f54">s&lt;/span> = &lt;span style="color:#434f54">Encoding&lt;/span>.&lt;span style="color:#434f54">ASCII&lt;/span>.&lt;span style="color:#434f54">GetString&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">segment&lt;/span>.&lt;span style="color:#434f54">Span&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">Console&lt;/span>.&lt;span style="color:#434f54">Write&lt;/span>(&lt;span style="color:#434f54">s&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#95a5a6">// tell the pipe that we used everything&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#434f54">reader&lt;/span>.&lt;span style="color:#434f54">AdvanceTo&lt;/span>(&lt;span style="color:#434f54">buffer&lt;/span>.&lt;span style="color:#434f54">End&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>就像Stream例子一样，我们有一个循环持续到我们读取到数据的末尾，在Stream中，这种情况通过&lt;code>Read&lt;/code>方法返回一个非正结果时判定，但是在pipeline中有两种检查方式：&lt;/p>
&lt;ul>
&lt;li>&lt;code>read.IsCompleted&lt;/code>告诉我们那个写pipe是否被通知完成，并且不会再有数据被写入(pipe.Writer.Complete();之前代码中的这句)&lt;/li>
&lt;li>&lt;code>buffer.IsEmpty&lt;/code>告诉我们&lt;em>在这次操作&lt;/em>中没有剩余的数据需要处理&lt;/li>
&lt;/ul>
&lt;p>如果pipe中不再有数据并且writer被通知complete，那么将永远不会有东西存在于这个pipe中，那我们就可以退出了&lt;/p>
&lt;p>如果我们有数据存在，我们可以查看缓冲区，所以首先——我们要谈谈缓冲；在代码中那是个新类型&lt;code>ReadOnlySequence&amp;lt;byte&amp;gt;&lt;/code>——这个概念结合了几个角色：&lt;/p>
&lt;ul>
&lt;li>描述不连续内存，特别是一个由0个，1个或多个&lt;code>ReadOnlyMemory&amp;lt;byte&amp;gt;&lt;/code>块组成的序列&lt;/li>
&lt;li>描述在这个数据流中的一个逻辑位置(&lt;code>SequencePosition&lt;/code>)—— in particular via &lt;code>buffer.Start&lt;/code> and &lt;code>buffer.End&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>非连续&lt;/code>在此非常重要，我们很快将看到这些数据实际上的去向，但在读方面：我们需要准备好处理可以跨多个部分传播的数据。在这里，我们通过简单的遍历缓冲区，轮流解码每一段数据来达到目的。请注意, 即使 API 被设计为可以描述多个非连续缓冲区, 但通常情况下, 接收到的数据在单个缓冲区中是连续的。在这种情况下, 通常可以为单个缓冲区编写优化的实现。你可以通过检查&lt;code>buffer.IsSingleSegment&lt;/code>和访问&lt;code>buffer.First&lt;/code>来做到。&lt;/p>
&lt;p>最终，我们调用&lt;code>AdvanceTo&lt;/code>，告诉Pipe我们实际上使用了多少数据。&lt;/p>
&lt;h3 id="关键点你无需取出你提供的所有数据">关键点：你无需取出你提供的所有数据&lt;/h3>
&lt;p>对比流：当你在Stream上调用Read时，它会将所有数据放到你给它的缓冲区中，在大多数现实场景中，并不是总是能及时消费掉所有的数据——maybe it only makes sense to consider &amp;ldquo;commands&amp;rdquo; as &amp;ldquo;entire text lines&amp;rdquo;,, and you haven&amp;rsquo;t yet seen a &lt;code>cr&lt;/code>/&lt;code>lf&lt;/code> in the data. 对于Stream来说，这点很坑——一旦数据给了你，就是你的问题了，如果你现在用不上它，那你就要在某处储备这段数据，但是对于Pipelines，你可以告诉它你消费过了。在我们的例子中，我们通过传递&lt;code>buffer.End&lt;/code>到&lt;code>AdvanceTo&lt;/code>来告诉它我们消费掉了之前提供的所有数据。这意味着我们将永远不会再见到这段数据，就像用Stream一样，但是，我们也可以传递&lt;code>buffer.Start&lt;/code>，意味着“我们什么都还没使用”——及时我们能够检查这段数据，它也依然会留存在pipe中以供后续读取。我们也可以获取缓冲区中任意的&lt;code>SequencePosition&lt;/code> 值——例如如果我们读取20字节——所以我们可以完全控制有多少数据被从pipe中丢弃。这里有两种方法取得&lt;code>SequencePosition&lt;/code> ：&lt;/p>
&lt;ul>
&lt;li>你可以就像&lt;code>Slice(...)&lt;/code>一个 &lt;code>Span&amp;lt;T&amp;gt;&lt;/code> o或者&lt;code>Memory&amp;lt;T&amp;gt;&lt;/code>一样&lt;code>Slice(...)&lt;/code>一个&lt;code>ReadOnlySequence&amp;lt;byte&amp;gt;&lt;/code> ——然后访问子集中的&lt;code>.Start&lt;/code>或&lt;code>.End&lt;/code>&lt;/li>
&lt;li>你可以使用&lt;code>ReadOnlySequence&amp;lt;byte&amp;gt;&lt;/code>中的&lt;code>.GetPosition(...)&lt;/code> 方法，它返回一个相关位置而&lt;em>无需&lt;/em>真正分割&lt;/li>
&lt;/ul>
&lt;p>更微妙的是：我们可以分别告诉它我们消费了一些数量，但是我们已检查了另一个不同的数量，这里最常见的例子是表达“你可以丢弃这么多——这些我做完了；但是我看完了所有的数据，我此时无法处理——我需要更多数据（you can drop &lt;em>this much&lt;/em> - I&amp;rsquo;m done with that; but I looked at everything, I can&amp;rsquo;t make any more progress at the moment - I need more data）”，具体来说：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#434f54">reader&lt;/span>.&lt;span style="color:#434f54">AdvanceTo&lt;/span>(&lt;span style="color:#434f54">consumedToPosition&lt;/span>, &lt;span style="color:#434f54">buffer&lt;/span>.&lt;span style="color:#434f54">End&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里正是&lt;code>PipeWriter.FlushAsync()&lt;/code>和&lt;code>PipeReader.ReadAsync()&lt;/code>微妙的相互作用出场的地方了，我之前跳过了&lt;code>PipeWriter.FlushAsync()&lt;/code>，它实际上在一次调用里提供了两个功能：&lt;/p>
&lt;ul>
&lt;li>如果存在一个&lt;code>ReadAsync&lt;/code> 调用，它会被注意到，因为它需要数据，然后它唤醒reader，使读取循环继续&lt;/li>
&lt;li>如果writer快过reader，比如pipe中充满了没有被reader清楚的数据，它会挂起writer(通过同步的not completing)——当pipe有了更多空间后，才会被重新激活(writer挂起/恢复的阈值可以在创建Pipe实例时被指定)&lt;/li>
&lt;/ul>
&lt;p>显然, 这些概念在我们的示例中没有发挥作用, 但它们是Pipelines工作原理的核心思想。将数据推送回pipe的能力极大地简化了大量 IO 场景。实际上, 我在有pipelines之前看到的每一个协议处理代码都有大量的代码与处理不完整数据的积压有关——它是这样一个重复的逻辑, 我非常高兴地看到它能在框架中被处理得很好。&lt;/p>
&lt;h3 id="唤醒或者说响应式指的是什么">“唤醒”或者说“响应式”指的是什么&lt;/h3>
&lt;p>你可能会注意到，我并没有真正定义我之前表达的意思，在表层上，我的意思是：对于&lt;code>ReadAsync&lt;/code> 或&lt;code>FlushAsync&lt;/code> 的一个await操作在其返回之前是未完成的，然后现在异步延续被产生，允许我们的async方法恢复执行，是，没错，不过这只是重新说明了 &lt;code>async&lt;/code>/&lt;code>await&lt;/code> 是什么意思。但是我debug的重点关注在于代码运行于哪个线程上——原因我会在之后的系列中讨论。所以说 &amp;ldquo;异步延续被产生 &amp;quot; 对我来说还不够。我想了解是谁在调用它, 就线程而言。最常见的答案是：&lt;/p>
&lt;ul>
&lt;li>它通过&lt;code>SynchronizationContext&lt;/code> 委托（注意：在许多系统中&lt;em>没有&lt;/em>&lt;code>SynchronizationContext&lt;/code> ）&lt;/li>
&lt;li>触发状态更改的线程会在状态更改时使用, 以产生延续&lt;/li>
&lt;li>全局线程池会被用来产生延续&lt;/li>
&lt;/ul>
&lt;p>在某些情况下，所有这些都可以是没问题的，而在某些情况下，所有这些都可能是糟糕的！同步上下文是一种完善的机制，可以从工作线程返回到主应用程序线程 (例外：桌面应用程序中的 UI 线程)。然而，它是没有必要的如果只是说我们完成了一个IO操作然后准备跳回一个应用线程；并且这么做会实际上将大量IO代码和数据处理代码转移到应用线程——这通常是我们想要避免的。并且，如果应用代码在异步调用时使用了&lt;code>Wait()&lt;/code>或&lt;code>.Result&lt;/code>会导致死锁（假设你不是故意的）。第二种选项（“内联”地在一个触发它的线程上执行回调）可能会有问题，因为它可以偷取你想要用来做别的事的线程（并且有可能导致死锁）；并且在某些极端情况下，当两个异步方法本质上作为协程运行时，可能会导致stack-dive（最终栈溢出）。最后一个选项 (全局线程池) 没有前两个的问题, 但在某些负载条件下可能会遇到严重问题——我将在本系列后面的部分讨论这一点。&lt;/p>
&lt;p>但是好消息是，pipelines在这里给了你控制权。当创建Pipe实例时，我们可以提供&lt;code>PipeScheduler&lt;/code> 实例给reader和writer（分别地）使用。&lt;code>PipeScheduler&lt;/code> 用来执行这些激活。如果没有制定，那么它默认受i按检查&lt;code>SynchronizationContext&lt;/code>，然后使用全局线程池使用“内联”延续（使用那个导致状态改变的线程）作为另一个可用选项。但是：&lt;em>你可以提供你对于&lt;code>PipeScheduler&lt;/code>自己的实现&lt;/em>，给予你对线程模型的完全控制。&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>所以：我们已经研究了什么是&lt;code>Pipe&lt;/code> ，和我们怎样才能用&lt;code>PipeWriter&lt;/code>写入一个pipe，和用&lt;code>PipeReader&lt;/code> 从pipe中读取——和怎样&amp;quot;advance&amp;quot;二者。我们已经研究了其于Stream的相似和差异，我们讨论了&lt;code>ReadAsync()&lt;/code>和 &lt;code>FlushAsync()&lt;/code> 怎样交互控制writer和reader的分片执行。我们研究了通过pipe提供所有缓冲区后，对缓冲区的责任怎样被反转——和pipe怎样简化了积压数据的管理。最终，我们讨论了激活对&lt;code>await&lt;/code>操作的延续进行激活的线程模型。&lt;/p>
&lt;p>这对于第一步来说可能已经足够了。在之后，我们将研究pipelines工作时的内存模型——比如数据存活在哪里。我们也将研究&lt;em>如何在现实场景中利用pipelines来开始做些有趣的东西&lt;/em>。&lt;/p></description></item></channel></rss>