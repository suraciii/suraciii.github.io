<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=http://suraciii.github.io/favicon.ico><link rel=stylesheet href=/css/style.min.css><title>在EF Core中使用拦截器实现自动软删除</title></head><body><header id=banner><h2><a href=http://suraciii.github.io/>The Dice Maker</a></h2><nav><ul></ul></nav></header><main id=content><article><header id=post-header><h1>在EF Core中使用拦截器实现自动软删除</h1><div><time>June 30, 2023</time></div></header><p>拦截器(Interceptor)是EF Core中的一种中间件形式的组件，可以用于在EF Core的工作流中注入用户代码，以进行拦截、修改一些特定的EF Core操作。</p><p>下面以实现软删除为例。</p><h2 id=ef-core中删除实体的流程>EF Core中删除实体的流程</h2><p>在EF Core中，通常所有对实体的写操作（增删改）都需要被追踪，EF Core通过对实体对象进行追踪，对比并记录其状态变更，从而生成相应的数据库SQL语句。</p><p>当我们调用<code>DbContext.Remove(entity001)</code>时，其内部逻辑为：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#95a5a6>// 获取此实体的入口（Entry），EntityEntry就像一个装着实体的瓶子，瓶子上贴着标签，表示着这个瓶子里的实体即将被同步到数据库中的变更</span>
</span></span><span style=display:flex><span><span style=color:#00979d>var</span> <span style=color:#434f54>entry</span> = <span style=color:#728e00>new</span> <span style=color:#434f54>EntityEntry</span>(<span style=color:#434f54>entity</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00979d>var</span> <span style=color:#434f54>initialState</span> = <span style=color:#434f54>entry</span>.<span style=color:#434f54>State</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#95a5a6>// 如果这是一个未被跟踪(Detached)的实体，则将实体的状态设置为已跟踪但没有发生变更(Unchanged)</span>
</span></span><span style=display:flex><span><span style=color:#728e00>if</span> (<span style=color:#434f54>initialState</span> == <span style=color:#434f54>EntityState</span>.<span style=color:#434f54>Detached</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#434f54>SetEntityState</span>(<span style=color:#434f54>entry</span>.<span style=color:#434f54>GetInfrastructure</span>(), <span style=color:#434f54>EntityState</span>.<span style=color:#434f54>Unchanged</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#95a5a6>// An Added entity does not yet exist in the database. If it is then marked as deleted there is</span>
</span></span><span style=display:flex><span><span style=color:#95a5a6>// nothing to delete because it was not yet inserted, so just make sure it doesn&#39;t get inserted.</span>
</span></span><span style=display:flex><span><span style=color:#95a5a6>// 如果此实体的初始状态为已添加(Added)，这意味着这个实体即将（但还没有）被插入到数据库中，此时只需要将其状态更改为`Detached`来保证这次数据插入不会发生即可</span>
</span></span><span style=display:flex><span><span style=color:#95a5a6>// 否则，则标记此实体状态为已删除(Deleted)，在稍后调用SaveChanges方法时，EF Core会生成并执行相应的删除语句</span>
</span></span><span style=display:flex><span><span style=color:#434f54>entry</span>.<span style=color:#434f54>State</span> =
</span></span><span style=display:flex><span>	<span style=color:#434f54>initialState</span> == <span style=color:#434f54>EntityState</span>.<span style=color:#434f54>Added</span>
</span></span><span style=display:flex><span>		? <span style=color:#434f54>EntityState</span>.<span style=color:#434f54>Detached</span>
</span></span><span style=display:flex><span>		: <span style=color:#434f54>EntityState</span>.<span style=color:#434f54>Deleted</span>;
</span></span></code></pre></div><h2 id=软删除>软删除</h2><p>通常，实现软删除是通过设置一个类似<code>IsDeleted</code>的字段，在删除实体时，将字段值更新为<code>true</code>，并在查询时，过滤掉所有<code>IsDeleted=true</code>的记录</p><p>这就需要对实体模型进行相关配置：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#728e00>public</span> <span style=color:#728e00>static</span> <span style=color:#434f54>EntityTypeBuilder</span>&lt;<span style=color:#434f54>TEntity</span>&gt; <span style=color:#434f54>EnableSoftDelete</span>&lt;<span style=color:#434f54>TEntity</span>&gt;(
</span></span><span style=display:flex><span>	<span style=color:#728e00>this</span> <span style=color:#434f54>EntityTypeBuilder</span>&lt;<span style=color:#434f54>TEntity</span>&gt; <span style=color:#434f54>builder</span>)
</span></span><span style=display:flex><span>	<span style=color:#728e00>where</span> <span style=color:#434f54>TEntity</span> : <span style=color:#728e00>class</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#95a5a6>// 添加一个注释，标志着此实体启用了软删除</span>
</span></span><span style=display:flex><span>	<span style=color:#434f54>builder</span>.<span style=color:#434f54>HasAnnotation</span>(<span style=color:#7f8c8d>&#34;soft_delete&#34;</span>, <span style=color:#00979d>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#95a5a6>// 添加相关字段</span>
</span></span><span style=display:flex><span>	<span style=color:#434f54>builder</span>.<span style=color:#434f54>Property</span>&lt;<span style=color:#00979d>bool?</span>&gt;(<span style=color:#7f8c8d>&#34;is_deleted&#34;</span>)
</span></span><span style=display:flex><span>		.<span style=color:#434f54>HasDefaultValue</span>(<span style=color:#00979d>false</span>);
</span></span><span style=display:flex><span>	<span style=color:#434f54>builder</span>.<span style=color:#434f54>HasIndex</span>(<span style=color:#7f8c8d>&#34;is_deleted&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#434f54>builder</span>.<span style=color:#434f54>Property</span>&lt;<span style=color:#434f54>DateTimeOffset</span>?&gt;(<span style=color:#7f8c8d>&#34;deleted_at&#34;</span>)
</span></span><span style=display:flex><span>		.<span style=color:#434f54>HasDefaultValue</span>(<span style=color:#00979d>null</span>);
</span></span><span style=display:flex><span>	<span style=color:#434f54>builder</span>.<span style=color:#434f54>Property</span>&lt;<span style=color:#00979d>string?</span>&gt;(<span style=color:#7f8c8d>&#34;deleted_by&#34;</span>)
</span></span><span style=display:flex><span>		.<span style=color:#434f54>HasDefaultValue</span>(<span style=color:#00979d>null</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#95a5a6>// 配置查询过滤器，在查询时，使其忽略所有is_deleted字段值为true的记录</span>
</span></span><span style=display:flex><span>	<span style=color:#434f54>builder</span>.<span style=color:#434f54>HasQueryFilter</span>(<span style=color:#434f54>x</span> =&gt; <span style=color:#434f54>EF</span>.<span style=color:#434f54>Property</span>&lt;<span style=color:#00979d>bool?</span>&gt;(<span style=color:#434f54>x</span>, <span style=color:#7f8c8d>&#34;is_deleted&#34;</span>) != <span style=color:#00979d>true</span>);
</span></span><span style=display:flex><span>	<span style=color:#728e00>return</span> <span style=color:#434f54>builder</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=使用interceptor拦截ef-core对实体的删除操作>使用Interceptor拦截EF Core对实体的删除操作</h2><p>创建一个<code>SoftDeleteInterceptor</code>，实现<code>ISaveChangesInterceptor</code>接口：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#728e00>public</span> <span style=color:#728e00>class</span> <span style=color:#434f54>SoftDeleteInterceptor</span> : <span style=color:#434f54>ISaveChangesInterceptor</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#728e00>public</span> <span style=color:#434f54>ValueTask</span>&lt;<span style=color:#00979d>int</span>&gt; <span style=color:#434f54>SavedChangesAsync</span>(<span style=color:#434f54>SaveChangesCompletedEventData</span> <span style=color:#434f54>eventData</span>, <span style=color:#00979d>int</span> <span style=color:#434f54>result</span>, <span style=color:#434f54>CancellationToken</span> <span style=color:#434f54>cancellationToken</span> = <span style=color:#728e00>default</span>) { }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#728e00>public</span> <span style=color:#434f54>ValueTask</span>&lt;<span style=color:#434f54>InterceptionResult</span>&lt;<span style=color:#00979d>int</span>&gt;&gt; <span style=color:#434f54>SavingChangesAsync</span>(
</span></span><span style=display:flex><span>        <span style=color:#434f54>DbContextEventData</span> <span style=color:#434f54>eventData</span>,
</span></span><span style=display:flex><span>        <span style=color:#434f54>InterceptionResult</span>&lt;<span style=color:#00979d>int</span>&gt; <span style=color:#434f54>result</span>,
</span></span><span style=display:flex><span>        <span style=color:#434f54>CancellationToken</span> <span style=color:#434f54>cancellationToken</span> = <span style=color:#728e00>default</span>) { }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#728e00>#if</span> <span style=color:#434f54>NET6_0</span>
</span></span><span style=display:flex><span>    <span style=color:#728e00>public</span> <span style=color:#434f54>InterceptionResult</span>&lt;<span style=color:#00979d>int</span>&gt; <span style=color:#434f54>SavingChanges</span>(<span style=color:#434f54>DbContextEventData</span> <span style=color:#434f54>eventData</span>, <span style=color:#434f54>InterceptionResult</span>&lt;<span style=color:#00979d>int</span>&gt; <span style=color:#434f54>result</span>) =&gt; <span style=color:#434f54>result</span>;
</span></span><span style=display:flex><span>    <span style=color:#728e00>public</span> <span style=color:#00979d>int</span> <span style=color:#434f54>SavedChanges</span>(<span style=color:#434f54>SaveChangesCompletedEventData</span> <span style=color:#434f54>eventData</span>, <span style=color:#00979d>int</span> <span style=color:#434f54>result</span>) =&gt; <span style=color:#434f54>result</span>;
</span></span><span style=display:flex><span>    <span style=color:#728e00>public</span> <span style=color:#728e00>void</span> <span style=color:#434f54>SaveChangesFailed</span>(<span style=color:#434f54>DbContextErrorEventData</span> <span style=color:#434f54>eventData</span>) { }
</span></span><span style=display:flex><span>    <span style=color:#728e00>public</span> <span style=color:#434f54>Task</span> <span style=color:#434f54>SaveChangesFailedAsync</span>(<span style=color:#434f54>DbContextErrorEventData</span> <span style=color:#434f54>eventData</span>, <span style=color:#434f54>CancellationToken</span> <span style=color:#434f54>cancellationToken</span> = <span style=color:#728e00>default</span>) =&gt; <span style=color:#434f54>Task</span>.<span style=color:#434f54>CompletedTask</span>;
</span></span><span style=display:flex><span><span style=color:#728e00>#endif</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>ISaveChangesInterceptor</code>用于拦截EF Core的<code>SaveChanges</code>行为，其中<code>SavingChanges</code>会在<code>SaveChanges</code>操作之前触发，<code>SavedChanges</code>会在<code>SaveChanges</code>成功后触发，而<code>SaveChangesFailed</code>会在<code>SaveChanges</code>失败后触发</p><p>这里我们只需要实现<code>SavingChangesAsync</code>和<code>SaveChangesFailedAsync</code>即可（以及它们对应的同步方法，这里忽略了）</p><p>在<code>SavingChangesAsync</code>中，我们需要将EF Core的删除操作拦截，改为更新操作：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#728e00>public</span> <span style=color:#434f54>ValueTask</span>&lt;<span style=color:#434f54>InterceptionResult</span>&lt;<span style=color:#00979d>int</span>&gt;&gt; <span style=color:#434f54>SavingChangesAsync</span>(
</span></span><span style=display:flex><span>	<span style=color:#434f54>DbContextEventData</span> <span style=color:#434f54>eventData</span>,
</span></span><span style=display:flex><span>	<span style=color:#434f54>InterceptionResult</span>&lt;<span style=color:#00979d>int</span>&gt; <span style=color:#434f54>result</span>,
</span></span><span style=display:flex><span>	<span style=color:#434f54>CancellationToken</span> <span style=color:#434f54>cancellationToken</span> = <span style=color:#728e00>default</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#00979d>var</span> <span style=color:#434f54>context</span> = <span style=color:#434f54>eventData</span>.<span style=color:#434f54>Context</span>!;
</span></span><span style=display:flex><span>	<span style=color:#95a5a6>// 获取所有状态为`Deleted`并被标记为软删除的实体</span>
</span></span><span style=display:flex><span>	<span style=color:#00979d>var</span> <span style=color:#434f54>deletedEntities</span> = <span style=color:#434f54>context</span>.<span style=color:#434f54>ChangeTracker</span>.<span style=color:#434f54>Entries</span>().<span style=color:#434f54>Where</span>(<span style=color:#434f54>entry</span> =&gt; <span style=color:#434f54>entry</span>.<span style=color:#434f54>State</span> == <span style=color:#434f54>EntityState</span>.<span style=color:#434f54>Deleted</span> &amp;&amp; <span style=color:#434f54>entry</span>.<span style=color:#434f54>Metadata</span>.<span style=color:#434f54>FindAnnotation</span>(<span style=color:#434f54>Annotations</span>.<span style=color:#434f54>SoftDelete</span>) <span style=color:#728e00>is</span> <span style=color:#434f54>not</span> <span style=color:#00979d>null</span>);
</span></span><span style=display:flex><span>	<span style=color:#728e00>foreach</span> (<span style=color:#00979d>var</span> <span style=color:#434f54>entry</span> <span style=color:#728e00>in</span> <span style=color:#434f54>deletedEntities</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#95a5a6>// 将实体状态改为Modified，稍后EF Core则会因此对此实体生成并执行更新语句</span>
</span></span><span style=display:flex><span>		<span style=color:#434f54>entry</span>.<span style=color:#434f54>State</span> = <span style=color:#434f54>EntityState</span>.<span style=color:#434f54>Modified</span>;
</span></span><span style=display:flex><span>        <span style=color:#434f54>entry</span>.<span style=color:#434f54>CurrentValues</span>[<span style=color:#434f54>PropertyNames</span>.<span style=color:#434f54>IsDeleted</span>] = <span style=color:#00979d>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#434f54>entry</span>.<span style=color:#434f54>CurrentValues</span>[<span style=color:#434f54>PropertyNames</span>.<span style=color:#434f54>DeletedAt</span>] = <span style=color:#434f54>DateTimeOffset</span>.<span style=color:#434f54>UtcNow</span>;
</span></span><span style=display:flex><span>        <span style=color:#434f54>entry</span>.<span style=color:#434f54>CurrentValues</span>[<span style=color:#434f54>PropertyNames</span>.<span style=color:#434f54>DeletedBy</span>] = <span style=color:#434f54>GetOperator</span>();
</span></span><span style=display:flex><span>		<span style=color:#95a5a6>// 添加一个运行时注释，记录此实体已被软删除</span>
</span></span><span style=display:flex><span>        <span style=color:#434f54>entry</span>.<span style=color:#434f54>Metadata</span>.<span style=color:#434f54>AddRuntimeAnnotation</span>(<span style=color:#434f54>Annotations</span>.<span style=color:#434f54>HasSoftDeleted</span>, <span style=color:#00979d>null</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#728e00>return</span> <span style=color:#434f54>ValueTask</span>.<span style=color:#434f54>FromResult</span>(<span style=color:#434f54>result</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在<code>SavedChangesAsync</code>中，找到被软删除后的实体，将其状态同步为<code>Detached</code>，来保证其一致：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#00979d>var</span> <span style=color:#434f54>softDeletedEntries</span> = <span style=color:#434f54>eventData</span>.<span style=color:#434f54>Context</span>!.<span style=color:#434f54>ChangeTracker</span>.<span style=color:#434f54>Entries</span>().<span style=color:#434f54>Where</span>(<span style=color:#434f54>entry</span> =&gt; <span style=color:#434f54>entry</span>.<span style=color:#434f54>Metadata</span>.<span style=color:#434f54>FindRuntimeAnnotation</span>(<span style=color:#434f54>Annotations</span>.<span style=color:#434f54>HasSoftDeleted</span>) != <span style=color:#00979d>null</span>);
</span></span><span style=display:flex><span><span style=color:#728e00>foreach</span> (<span style=color:#00979d>var</span> <span style=color:#434f54>entries</span> <span style=color:#728e00>in</span> <span style=color:#434f54>softDeletedEntries</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#434f54>entries</span>.<span style=color:#434f54>State</span> = <span style=color:#434f54>EntityState</span>.<span style=color:#434f54>Detached</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#728e00>return</span> <span style=color:#434f54>ValueTask</span>.<span style=color:#434f54>FromResult</span>(<span style=color:#434f54>result</span>);
</span></span></code></pre></div><h3 id=启用软删除拦截器>启用软删除拦截器</h3><p>通常通过覆写<code>DbContext.OnConfiguring</code>方法来启用拦截器：</p><pre tabindex=0><code>public class MyContext : DbContext
{
    private readonly SoftDeleteInterceptor _softDeleteInterceptor = new SoftDeleteInterceptor();

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        =&gt; optionsBuilder
            .AddInterceptors(_softDeleteInterceptor)
}
</code></pre><p>拦截器启用后，即可将EF Core的删除操作拦截修改为更新操作，实现软删除
可以通过不适用过滤器的查询来进行验证：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#00979d>var</span> <span style=color:#434f54>deleted</span> = <span style=color:#728e00>await</span> <span style=color:#434f54>dbContext</span>.<span style=color:#434f54>Set</span>&lt;<span style=color:#434f54>MyEntity</span>&gt;().<span style=color:#434f54>IgnoreQueryFilters</span>().<span style=color:#434f54>FirstOrDefaultAsync</span>();
</span></span><span style=display:flex><span><span style=color:#434f54>deleted</span>.<span style=color:#434f54>Should</span>().<span style=color:#434f54>NotBeNull</span>();
</span></span></code></pre></div><h2 id=缺陷>缺陷</h2><p>这种方案还有着一些缺陷，比如：</p><ol><li>无法对引用实体进行级联的软删除</li><li>无法“硬”删除，这个问题可以通过使用添加一个<code>RuntimeAnnotation</code>来解决</li></ol><h2 id=拦截器的更多用法>拦截器的更多用法</h2><p>拦截器还有一些其它玩法，比如<a href=https://learn.microsoft.com/en-us/ef/core/logging-events-diagnostics/interceptors#savechanges-interception>官方文档</a>中介绍了一个自动生成审计记录的案例</p><p>另外也许还能利用拦截器实现一个简易的&rsquo;Change Data Capture&rsquo;机制，但是感觉不是很靠谱，不在数据库上做CDC的话，数据可靠性不够</p></article></main><footer id=footer></footer></body></html>