<!doctype html><html><head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel="shortcut icon" href=http://suraciii.github.io/favicon.ico>
<link rel=stylesheet href=/css/style.min.css>
<title>.NET Activity API中的一个小陷阱</title>
</head>
<body><header id=banner>
<h2><a href=http://suraciii.github.io/>The Dice Maker</a></h2>
<nav>
<ul>
</ul>
</nav>
</header>
<main id=content>
<article>
<header id=post-header>
<h1>.NET Activity API中的一个小陷阱</h1>
<div>
<time>January 27, 2022</time>
</div>
</header><p>最近在为Orleans改进其分布式追踪组件(<a href=https://github.com/dotnet/orleans/pull/7443>Use DistributedContextPropagator to propagate Activities</a>)的时候，从AspNetCore中抄了一些代码:</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#998;font-style:italic>// https://github.com/dotnet/aspnetcore/blob/9da42b9fab4c61fe46627ac0c6877905ec845d5a/src/Hosting/Hosting/src/Internal/HostingApplicationDiagnostics.cs#L272
</span><span style=color:#998;font-style:italic></span>
<span style=color:#000;font-weight:700>private</span> Activity? StartActivity(HttpContext httpContext, <span style=color:#458;font-weight:700>bool</span> loggingEnabled, <span style=color:#458;font-weight:700>bool</span> diagnosticListenerActivityCreationEnabled, <span style=color:#000;font-weight:700>out</span> <span style=color:#458;font-weight:700>bool</span> hasDiagnosticListener)
{
	<span style=color:#458;font-weight:700>var</span> activity = <span style=color:#099>_</span>activitySource.CreateActivity(ActivityName, ActivityKind.Server);
	<span style=color:#998;font-style:italic>// ...
</span><span style=color:#998;font-style:italic></span>	<span style=color:#458;font-weight:700>var</span> headers = httpContext.Request.Headers;
	<span style=color:#099>_</span>propagator.ExtractTraceIdAndState(headers,
		<span style=color:#000;font-weight:700>static</span> (<span style=color:#458;font-weight:700>object?</span> carrier, <span style=color:#458;font-weight:700>string</span> fieldName, <span style=color:#000;font-weight:700>out</span> <span style=color:#458;font-weight:700>string?</span> fieldValue, <span style=color:#000;font-weight:700>out</span> IEnumerable&lt;<span style=color:#458;font-weight:700>string</span>&gt;? fieldValues) =&gt;
		{
			fieldValues = <span style=color:#000;font-weight:700>default</span>;
			<span style=color:#458;font-weight:700>var</span> headers = (IHeaderDictionary)carrier!;
			fieldValue = headers[fieldName];
		},
		<span style=color:#000;font-weight:700>out</span> <span style=color:#458;font-weight:700>var</span> requestId,
		<span style=color:#000;font-weight:700>out</span> <span style=color:#458;font-weight:700>var</span> traceState);

	<span style=color:#998;font-style:italic>// ...
</span><span style=color:#998;font-style:italic></span>	activity.SetParentId(requestId);
	<span style=color:#000;font-weight:700>if</span> (!<span style=color:#458;font-weight:700>string</span>.IsNullOrEmpty(traceState))
	{
		activity.TraceStateString = traceState;
	}
}
</code></pre></div><p>这段代码的作用是，创建Activity后，从请求头中尝试获取追踪信息（traceid等），如果存在的话，就通过<code>activity.SetParentId(requestId)</code>将这个新创建的Activity与请求头中的追踪上下文关联，即进入链路成为其中的一个子片段。</p>
<p>这个逻辑看起来没什么问题，也有相关的单元测试覆盖，于是我把这段代码抄到了Orleans里并最终合并进主干，但是不久后有一个开发者提了issue，报告了其中的问题——</p>
<blockquote>
<p>在使用OpenTelemetry SDK捕获Activities从而产生分布式追踪信息后，这些Activity所代表的Span并没有根据请求链路关联起来，而是各自成为了独立的链路。</p>
</blockquote>
<p>这就十分令人好奇了——这是从AspNetCore代码库里抄来的代码，也有相关测试覆盖，为什么还会有问题？
于是使用OpenTelemetry SDK重现了这个bug并仔细调试后，发现了问题出现的原因：</p>
<p>OpenTelemetry SDK记录应用的Activity时，有一个默认的采样器(Sampler)，在这个采样器中它会在创建Activity时访问相关<code>ActivityCreationOptions</code>中的<code>.TraceId</code>属性，再看其源码：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#998;font-style:italic>// https://github.com/dotnet/runtime/blob/970d347a1b06951692cfecc1cc12a500158708b1/src/libraries/System.Diagnostics.DiagnosticSource/src/System/Diagnostics/ActivityCreationOptions.cs#L128
</span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>public</span> ActivityTraceId TraceId
{
	<span style=color:#000;font-weight:700>get</span>
	{
		<span style=color:#000;font-weight:700>if</span> (Parent <span style=color:#000;font-weight:700>is</span> ActivityContext &amp;&amp; IdFormat == ActivityIdFormat.W3C &amp;&amp; <span style=color:#099>_</span>context == <span style=color:#000;font-weight:700>default</span>)
		{
			Func&lt;ActivityTraceId&gt;? traceIdGenerator = Activity.TraceIdGenerator;
			ActivityTraceId id = traceIdGenerator == <span style=color:#000;font-weight:700>null</span> ? ActivityTraceId.CreateRandom() : traceIdGenerator();

			Unsafe.AsRef(<span style=color:#000;font-weight:700>in</span> <span style=color:#099>_</span>context) = <span style=color:#000;font-weight:700>new</span> ActivityContext(id, <span style=color:#000;font-weight:700>default</span>, ActivityTraceFlags.None);
		}

		<span style=color:#000;font-weight:700>return</span> <span style=color:#099>_</span>context.TraceId;
	}
}
</code></pre></div><p>也就是说，访问<code>.TraceId</code>时，如果它还没有traceid，就生成一个并返回，最终被配置到新创建的Activity中，而Activity的TraceId只能被配置一次，也就是说如果traceid已经存在，后面的<code>activity.SetParentId(requestId)</code>就不会产生作用。</p>
<p>所以最终，每个Activity都单独生成了自己的traceid，没有使用进入父级链路。</p>
<p>查看<code>SetParentId</code>这个API的文档时，也发现了建议谨慎使用的注释：</p>
<blockquote>
<p>This is intended to be used only at &lsquo;boundary&rsquo; scenarios where an activity from another process logically started this activity.</p>
</blockquote>
<h4 id=为什么单元测试里没有问题>为什么单元测试里没有问题？</h4>
<p>单元测试里虽然也使用了采样器，但是并没有在采样器中访问<code>TraceId</code>，所以不会出现上述问题，而在采样器中加入了对<code>TraceId</code>的访问后，也成功复现了这个bug</p>
<h4 id=为什么opentelemetry-sdk采集aspnetcore的activities就没有这个问题>为什么OpenTelemetry SDK采集AspNetCore的Activities就没有这个问题？</h4>
<p>因为OpenTelemetry SDK没有直接采集AspNetCore生成的Activities，而是hook了相关生命周期事件，生成并采集自定义的Activities，如果它直接采集AspNetCore产生的Activities，也会有这个问题，这是AspNetCore代码中的一个缺陷，有一个<a href=https://github.com/dotnet/aspnetcore/issues/37471#issuecomment-972083624>issue</a>记录了它</p>
<p>总结和教训：</p>
<ul>
<li>只有单元测试是不够的，还要进行端到端的测试</li>
<li>不能盲目信任“权威”代码，它也有bug</li>
<li>这种明明只是访问一个属性却产生了副作用的做法是不好的，一方面它容易引入错误，另一方面出错后也很难进行相关的debug</li>
</ul>
</article>
</main><footer id=footer>
</footer>
</body>
</html>