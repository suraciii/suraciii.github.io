---
title: "事件驱动架构：事件怎么设计"
date: 2023-07-27T00:00:00Z
draft: true
---

当我们在系统中发送一些消息时，可能会有以下三种原因：
* 我要对方为我做某些事
* 系统中发生了某些事
* 我想知道对方的某些信息

在这三种场景中的三种不同的消息分别对应着命令，事件和查询

我喜欢用一个星巴克的例子来解释这三种形式的消息：

* 当你走进一家星巴克，但是你有些犹豫要喝点什么，于是你问店员最近有什么新品 —— 这是查询
* 但是你最终还是只想来一杯拿铁，于是你礼貌但是强硬地要求店员为你调制一杯拿铁，你会一直紧紧地盯着他，除非拿到小票，否则你不会离开收银台 —— 这是命令
* 咖啡师将调好的拿铁放在取餐处，并大喊一声“X先生/女士的拿铁好了”后转身离开，他不关心你是否听到了，甚至不关心你是否还在此处 —— 这是事件

（这个例子的灵感来源于《星巴克不用2PC》）

总结下来，这三种形式的消息具有以下的特性：

| 消息 | 行为/状态变更 | 需要响应 |
|------|-------------|---------|
| 命令 | 请求发生      | 也许    |
| 事件 | 刚发生过      | 否      |
| 查询 | 无           | 是      |

理解这三种消息，尤其是命令与事件之间的区别，对于如何设计一个成功的事件驱动系统来说至关重要

## 以事件替代命令

假设一个场景：在一个电商微服务系统中，有着若干个模块，其中包括  
* 商品目录模块(Catalog)： 负责维护商品信息
* 购物车模块(Basket)： 负责维护顾客的购物车信息
* 通知模块(Notification)： 负责给顾客发送促销通知

假设我们需要实现一个功能：在运营人员变更商品价格后，更新用户购物车中的商品价格

一个直观的实现方式是，为购物车模块实现一个用于更新顾客购物车中的商品价格的接口(在微服务系统中，这通常是一个REST或RPC的API)，并由商品目录模块在更新商品价格时进行调用

稍有经验的开发者就能看出，这样的设计有着几个问题：
* 对顾客购物车的更新阻塞了对商品价格的更新
* 在分布式系统中，网络请求具备着不确定性，尤其在请求链路较长和请求耗时较长的情况下更是如此
* 由于网络中断，或者用户取消了请求，更新中断了，数据出现了不一致

而对于具备微服务架构设计经验的人来说，很可能还会看到另外的问题：

在这种模式下，商品目录模块调用了购物车模块的一个接口，这使商品目录模块显式地依赖着购物车模块  
而购物车模块公开了一个接口，但是这个接口却不属于购物车模块自己，这个接口是为了商品目录模块而存在的，是为了响应对方的变化而存在的，并且，购物车模块中的商品信息、价格信息，是来自于商品目录模块中的业务知识，这意味着购物车模块隐式地依赖着商品目录模块  
更何况，通常这种情况下，购物车模块也会显式地依赖商品目录模块——比如在用户添加商品到购物车时，购物车也许需要检查商品是否已被下架等

这时，模块间出现双向依赖，它的坏味道足以令敏感的架构师皱起眉头，甚至坐立难安，仿佛已经看到了在未来，随着系统的不断演进，这两个模块耦合的越来越深，任何改动都必须在二者上同时进行，或者是，其中一个模块的血液逐渐被另一个模块所吸食，成为一个只有CRUD没有自己的业务逻辑的贫血模块，最后逐渐被对方吞并，成为其中的一部分


这时，我们也许可以换个角度来重新看这个功能：

> 用户购物车中的商品价格，需要**响应**商品价格信息的变更

按照这样的描述，我们来重新实现这个功能  

其中一个简单的做法是，购物车模块根本不保存商品的价格信息，而是只在需要这些信息时，才前往商品目录服务进行查询，这种方式解决了上面所说的问题，简单而有效，但是这基本只适合我们例子里的当前场景，当业务逻辑更丰满，更复杂起来后，就行不通了，比如，如果需要给购物车中有商品降价的顾客发送促销通知。
（事实上，如果没有这样的复杂场景的话，购物车模块就不会也不应该存在）

因此，此时就适合以事件的形式来完成模块间的通信

在商品价格变更后，商品目录模块发布一条商品价格已变更(`CatalogItemPriceChanged`)的事件到事件基础设施，而任何对此事件感兴趣的模块，都可以通过事件基础设施订阅此事件，订阅事件后，由事件基础设施负责将事件交付到相关模块，并由各模块对此进行响应

在这种情况下，商品目录模块对购物车模块的显式依赖被反转，购物车中的商品价格更新不再阻塞商品目录模块中的业务执行，*最终*也保证了数据的一致性

## 事件协作

聊完两个模块之间的协作，再来看整个系统下的协作
既然说是“事件驱动架构”，那么当然就要以事件来触发模块中的业务行为，甚至要以事件来驱动整个业务流程，还是以电商系统为例，实现事件驱动架构，经常就会很自然地产出类似下面的事件流(EventFlow)：

* 用户创建订单，订单模块发布`订单已创建`事件
* 支付模块订阅`订单已创建`事件，处理完成后发布`支付已完成`事件
* 库存模块订阅`支付已完成`事件，处理完成后发布`商品已出库`事件
* 配送模块订阅`商品已出库`事件，处理完成后发布...

这里只是一个极度简化版的事件流，一个完整的流程应该还要包含相应的补偿事件，比如`支付失败`和`商品出库失败`等事件，以取得跨模块，跨数据库的业务一致性（这被称为Saga）

这样的系统中不仅以事件来触发模块中的业务行为，甚至也以事件来驱动着整个业务流程的流转，看起来十分地“事件驱动”，但是，实际上它是一个**极**糟糕的设计，我衷心的祝福每个设计事件驱动的微服务系统的人能在设计之初就能意识到这点，否则它将会给项目带来无尽的痛苦和灾难。

下面用前面说过的依赖分析的方法，来整理这个系统下各个组件的依赖关系。

直觉上，和前面一样，是事件的消费方依赖于事件的生产方，即：


但是当我们深入下去，就会看到：
* 创建订单时需要记录`支付方法`，但是显然，`支付方法`是属于`支付模块`中的概念，这使`订单模块`在上下文上依赖了`支付模块`
* 订单模块需要订阅`支付已完成`和`商品已出库`，来更新订单的付款状态和出库状态，因此，`订单模块`依赖了`支付模块`和`库存模块`，实际上后面还要依赖`配送模块`
再加上我们上面提到的补偿事件，最终，这些模块互相依赖，形成了依赖地狱

## 事件中的信息

正如前文所说，事件是一种消息，那事件中应该携带哪些信息，携带多少信息，就是一个非常值得谨慎设计的地方

以 商品价格已变更 事件为例，其中一个思路是，既然购物车模块需要响应这个事件，那么就为它来提供它所需要的信息吧

```golang
type CatalogItemPriceChanged {
	string CatalogItemId,
	Number Price
}
```




